using System;
using System.Runtime.CompilerServices;

namespace Ionic.Zlib
{
	// Token: 0x0200009F RID: 159
	internal sealed class InflateBlocks
	{
		// Token: 0x0600063D RID: 1597 RVA: 0x0002BD6C File Offset: 0x00029F6C
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal InflateBlocks(ZlibCodec codec, object checkfn, int p2)
		{
			this._codec = codec;
			this.hufts = new int[4320];
			this.window = new byte[p2];
			this.end = p2;
			this.checkfn = checkfn;
			this.mode = InflateBlocks.InflateBlockMode.TYPE;
			this.Reset();
		}

		// Token: 0x0600063E RID: 1598 RVA: 0x0002BDEC File Offset: 0x00029FEC
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal uint Reset()
		{
			uint result;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						this.bitk = 0;
						this.bitb = 0;
						this.readAt = (this.writeAt = 0);
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						return result;
					case 2:
						if (this.checkfn != null)
						{
							this._codec._Adler32 = (this.check = Adler.Adler32(0U, null, 0, 0));
							num = delegate0da.f0000d7(-1);
							continue;
						}
						return result;
					case 3:
						result = this.check;
						this.mode = InflateBlocks.InflateBlockMode.TYPE;
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			return result;
		}

		// Token: 0x0600063F RID: 1599 RVA: 0x0002BED8 File Offset: 0x0002A0D8
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal int Process(int p0)
		{
			bool flag;
			int num2;
			int num3;
			int num4;
			int num5;
			int num6;
			int num7;
			int num8;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						if (!flag)
						{
							flag = (num2 != this.end || this.readAt == 0);
							if (!flag)
							{
								num2 = 0;
								num3 = ((num2 < this.readAt) ? (this.readAt - num2 - 1) : (this.end - num2));
							}
							flag = (num3 != 0);
							if (!flag)
							{
								this.writeAt = num2;
								p0 = this.Flush(p0);
								num2 = this.writeAt;
								num3 = ((num2 < this.readAt) ? (this.readAt - num2 - 1) : (this.end - num2));
								flag = (num2 != this.end || this.readAt == 0);
								if (!flag)
								{
									num2 = 0;
									num3 = ((num2 < this.readAt) ? (this.readAt - num2 - 1) : (this.end - num2));
								}
								flag = (num3 != 0);
								if (!flag)
								{
									goto Block_40;
								}
							}
						}
						p0 = 0;
						num4 = this.left;
						flag = (num4 <= num5);
						if (!flag)
						{
							num4 = num5;
						}
						flag = (num4 <= num3);
						if (!flag)
						{
							num4 = num3;
						}
						Array.Copy(this._codec.InputBuffer, num6, this.window, num2, num4);
						num6 += num4;
						num5 -= num4;
						num2 += num4;
						num3 -= num4;
						flag = ((this.left -= num4) == 0);
						if (!flag)
						{
							goto IL_689;
						}
						this.mode = ((this.last != 0) ? InflateBlocks.InflateBlockMode.DRY : InflateBlocks.InflateBlockMode.TYPE);
						goto IL_689;
					case 1:
						goto IL_F7A;
					case 2:
						goto IL_36;
					case 3:
						num6 = this._codec.NextIn;
						num5 = this._codec.AvailableBytesIn;
						num7 = this.bitb;
						num8 = this.bitk;
						num2 = this.writeAt;
						num3 = ((num2 < this.readAt) ? (this.readAt - num2 - 1) : (this.end - num2));
						goto IL_689;
					}
					break;
					for (;;)
					{
						IL_689:
						flag = true;
						int[] array;
						int[] array2;
						switch (this.mode)
						{
						case InflateBlocks.InflateBlockMode.TYPE:
							for (;;)
							{
								flag = (num8 < 3);
								if (!flag)
								{
									break;
								}
								flag = (num5 == 0);
								if (flag)
								{
									goto IL_79D;
								}
								p0 = 0;
								num5--;
								num7 |= (int)(this._codec.InputBuffer[num6++] & byte.MaxValue) << num8;
								num8 += 8;
							}
							num4 = (num7 & 7);
							this.last = (num4 & 1);
							switch ((uint)num4 >> 1)
							{
							case 0U:
								num7 >>= 3;
								num8 -= 3;
								num4 = (num8 & 7);
								num7 >>= num4;
								num8 -= num4;
								this.mode = InflateBlocks.InflateBlockMode.LENS;
								continue;
							case 1U:
							{
								array = new int[1];
								array2 = new int[1];
								int[][] array3 = new int[1][];
								int[][] array4 = new int[1][];
								InfTree.inflate_trees_fixed(array, array2, array3, array4, this._codec);
								this.codes.Init(array[0], array2[0], array3[0], 0, array4[0], 0);
								num7 >>= 3;
								num8 -= 3;
								this.mode = InflateBlocks.InflateBlockMode.CODES;
								continue;
							}
							case 2U:
								num7 >>= 3;
								num8 -= 3;
								this.mode = InflateBlocks.InflateBlockMode.TABLE;
								continue;
							case 3U:
								goto IL_898;
							default:
								continue;
							}
							break;
						case InflateBlocks.InflateBlockMode.LENS:
							for (;;)
							{
								flag = (num8 < 32);
								if (!flag)
								{
									break;
								}
								flag = (num5 == 0);
								if (flag)
								{
									goto IL_A01;
								}
								p0 = 0;
								num5--;
								num7 |= (int)(this._codec.InputBuffer[num6++] & byte.MaxValue) << num8;
								num8 += 8;
							}
							flag = ((~num7 >> 16 & 65535) == (num7 & 65535));
							if (!flag)
							{
								goto Block_27;
							}
							this.left = (num7 & 65535);
							num8 = (num7 = 0);
							this.mode = ((this.left != 0) ? InflateBlocks.InflateBlockMode.STORED : ((this.last != 0) ? InflateBlocks.InflateBlockMode.DRY : InflateBlocks.InflateBlockMode.TYPE));
							continue;
						case InflateBlocks.InflateBlockMode.STORED:
							goto IL_A9C;
						case InflateBlocks.InflateBlockMode.TABLE:
							for (;;)
							{
								flag = (num8 < 14);
								if (!flag)
								{
									break;
								}
								flag = (num5 == 0);
								if (flag)
								{
									goto IL_D5A;
								}
								p0 = 0;
								num5--;
								num7 |= (int)(this._codec.InputBuffer[num6++] & byte.MaxValue) << num8;
								num8 += 8;
							}
							num4 = (this.table = (num7 & 16383));
							flag = ((num4 & 31) <= 29 && (num4 >> 5 & 31) <= 29);
							if (!flag)
							{
								goto Block_48;
							}
							num4 = 258 + (num4 & 31) + (num4 >> 5 & 31);
							flag = (this.blens != null && this.blens.Length >= num4);
							if (!flag)
							{
								this.blens = new int[num4];
							}
							else
							{
								delegate0100.f000125(this.blens, 0, num4);
							}
							num7 >>= 14;
							num8 -= 14;
							this.index = 0;
							this.mode = InflateBlocks.InflateBlockMode.BTREE;
							goto IL_C7;
						case InflateBlocks.InflateBlockMode.BTREE:
							goto IL_C7;
						case InflateBlocks.InflateBlockMode.DTREE:
							goto IL_231;
						case InflateBlocks.InflateBlockMode.CODES:
							IL_1015:
							this.bitb = num7;
							this.bitk = num8;
							this._codec.AvailableBytesIn = num5;
							this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
							this._codec.NextIn = num6;
							this.writeAt = num2;
							p0 = this.codes.Process(this, p0);
							flag = (p0 == 1);
							if (!flag)
							{
								goto Block_52;
							}
							p0 = 0;
							num6 = this._codec.NextIn;
							num5 = this._codec.AvailableBytesIn;
							num7 = this.bitb;
							num8 = this.bitk;
							num2 = this.writeAt;
							num3 = ((num2 < this.readAt) ? (this.readAt - num2 - 1) : (this.end - num2));
							flag = (this.last != 0);
							if (!flag)
							{
								this.mode = InflateBlocks.InflateBlockMode.TYPE;
								continue;
							}
							goto IL_1109;
						case InflateBlocks.InflateBlockMode.DRY:
							goto IL_1110;
						case InflateBlocks.InflateBlockMode.DONE:
							goto IL_11CD;
						case InflateBlocks.InflateBlockMode.BAD:
							goto IL_122C;
						}
						goto Block_21;
						for (;;)
						{
							IL_C7:
							flag = (this.index < 4 + (this.table >> 10));
							if (!flag)
							{
								break;
							}
							for (;;)
							{
								flag = (num8 < 3);
								if (!flag)
								{
									break;
								}
								flag = (num5 == 0);
								if (flag)
								{
									goto IL_F28;
								}
								p0 = 0;
								num5--;
								num7 |= (int)(this._codec.InputBuffer[num6++] & byte.MaxValue) << num8;
								num8 += 8;
							}
							this.blens[InflateBlocks.border[this.index++]] = (num7 & 7);
							num7 >>= 3;
							num8 -= 3;
						}
						for (;;)
						{
							flag = (this.index < 19);
							if (!flag)
							{
								break;
							}
							this.blens[InflateBlocks.border[this.index++]] = 0;
						}
						this.f00006b[0] = 7;
						num4 = this.inftree.inflate_trees_bits(this.blens, this.f00006b, this.f00006c, this.hufts, this._codec);
						flag = (num4 == 0);
						if (!flag)
						{
							goto Block_5;
						}
						this.index = 0;
						this.mode = InflateBlocks.InflateBlockMode.DTREE;
						for (;;)
						{
							IL_231:
							flag = true;
							num4 = this.table;
							flag = (this.index < 258 + (num4 & 31) + (num4 >> 5 & 31));
							if (!flag)
							{
								break;
							}
							num4 = this.f00006b[0];
							for (;;)
							{
								flag = (num8 < num4);
								if (!flag)
								{
									break;
								}
								flag = (num5 == 0);
								if (flag)
								{
									goto IL_442;
								}
								p0 = 0;
								num5--;
								num7 |= (int)(this._codec.InputBuffer[num6++] & byte.MaxValue) << num8;
								num8 += 8;
							}
							num4 = this.hufts[(this.f00006c[0] + (num7 & InternalInflateConstants.InflateMask[num4])) * 3 + 1];
							int num9 = this.hufts[(this.f00006c[0] + (num7 & InternalInflateConstants.InflateMask[num4])) * 3 + 2];
							flag = (num9 >= 16);
							if (!flag)
							{
								num7 >>= num4;
								num8 -= num4;
								this.blens[this.index++] = num9;
							}
							else
							{
								int num10 = (num9 == 18) ? 7 : (num9 - 14);
								int num11 = (num9 == 18) ? 11 : 3;
								for (;;)
								{
									flag = (num8 < num4 + num10);
									if (!flag)
									{
										break;
									}
									flag = (num5 == 0);
									if (flag)
									{
										goto IL_586;
									}
									p0 = 0;
									num5--;
									num7 |= (int)(this._codec.InputBuffer[num6++] & byte.MaxValue) << num8;
									num8 += 8;
								}
								num7 >>= num4;
								num8 -= num4;
								num11 += (num7 & InternalInflateConstants.InflateMask[num10]);
								num7 >>= num10;
								num8 -= num10;
								num10 = this.index;
								num4 = this.table;
								if (num10 + num11 > 258 + (num4 & 31) + (num4 >> 5 & 31))
								{
									goto IL_5E2;
								}
								if (num9 == 16)
								{
									flag = (num10 >= 1);
									if (!flag)
									{
										goto IL_5F0;
									}
								}
								num9 = ((num9 == 16) ? this.blens[num10 - 1] : 0);
								do
								{
									this.blens[num10++] = num9;
									flag = (--num11 != 0);
								}
								while (flag);
								this.index = num10;
							}
						}
						this.f00006c[0] = -1;
						array = new int[]
						{
							9
						};
						array2 = new int[]
						{
							6
						};
						int[] array5 = new int[1];
						int[] array6 = new int[1];
						num4 = this.table;
						num4 = this.inftree.inflate_trees_dynamic(257 + (num4 & 31), 1 + (num4 >> 5 & 31), this.blens, array, array2, array5, array6, this.hufts, this._codec);
						flag = (num4 == 0);
						if (!flag)
						{
							goto Block_9;
						}
						this.codes.Init(array[0], array2[0], this.hufts, array5[0], this.hufts, array6[0]);
						this.mode = InflateBlocks.InflateBlockMode.CODES;
						goto IL_1015;
					}
					IL_5F0:
					this.blens = null;
					this.mode = InflateBlocks.InflateBlockMode.BAD;
					this._codec.Message = c0000c0.m00000f("øo;\u0005Ê\0W\u0017Î\u001b:\fdò#\0âêN\u0014H´\u007fÌ'");
					p0 = -3;
					num = delegate0da.f0000d7(-1);
					continue;
					IL_A9C:
					flag = (num5 != 0);
					if (!flag)
					{
						goto Block_30;
					}
					flag = (num3 != 0);
					num = delegate0da.f0000d7(0);
					continue;
					IL_F28:
					this.bitb = num7;
					this.bitk = num8;
					this._codec.AvailableBytesIn = num5;
					this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
					num = delegate0da.f0000d7(-2);
					continue;
					IL_5E2:
					goto IL_5F0;
				}
			}
			IL_36:
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			Block_5:
			p0 = num4;
			flag = (p0 != -3);
			if (!flag)
			{
				this.blens = null;
				this.mode = InflateBlocks.InflateBlockMode.BAD;
			}
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			Block_9:
			flag = (num4 != -3);
			if (!flag)
			{
				this.blens = null;
				this.mode = InflateBlocks.InflateBlockMode.BAD;
			}
			p0 = num4;
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			IL_442:
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			IL_586:
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			Block_21:
			p0 = -2;
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			IL_79D:
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			IL_898:
			num7 >>= 3;
			num8 -= 3;
			this.mode = InflateBlocks.InflateBlockMode.BAD;
			this._codec.Message = c0000c0.m00000f("øo;\u0005Ê\0W\u0017Î\u001e!Oc·9\u001eæç");
			p0 = -3;
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			Block_27:
			this.mode = InflateBlocks.InflateBlockMode.BAD;
			this._codec.Message = c0000c0.m00000f("øo;\u0005Ê\0W\u0017ß\u0006!^móm\u0005úí\r\r\r¨\u007fÃ4Ê\u001f­");
			p0 = -3;
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			IL_A01:
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			Block_30:
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			Block_40:
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			IL_D5A:
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			Block_48:
			this.mode = InflateBlocks.InflateBlockMode.BAD;
			this._codec.Message = c0000c0.m00000f("ån\"DË\b]N\u008c\u001e+Boã%GùðN\u0002D·nÌ=Ý\u0012þdÁ\u008eÔr[9");
			p0 = -3;
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			IL_F7A:
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			Block_52:
			return this.Flush(p0);
			IL_1109:
			this.mode = InflateBlocks.InflateBlockMode.DRY;
			IL_1110:
			this.writeAt = num2;
			p0 = this.Flush(p0);
			num2 = this.writeAt;
			num3 = ((num2 < this.readAt) ? (this.readAt - num2 - 1) : (this.end - num2));
			flag = (this.readAt == this.writeAt);
			if (!flag)
			{
				this.bitb = num7;
				this.bitk = num8;
				this._codec.AvailableBytesIn = num5;
				this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
				this._codec.NextIn = num6;
				this.writeAt = num2;
				return this.Flush(p0);
			}
			this.mode = InflateBlocks.InflateBlockMode.DONE;
			IL_11CD:
			p0 = 1;
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
			IL_122C:
			p0 = -3;
			this.bitb = num7;
			this.bitk = num8;
			this._codec.AvailableBytesIn = num5;
			this._codec.TotalBytesIn += (long)(num6 - this._codec.NextIn);
			this._codec.NextIn = num6;
			this.writeAt = num2;
			return this.Flush(p0);
		}

		// Token: 0x06000640 RID: 1600 RVA: 0x0002D170 File Offset: 0x0002B370
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void Free()
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						this.Reset();
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_8D;
					case 2:
						this.window = null;
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_8D:
			this.hufts = null;
		}

		// Token: 0x06000641 RID: 1601 RVA: 0x0002D214 File Offset: 0x0002B414
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void SetDictionary(byte[] p0, int start, int p2)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						Array.Copy(p0, start, this.window, 0, p2);
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_8F;
					case 2:
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_8F:
			this.writeAt = p2;
			this.readAt = p2;
		}

		// Token: 0x06000642 RID: 1602 RVA: 0x0002D2C0 File Offset: 0x0002B4C0
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal int SyncPoint()
		{
			int result;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					int num2;
					switch (num)
					{
					case 0:
						if (this.mode != InflateBlocks.InflateBlockMode.LENS)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						num2 = 1;
						goto IL_3D;
					case 1:
						return result;
					case 2:
						num2 = 0;
						goto IL_3D;
					case 3:
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
					IL_3D:
					result = num2;
					num = delegate0da.f0000d7(-1);
				}
			}
			return result;
		}

		// Token: 0x06000643 RID: 1603 RVA: 0x0002D364 File Offset: 0x0002B564
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal int Flush(int p0)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					int num2;
					int num3;
					switch (num)
					{
					case 0:
						IL_17E:
						if (num2 == 0)
						{
							goto Block_7;
						}
						if (num2 > this._codec.AvailableBytesOut)
						{
							num2 = this._codec.AvailableBytesOut;
						}
						if (num2 != 0 && p0 == -5)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_39;
					case 1:
						this.readAt = 0;
						if (this.writeAt == this.end)
						{
							this.writeAt = 0;
							goto IL_110;
						}
						goto IL_110;
					case 2:
						p0 = 0;
						goto IL_39;
					case 3:
						num3 = 0;
						goto IL_114;
					}
					break;
					IL_39:
					this._codec.AvailableBytesOut -= num2;
					this._codec.TotalBytesOut += (long)num2;
					if (this.checkfn != null)
					{
						this._codec._Adler32 = (this.check = Adler.Adler32(this.check, this.window, this.readAt, num2));
					}
					Array.Copy(this.window, this.readAt, this._codec.OutputBuffer, this._codec.NextOut, num2);
					this._codec.NextOut += num2;
					this.readAt += num2;
					bool flag = this.readAt != this.end || num3 != 0;
					if (flag)
					{
						num3++;
						goto IL_110;
					}
					num = delegate0da.f0000d7(-1);
					continue;
					IL_114:
					if (num3 >= 2)
					{
						goto Block_4;
					}
					if (num3 == 0)
					{
						num2 = ((this.readAt <= this.writeAt) ? this.writeAt : this.end) - this.readAt;
						goto IL_17E;
					}
					num2 = this.writeAt - this.readAt;
					num = delegate0da.f0000d7(0);
					continue;
					IL_110:
					num3++;
					goto IL_114;
				}
			}
			Block_4:
			return p0;
			Block_7:
			if (p0 == -5)
			{
				p0 = 0;
			}
			return p0;
		}

		// Token: 0x06000644 RID: 1604 RVA: 0x0002D5BC File Offset: 0x0002B7BC
		// Note: this type is marked as 'beforefieldinit'.
		static InflateBlocks()
		{
			c0000c0.Initialize();
			c0000c0.PostInitialize();
			InflateBlocks.border = new int[]
			{
				16,
				17,
				18,
				0,
				8,
				7,
				9,
				6,
				10,
				5,
				11,
				4,
				12,
				3,
				13,
				2,
				14,
				1,
				15
			};
		}

		// Token: 0x040002F0 RID: 752
		private const int MANY = 1440;

		// Token: 0x040002F1 RID: 753
		internal static readonly int[] border;

		// Token: 0x040002F2 RID: 754
		private InflateBlocks.InflateBlockMode mode;

		// Token: 0x040002F3 RID: 755
		internal int left;

		// Token: 0x040002F4 RID: 756
		internal int table;

		// Token: 0x040002F5 RID: 757
		internal int index;

		// Token: 0x040002F6 RID: 758
		internal int[] blens;

		// Token: 0x040002F7 RID: 759
		internal int[] f00006b = new int[1];

		// Token: 0x040002F8 RID: 760
		internal int[] f00006c = new int[1];

		// Token: 0x040002F9 RID: 761
		internal InflateCodes codes = new InflateCodes();

		// Token: 0x040002FA RID: 762
		internal int last;

		// Token: 0x040002FB RID: 763
		internal ZlibCodec _codec;

		// Token: 0x040002FC RID: 764
		internal int bitk;

		// Token: 0x040002FD RID: 765
		internal int bitb;

		// Token: 0x040002FE RID: 766
		internal int[] hufts;

		// Token: 0x040002FF RID: 767
		internal byte[] window;

		// Token: 0x04000300 RID: 768
		internal int end;

		// Token: 0x04000301 RID: 769
		internal int readAt;

		// Token: 0x04000302 RID: 770
		internal int writeAt;

		// Token: 0x04000303 RID: 771
		internal object checkfn;

		// Token: 0x04000304 RID: 772
		internal uint check;

		// Token: 0x04000305 RID: 773
		internal InfTree inftree = new InfTree();

		// Token: 0x020000A0 RID: 160
		private enum InflateBlockMode
		{
			// Token: 0x04000307 RID: 775
			TYPE,
			// Token: 0x04000308 RID: 776
			LENS,
			// Token: 0x04000309 RID: 777
			STORED,
			// Token: 0x0400030A RID: 778
			TABLE,
			// Token: 0x0400030B RID: 779
			BTREE,
			// Token: 0x0400030C RID: 780
			DTREE,
			// Token: 0x0400030D RID: 781
			CODES,
			// Token: 0x0400030E RID: 782
			DRY,
			// Token: 0x0400030F RID: 783
			DONE,
			// Token: 0x04000310 RID: 784
			BAD
		}
	}
}
