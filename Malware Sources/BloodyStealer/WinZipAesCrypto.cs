using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;

namespace Ionic.Zip
{
	// Token: 0x02000068 RID: 104
	internal class WinZipAesCrypto
	{
		// Token: 0x06000310 RID: 784 RVA: 0x000133C4 File Offset: 0x000115C4
		[MethodImpl(MethodImplOptions.NoInlining)]
		private WinZipAesCrypto(string password, int KeyStrengthInBits)
		{
			this._Password = password;
			this._KeyStrengthInBits = KeyStrengthInBits;
		}

		// Token: 0x06000311 RID: 785 RVA: 0x000133E8 File Offset: 0x000115E8
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static WinZipAesCrypto Generate(string password, int KeyStrengthInBits)
		{
			WinZipAesCrypto winZipAesCrypto;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
					{
						int num2 = winZipAesCrypto._KeyStrengthInBytes / 2;
						num = delegate0da.f0000d7(-2);
						continue;
					}
					case 1:
						goto IL_9B;
					case 2:
					{
						int num2;
						winZipAesCrypto._Salt = new byte[num2];
						num = delegate0da.f0000d7(-1);
						continue;
					}
					case 3:
						winZipAesCrypto = new WinZipAesCrypto(password, KeyStrengthInBits);
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_9B:
			Random p = new Random();
			delegate0143.f000184(p, winZipAesCrypto._Salt);
			return winZipAesCrypto;
		}

		// Token: 0x06000312 RID: 786 RVA: 0x000134A8 File Offset: 0x000116A8
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static WinZipAesCrypto ReadFromStream(string password, int KeyStrengthInBits, Stream p2)
		{
			WinZipAesCrypto winZipAesCrypto;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						winZipAesCrypto._providedPv = new byte[2];
						delegate0144.f000185(p2, winZipAesCrypto._Salt, 0, winZipAesCrypto._Salt.Length);
						delegate0144.f000185(p2, winZipAesCrypto._providedPv, 0, winZipAesCrypto._providedPv.Length);
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_11F;
					case 2:
						winZipAesCrypto.PasswordVerificationStored = (short)((int)winZipAesCrypto._providedPv[0] + (int)winZipAesCrypto._providedPv[1] * 256);
						if (password != null)
						{
							winZipAesCrypto.PasswordVerificationGenerated = (short)((int)winZipAesCrypto.GeneratedPV[0] + (int)winZipAesCrypto.GeneratedPV[1] * 256);
							num = delegate0da.f0000d7(-1);
							continue;
						}
						return winZipAesCrypto;
					case 3:
					{
						winZipAesCrypto = new WinZipAesCrypto(password, KeyStrengthInBits);
						int num2 = winZipAesCrypto._KeyStrengthInBytes / 2;
						winZipAesCrypto._Salt = new byte[num2];
						num = delegate0da.f0000d7(0);
						continue;
					}
					}
					break;
				}
			}
			IL_11F:
			if (winZipAesCrypto.PasswordVerificationGenerated != winZipAesCrypto.PasswordVerificationStored)
			{
				throw new BadPasswordException(c0000c0.m00000f("ó`)DÖ\b@DÛ\u001d<H"));
			}
			return winZipAesCrypto;
		}

		// Token: 0x1700008E RID: 142
		// (get) Token: 0x06000313 RID: 787 RVA: 0x000135F8 File Offset: 0x000117F8
		public byte[] GeneratedPV
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				if (!this._cryptoGenerated)
				{
					this._GenerateCryptoBytes();
				}
				return this._generatedPv;
			}
		}

		// Token: 0x1700008F RID: 143
		// (get) Token: 0x06000314 RID: 788 RVA: 0x0001361C File Offset: 0x0001181C
		public byte[] Salt
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._Salt;
			}
		}

		// Token: 0x17000090 RID: 144
		// (get) Token: 0x06000315 RID: 789 RVA: 0x00013630 File Offset: 0x00011830
		private int _KeyStrengthInBytes
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._KeyStrengthInBits / 8;
			}
		}

		// Token: 0x17000091 RID: 145
		// (get) Token: 0x06000316 RID: 790 RVA: 0x00013648 File Offset: 0x00011848
		public int SizeOfEncryptionMetadata
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._KeyStrengthInBytes / 2 + 10 + 2;
			}
		}

		// Token: 0x17000092 RID: 146
		// (set) Token: 0x06000317 RID: 791 RVA: 0x00013664 File Offset: 0x00011864
		public string Password
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							if (this._Password != null)
							{
								num = delegate0da.f0000d7(-2);
								continue;
							}
							return;
						case 1:
							goto IL_AE;
						case 2:
							this.PasswordVerificationGenerated = (short)((int)this.GeneratedPV[0] + (int)this.GeneratedPV[1] * 256);
							num = delegate0da.f0000d7(-1);
							continue;
						case 3:
							this._Password = value;
							num = delegate0da.f0000d7(0);
							continue;
						}
						break;
					}
				}
				IL_AE:
				if (this.PasswordVerificationGenerated != this.PasswordVerificationStored)
				{
					throw new BadPasswordException();
				}
			}
		}

		// Token: 0x06000318 RID: 792 RVA: 0x00013738 File Offset: 0x00011938
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void _GenerateCryptoBytes()
		{
			Rfc2898DeriveBytes p;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						this._keyBytes = delegate0145.f000186(p, this._KeyStrengthInBytes);
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_C4;
					case 2:
						this._MacInitializationVector = delegate0145.f000186(p, this._KeyStrengthInBytes);
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
						p = new Rfc2898DeriveBytes(this._Password, this.Salt, this.Rfc2898KeygenIterations);
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_C4:
			this._generatedPv = delegate0145.f000186(p, 2);
			this._cryptoGenerated = true;
		}

		// Token: 0x17000093 RID: 147
		// (get) Token: 0x06000319 RID: 793 RVA: 0x00013824 File Offset: 0x00011A24
		public byte[] KeyBytes
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				if (!this._cryptoGenerated)
				{
					this._GenerateCryptoBytes();
				}
				return this._keyBytes;
			}
		}

		// Token: 0x17000094 RID: 148
		// (get) Token: 0x0600031A RID: 794 RVA: 0x00013848 File Offset: 0x00011A48
		public byte[] MacIv
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				if (!this._cryptoGenerated)
				{
					this._GenerateCryptoBytes();
				}
				return this._MacInitializationVector;
			}
		}

		// Token: 0x0600031B RID: 795 RVA: 0x0001386C File Offset: 0x00011A6C
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void ReadAndVerifyMac(Stream p0)
		{
			bool flag;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					int num2;
					switch (num)
					{
					case 0:
						if (this._StoredMac.Length != this.CalculatedMac.Length)
						{
							goto Block_2;
						}
						if (!flag)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_FE;
					case 1:
						flag = true;
						goto IL_EA;
					case 2:
						num2 = 0;
						goto IL_EE;
					case 3:
						flag = false;
						this._StoredMac = new byte[10];
						delegate0144.f000185(p0, this._StoredMac, 0, this._StoredMac.Length);
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
					IL_EE:
					if (num2 >= this._StoredMac.Length)
					{
						goto IL_FE;
					}
					if (this._StoredMac[num2] != this.CalculatedMac[num2])
					{
						num = delegate0da.f0000d7(-1);
						continue;
					}
					IL_EA:
					num2++;
					goto IL_EE;
				}
			}
			Block_2:
			IL_FE:
			if (flag)
			{
				throw new BadStateException(c0000c0.m00000f("Åi(Dë(p\u0017È\u001d+_(ù\"\u0013¶ï\u000f\u0012N¬4"));
			}
		}

		// Token: 0x0600031C RID: 796 RVA: 0x00013990 File Offset: 0x00011B90
		// Note: this type is marked as 'beforefieldinit'.
		[MethodImpl(MethodImplOptions.NoInlining)]
		static WinZipAesCrypto()
		{
			c0000c0.Initialize();
			c0000c0.PostInitialize();
		}

		// Token: 0x0400012B RID: 299
		internal byte[] _Salt;

		// Token: 0x0400012C RID: 300
		internal byte[] _providedPv;

		// Token: 0x0400012D RID: 301
		internal byte[] _generatedPv;

		// Token: 0x0400012E RID: 302
		internal int _KeyStrengthInBits;

		// Token: 0x0400012F RID: 303
		private byte[] _MacInitializationVector;

		// Token: 0x04000130 RID: 304
		private byte[] _StoredMac;

		// Token: 0x04000131 RID: 305
		private byte[] _keyBytes;

		// Token: 0x04000132 RID: 306
		private short PasswordVerificationStored;

		// Token: 0x04000133 RID: 307
		private short PasswordVerificationGenerated;

		// Token: 0x04000134 RID: 308
		private int Rfc2898KeygenIterations = 1000;

		// Token: 0x04000135 RID: 309
		private string _Password;

		// Token: 0x04000136 RID: 310
		private bool _cryptoGenerated;

		// Token: 0x04000137 RID: 311
		public byte[] CalculatedMac;
	}
}
