using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;

namespace Ionic.Zip
{
	// Token: 0x02000069 RID: 105
	internal class WinZipAesCipherStream : Stream
	{
		// Token: 0x0600031D RID: 797 RVA: 0x0001399C File Offset: 0x00011B9C
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal WinZipAesCipherStream(Stream p0, WinZipAesCrypto cryptoParams, long length, CryptoMode mode) : this(p0, cryptoParams, mode)
		{
			this._length = length;
		}

		// Token: 0x0600031E RID: 798 RVA: 0x000139B0 File Offset: 0x00011BB0
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal WinZipAesCipherStream(Stream p0, WinZipAesCrypto cryptoParams, CryptoMode mode)
		{
			this._params = cryptoParams;
			this._s = p0;
			this._mode = mode;
			this._nonce = 1;
			if (this._params == null)
			{
				throw new BadPasswordException(c0000c0.m00000f("Ât=\u0014Ê\u0010\u0013V\u008c\u0002/_{à\"\u0015ò¢\u001a\t\r±iÈsÿ2\u008d7Ý\u008dÕoN:\u0018ñâNÞ"));
			}
			int num = this._params.KeyBytes.Length * 8;
			if (num != 256 && num != 128 && num != 192)
			{
				throw new ArgumentException(c0000c0.m00000f("úd4\u0017Ï\u0013V"));
			}
			this._mac = new HMACSHA1(this._params.MacIv);
			this._aesCipher = new RijndaelManaged();
			this._aesCipher.BlockSize = 128;
			this._aesCipher.KeySize = num;
			this._aesCipher.Mode = CipherMode.ECB;
			this._aesCipher.Padding = PaddingMode.None;
			byte[] rgbIV = new byte[16];
			this._xform = this._aesCipher.CreateEncryptor(this._params.KeyBytes, rgbIV);
			if (this._mode == CryptoMode.Encrypt)
			{
				this._PendingWriteBuffer = new byte[16];
			}
		}

		// Token: 0x0600031F RID: 799 RVA: 0x00013AF8 File Offset: 0x00011CF8
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int ProcessOneBlockWriting(byte[] buffer, int offset, int last)
		{
			int num2;
			int i;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						if (num2 == last - offset)
						{
							if (this._NextXformWillBeFinal)
							{
								this.counterOut = this._xform.TransformFinalBlock(this.counter, 0, 16);
								this._finalBlock = true;
							}
							else
							{
								if (buffer != this._PendingWriteBuffer)
								{
									goto IL_36;
								}
								if (num2 != 16)
								{
									num = delegate0da.f0000d7(-2);
									continue;
								}
							}
						}
						if (!this._finalBlock)
						{
							this._xform.TransformBlock(this.counter, 0, 16, this.counterOut, 0);
						}
						i = 0;
						num = delegate0da.f0000d7(-1);
						continue;
					case 1:
						goto IL_189;
					case 2:
						goto IL_36;
					case 3:
					{
						if (this._finalBlock)
						{
							goto Block_2;
						}
						int num3 = last - offset;
						num2 = ((num3 > 16) ? 16 : num3);
						int p = this._nonce++;
						delegate0fe.f000121(delegate0136.f000173(p), 0, this.counter, 0, 4);
						num = delegate0da.f0000d7(0);
						continue;
					}
					}
					break;
				}
			}
			IL_36:
			Array.Copy(buffer, offset, this._PendingWriteBuffer, this._pendingCount, num2);
			this._pendingCount += num2;
			this._nonce--;
			return num2;
			Block_2:
			throw new InvalidOperationException(c0000c0.m00000f("Åi(DÀ\0]VÀR,@gô&Gþã\u001dFL¨hÈ2Ú\u000eþuÝ\u0086Ø=C8\röþF\u009fL\0­ñµ"));
			IL_189:
			while (i < num2)
			{
				buffer[offset + i] = (this.counterOut[i] ^ buffer[offset + i]);
				i++;
			}
			if (this._finalBlock)
			{
				this._mac.TransformFinalBlock(buffer, offset, num2);
			}
			else
			{
				this._mac.TransformBlock(buffer, offset, num2, null, 0);
			}
			return num2;
		}

		// Token: 0x06000320 RID: 800 RVA: 0x00013CE8 File Offset: 0x00011EE8
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int ProcessOneBlockReading(byte[] buffer, int offset, int count)
		{
			int num2;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
					{
						int num3;
						if (this._totalBytesXferred + (long)count == this._length && num2 == num3)
						{
							this._NextXformWillBeFinal = true;
							goto IL_10C;
						}
						goto IL_10C;
					}
					case 1:
						goto IL_15D;
					case 2:
						if (num2 == count - offset)
						{
							goto Block_1;
						}
						goto IL_74;
					case 3:
					{
						if (this._finalBlock)
						{
							goto Block_2;
						}
						int num3 = count - offset;
						num2 = ((num3 > 16) ? 16 : num3);
						if (this._length > 0L)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_10C;
					}
					}
					break;
					IL_74:
					this._mac.TransformBlock(buffer, offset, num2, null, 0);
					num = delegate0da.f0000d7(-1);
					continue;
					IL_10C:
					int p = this._nonce++;
					delegate0fe.f000121(delegate0136.f000173(p), 0, this.counter, 0, 4);
					if (!this._NextXformWillBeFinal)
					{
						goto IL_74;
					}
					num = delegate0da.f0000d7(-2);
				}
			}
			Block_1:
			this._mac.TransformFinalBlock(buffer, offset, num2);
			this.counterOut = this._xform.TransformFinalBlock(this.counter, 0, 16);
			this._finalBlock = true;
			goto IL_179;
			Block_2:
			throw new NotSupportedException();
			IL_15D:
			this._xform.TransformBlock(this.counter, 0, 16, this.counterOut, 0);
			IL_179:
			for (int i = 0; i < num2; i++)
			{
				buffer[offset + i] = (this.counterOut[i] ^ buffer[offset + i]);
			}
			return num2;
		}

		// Token: 0x06000321 RID: 801 RVA: 0x00013E98 File Offset: 0x00012098
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void TransformInPlace(byte[] buffer, int offset, int count)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					WinZipAesCipherStream.ProcessOneBlock processOneBlock;
					int num2;
					int num3;
					int num4;
					switch (num)
					{
					case 0:
						processOneBlock = ((this._mode == CryptoMode.Encrypt) ? new WinZipAesCipherStream.ProcessOneBlock(this.ProcessOneBlockWriting) : new WinZipAesCipherStream.ProcessOneBlock(this.ProcessOneBlockReading));
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						num2 += num3;
						goto IL_C0;
					case 2:
						goto IL_C0;
					case 3:
						num2 = offset;
						num4 = count + offset;
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
					IL_C0:
					if (num2 >= buffer.Length || num2 >= num4)
					{
						return;
					}
					num3 = processOneBlock(buffer, num2, num4);
					num = delegate0da.f0000d7(-1);
				}
			}
		}

		// Token: 0x06000322 RID: 802 RVA: 0x00013F78 File Offset: 0x00012178
		[MethodImpl(MethodImplOptions.NoInlining)]
		public override int Read(byte[] buffer, int offset, int count)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_A2;
					case 1:
						goto IL_C2;
					case 2:
						goto IL_54;
					case 3:
						if (this._mode == CryptoMode.Encrypt)
						{
							goto Block_3;
						}
						if (buffer == null)
						{
							goto Block_4;
						}
						goto IL_A2;
					}
					break;
					IL_A2:
					if (offset < 0 || count < 0)
					{
						goto IL_B2;
					}
					if (buffer.Length >= offset + count)
					{
						goto IL_64;
					}
					num = delegate0da.f0000d7(-2);
				}
			}
			IL_54:
			throw new ArgumentException(c0000c0.m00000f("Åi(DÄ\u001cUQÉ\0nE{·9\bù¢\u001d\vL¨v"));
			IL_64:
			int count2 = count;
			if (this._totalBytesXferred >= this._length)
			{
				return 0;
			}
			goto IL_C2;
			Block_3:
			throw new NotSupportedException();
			Block_4:
			throw new ArgumentNullException(c0000c0.m00000f("ót+\u0002Ã\u001b"));
			IL_B2:
			throw new ArgumentException(c0000c0.m00000f("Øo;\u0005Ê\0W\u0017Ü\u0013<Meò9\u0002äñ"));
			IL_C2:
			long num2 = this._length - this._totalBytesXferred;
			if (num2 < (long)count)
			{
				count2 = (int)num2;
			}
			int num3 = this._s.Read(buffer, offset, count2);
			this.TransformInPlace(buffer, offset, count2);
			this._totalBytesXferred += (long)num3;
			return num3;
		}

		// Token: 0x17000095 RID: 149
		// (get) Token: 0x06000323 RID: 803 RVA: 0x00014088 File Offset: 0x00012288
		public byte[] FinalAuthentication
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				byte[] array;
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							goto IL_95;
						case 1:
							goto IL_C4;
						case 2:
						{
							byte[] buffer;
							this._mac.ComputeHash(buffer);
							goto IL_43;
						}
						case 3:
						{
							if (this._finalBlock)
							{
								goto IL_43;
							}
							if (this._totalBytesXferred != 0L)
							{
								num = delegate0da.f0000d7(0);
								continue;
							}
							byte[] buffer = new byte[0];
							num = delegate0da.f0000d7(-2);
							continue;
						}
						}
						break;
						IL_43:
						array = new byte[10];
						num = delegate0da.f0000d7(-1);
					}
				}
				IL_95:
				throw new BadStateException(c0000c0.m00000f("Åi(DÀ\0]VÀR&M{ÿm\u000f÷ñN\bB°:Ï6Û\u0019þt×\u008eÆhC/\b¶"));
				IL_C4:
				Array.Copy(this._mac.Hash, 0, array, 0, 10);
				return array;
			}
		}

		// Token: 0x06000324 RID: 804 RVA: 0x00014170 File Offset: 0x00012370
		[MethodImpl(MethodImplOptions.NoInlining)]
		public override void Write(byte[] buffer, int offset, int count)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_D9;
					case 1:
						goto IL_148;
					case 2:
						goto IL_36;
					case 3:
						if (this._mode == CryptoMode.Decrypt)
						{
							goto Block_1;
						}
						if (buffer == null)
						{
							goto Block_2;
						}
						if (offset < 0 || count < 0)
						{
							goto IL_C9;
						}
						goto IL_D9;
					}
					break;
					IL_D9:
					if (buffer.Length < offset + count)
					{
						goto Block_4;
					}
					if (count == 0)
					{
						return;
					}
					if (this._pendingCount == 0)
					{
						goto IL_17C;
					}
					if (count + this._pendingCount <= 16)
					{
						delegate0fe.f000121(buffer, offset, this._PendingWriteBuffer, this._pendingCount, count);
						num = delegate0da.f0000d7(-2);
					}
					else
					{
						int num2 = 16 - this._pendingCount;
						delegate0fe.f000121(buffer, offset, this._PendingWriteBuffer, this._pendingCount, num2);
						this._pendingCount = 0;
						offset += num2;
						count -= num2;
						num = delegate0da.f0000d7(-1);
					}
				}
			}
			IL_36:
			this._pendingCount += count;
			return;
			Block_1:
			throw new NotSupportedException();
			Block_2:
			throw new ArgumentNullException(c0000c0.m00000f("ót+\u0002Ã\u001b"));
			IL_C9:
			throw new ArgumentException(c0000c0.m00000f("Øo;\u0005Ê\0W\u0017Ü\u0013<Meò9\u0002äñ"));
			Block_4:
			throw new ArgumentException(c0000c0.m00000f("Åi(DÉ\u000fUDÉ\u0006nMfóm\u0004ù÷\0\u0012\r¥hÈsÊ\u0018±7Ô\u0082ÄzR"));
			IL_148:
			this.ProcessOneBlockWriting(this._PendingWriteBuffer, 0, 16);
			this._s.Write(this._PendingWriteBuffer, 0, 16);
			this._totalBytesXferred += 16L;
			IL_17C:
			this.TransformInPlace(buffer, offset, count);
			this._s.Write(buffer, offset, count - this._pendingCount);
			this._totalBytesXferred += (long)(count - this._pendingCount);
		}

		// Token: 0x06000325 RID: 805 RVA: 0x00014330 File Offset: 0x00012530
		[MethodImpl(MethodImplOptions.NoInlining)]
		public override void Close()
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						this._NextXformWillBeFinal = true;
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_A4;
					case 2:
						this.ProcessOneBlockWriting(this._PendingWriteBuffer, 0, this._pendingCount);
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
						if (this._pendingCount != 0)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_D0;
					}
					break;
				}
			}
			IL_A4:
			this._s.Write(this._PendingWriteBuffer, 0, this._pendingCount);
			this._totalBytesXferred += (long)this._pendingCount;
			IL_D0:
			this._s.Close();
		}

		// Token: 0x17000096 RID: 150
		// (get) Token: 0x06000326 RID: 806 RVA: 0x00014418 File Offset: 0x00012618
		public override bool CanRead
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._mode == CryptoMode.Decrypt;
			}
		}

		// Token: 0x17000097 RID: 151
		// (get) Token: 0x06000327 RID: 807 RVA: 0x00014438 File Offset: 0x00012638
		public override bool CanSeek
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return false;
			}
		}

		// Token: 0x17000098 RID: 152
		// (get) Token: 0x06000328 RID: 808 RVA: 0x00014448 File Offset: 0x00012648
		public override bool CanWrite
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._mode == CryptoMode.Encrypt;
			}
		}

		// Token: 0x06000329 RID: 809 RVA: 0x00014460 File Offset: 0x00012660
		[MethodImpl(MethodImplOptions.NoInlining)]
		public override void Flush()
		{
			this._s.Flush();
		}

		// Token: 0x17000099 RID: 153
		// (get) Token: 0x0600032A RID: 810 RVA: 0x00014478 File Offset: 0x00012678
		public override long Length
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				throw new NotImplementedException();
			}
		}

		// Token: 0x1700009A RID: 154
		// (get) Token: 0x0600032B RID: 811 RVA: 0x0001448C File Offset: 0x0001268C
		// (set) Token: 0x0600032C RID: 812 RVA: 0x000144A0 File Offset: 0x000126A0
		public override long Position
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				throw new NotImplementedException();
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				throw new NotImplementedException();
			}
		}

		// Token: 0x0600032D RID: 813 RVA: 0x000144B4 File Offset: 0x000126B4
		[MethodImpl(MethodImplOptions.NoInlining)]
		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotImplementedException();
		}

		// Token: 0x0600032E RID: 814 RVA: 0x000144C8 File Offset: 0x000126C8
		[MethodImpl(MethodImplOptions.NoInlining)]
		public override void SetLength(long value)
		{
			throw new NotImplementedException();
		}

		// Token: 0x0600032F RID: 815 RVA: 0x000144DC File Offset: 0x000126DC
		[Conditional("Trace")]
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void TraceOutput(string format, params object[] varParams)
		{
			delegate0e6.f0000f4(this._outputLock);
			int num = delegate0fc.f000118(delegate010f.f00013e());
			delegate0146.f000188(num % 8 + ConsoleColor.DarkGray);
			delegate0147.f000189(c0000c0.m00000f("ê1wT\u0096YN\u0017û(\u000fo[·"), num);
			delegate0138.f000175(format, varParams);
			delegate0148.f00018b();
		}

		// Token: 0x06000330 RID: 816 RVA: 0x00014554 File Offset: 0x00012754
		// Note: this type is marked as 'beforefieldinit'.
		[MethodImpl(MethodImplOptions.NoInlining)]
		static WinZipAesCipherStream()
		{
			c0000c0.Initialize();
			c0000c0.PostInitialize();
		}

		// Token: 0x04000138 RID: 312
		private const int BLOCK_SIZE_IN_BYTES = 16;

		// Token: 0x04000139 RID: 313
		private WinZipAesCrypto _params;

		// Token: 0x0400013A RID: 314
		private Stream _s;

		// Token: 0x0400013B RID: 315
		private CryptoMode _mode;

		// Token: 0x0400013C RID: 316
		private int _nonce;

		// Token: 0x0400013D RID: 317
		private bool _finalBlock;

		// Token: 0x0400013E RID: 318
		private bool _NextXformWillBeFinal;

		// Token: 0x0400013F RID: 319
		internal HMACSHA1 _mac;

		// Token: 0x04000140 RID: 320
		internal RijndaelManaged _aesCipher;

		// Token: 0x04000141 RID: 321
		internal ICryptoTransform _xform;

		// Token: 0x04000142 RID: 322
		private byte[] counter = new byte[16];

		// Token: 0x04000143 RID: 323
		private byte[] counterOut = new byte[16];

		// Token: 0x04000144 RID: 324
		private long _length;

		// Token: 0x04000145 RID: 325
		private long _totalBytesXferred;

		// Token: 0x04000146 RID: 326
		private byte[] _PendingWriteBuffer;

		// Token: 0x04000147 RID: 327
		private int _pendingCount;

		// Token: 0x04000148 RID: 328
		private object _outputLock = new object();

		// Token: 0x0200006A RID: 106
		private sealed class ProcessOneBlock : MulticastDelegate
		{
			// Token: 0x06000331 RID: 817
			[MethodImpl(MethodImplOptions.NoInlining)]
			public extern ProcessOneBlock(object @object, IntPtr method);

			// Token: 0x06000332 RID: 818
			[MethodImpl(MethodImplOptions.NoInlining)]
			public extern int Invoke(byte[] p0, int p1, int p2);

			// Token: 0x06000333 RID: 819
			[MethodImpl(MethodImplOptions.NoInlining)]
			public extern IAsyncResult BeginInvoke(byte[] p0, int p1, int p2, AsyncCallback callback, object @object);

			// Token: 0x06000334 RID: 820
			[MethodImpl(MethodImplOptions.NoInlining)]
			public extern int EndInvoke(IAsyncResult result);

			// Token: 0x06000335 RID: 821 RVA: 0x00014560 File Offset: 0x00012760
			[MethodImpl(MethodImplOptions.NoInlining)]
			static ProcessOneBlock()
			{
				c0000c0.Initialize();
				c0000c0.PostInitialize();
			}
		}
	}
}
