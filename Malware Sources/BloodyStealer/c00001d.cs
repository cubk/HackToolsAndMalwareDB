using System;
using System.Runtime.CompilerServices;

namespace Application.Grabber.Browsers
{
	// Token: 0x0200001D RID: 29
	public class c00001d : IGcmMultiplier
	{
		// Token: 0x060000CB RID: 203 RVA: 0x00006724 File Offset: 0x00004924
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void Init(byte[] H)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					int num2;
					int num4;
					switch (num)
					{
					case 0:
						goto IL_143;
					case 1:
					{
						IL_3B:
						int num3;
						if (num2 < 16)
						{
							for (int i = 1; i < num2; i++)
							{
								uint[] array = (uint[])this.M[num3][num2].Clone();
								GcmUtilities.Xor(array, this.M[num3][i]);
								this.M[num3][num2 + i] = array;
							}
							num2 += num2;
							num = delegate0da.f0000d7(-1);
							continue;
						}
						if (++num3 == 32)
						{
							return;
						}
						if (num3 > 1)
						{
							this.M[num3] = new uint[16][];
							this.M[num3][0] = new uint[4];
							for (int j = 8; j > 0; j >>= 1)
							{
								uint[] array2 = (uint[])this.M[num3 - 2][j].Clone();
								GcmUtilities.MultiplyP8(array2);
								this.M[num3][j] = array2;
							}
							goto IL_38;
						}
						goto IL_38;
					}
					case 2:
					{
						int num3 = 0;
						goto IL_38;
					}
					case 3:
						this.M[0] = new uint[16][];
						this.M[1] = new uint[16][];
						this.M[0][0] = new uint[4];
						this.M[1][0] = new uint[4];
						this.M[1][8] = GcmUtilities.AsUints(H);
						num4 = 4;
						goto IL_143;
					}
					break;
					IL_143:
					if (num4 < 1)
					{
						uint[] array3 = (uint[])this.M[1][1].Clone();
						GcmUtilities.MultiplyP(array3);
						this.M[0][8] = array3;
						for (int k = 4; k >= 1; k >>= 1)
						{
							uint[] array4 = (uint[])this.M[0][k + k].Clone();
							GcmUtilities.MultiplyP(array4);
							this.M[0][k] = array4;
						}
						num = delegate0da.f0000d7(-2);
						continue;
					}
					uint[] array5 = (uint[])this.M[1][num4 + num4].Clone();
					GcmUtilities.MultiplyP(array5);
					this.M[1][num4] = array5;
					num4 >>= 1;
					num = delegate0da.f0000d7(0);
					continue;
					IL_38:
					num2 = 2;
					goto IL_3B;
				}
			}
		}

		// Token: 0x060000CC RID: 204 RVA: 0x00006984 File Offset: 0x00004B84
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void MultiplyH(byte[] p0)
		{
			uint[] array;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					int num2;
					switch (num)
					{
					case 0:
					{
						uint[] array2;
						array[1] ^= array2[1];
						array[2] ^= array2[2];
						array[3] ^= array2[3];
						array2 = this.M[num2 + num2 + 1][(p0[num2] & 240) >> 4];
						array[0] ^= array2[0];
						num = delegate0da.f0000d7(-2);
						continue;
					}
					case 1:
						goto IL_133;
					case 2:
					{
						uint[] array2;
						array[1] ^= array2[1];
						array[2] ^= array2[2];
						array[3] ^= array2[3];
						num2--;
						goto IL_64;
					}
					case 3:
						array = new uint[4];
						num2 = 15;
						goto IL_64;
					}
					break;
					IL_64:
					if (num2 < 0)
					{
						num = delegate0da.f0000d7(-1);
					}
					else
					{
						uint[] array2 = this.M[num2 + num2][(int)(p0[num2] & 15)];
						array[0] ^= array2[0];
						num = delegate0da.f0000d7(0);
					}
				}
			}
			IL_133:
			Pack.UInt32_To_BE(array[0], p0, 0);
			Pack.UInt32_To_BE(array[1], p0, 4);
			Pack.UInt32_To_BE(array[2], p0, 8);
			Pack.UInt32_To_BE(array[3], p0, 12);
		}

		// Token: 0x060000CD RID: 205 RVA: 0x00006AF0 File Offset: 0x00004CF0
		[MethodImpl(MethodImplOptions.NoInlining)]
		public c00001d()
		{
		}

		// Token: 0x060000CE RID: 206 RVA: 0x00006B08 File Offset: 0x00004D08
		// Note: this type is marked as 'beforefieldinit'.
		[MethodImpl(MethodImplOptions.NoInlining)]
		static c00001d()
		{
			c0000c0.Initialize();
			c0000c0.PostInitialize();
		}

		// Token: 0x0400004F RID: 79
		private readonly uint[][][] M = new uint[32][][];
	}
}
