using System;
using System.IO;
using System.Runtime.CompilerServices;
using Ionic.Zlib;

namespace Ionic.Zip
{
	// Token: 0x02000074 RID: 116
	internal class ZipCrypto
	{
		// Token: 0x0600037C RID: 892 RVA: 0x00015494 File Offset: 0x00013694
		[MethodImpl(MethodImplOptions.NoInlining)]
		private ZipCrypto()
		{
		}

		// Token: 0x0600037D RID: 893 RVA: 0x000154C0 File Offset: 0x000136C0
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static ZipCrypto ForWrite(string password)
		{
			ZipCrypto zipCrypto;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						if (password == null)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_82;
					case 1:
						goto IL_82;
					case 2:
						goto IL_36;
					case 3:
						zipCrypto = new ZipCrypto();
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_36:
			throw new BadPasswordException(c0000c0.m00000f("Åi$\u0017\u0086\f]CÞ\vn^mæ8\u000eäç\u001dFLäjÌ Í\0±eÜÍ"));
			IL_82:
			zipCrypto.InitCipher(password);
			return zipCrypto;
		}

		// Token: 0x0600037E RID: 894 RVA: 0x00015558 File Offset: 0x00013758
		[MethodImpl(MethodImplOptions.NoInlining)]
		public static ZipCrypto ForRead(string password, ZipEntry p1)
		{
			ZipCrypto zipCrypto;
			byte[] array;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					Stream archiveStream;
					byte[] weakEncryptionHeader;
					switch (num)
					{
					case 0:
						zipCrypto = new ZipCrypto();
						if (password == null)
						{
							goto Block_1;
						}
						goto IL_36;
					case 1:
						goto IL_B7;
					case 2:
						goto IL_36;
					case 3:
						archiveStream = p1._archiveStream;
						p1._WeakEncryptionHeader = new byte[12];
						weakEncryptionHeader = p1._WeakEncryptionHeader;
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
					IL_36:
					zipCrypto.InitCipher(password);
					ZipEntry.ReadWeakEncryptionHeader(archiveStream, weakEncryptionHeader);
					array = zipCrypto.DecryptMessage(weakEncryptionHeader, weakEncryptionHeader.Length);
					num = delegate0da.f0000d7(-1);
				}
			}
			Block_1:
			throw new BadPasswordException(c0000c0.m00000f("Åi$\u0017\u0086\f]CÞ\vn^mæ8\u000eäç\u001dFLäjÌ Í\0±eÜÍ"));
			IL_B7:
			if (array[11] != (byte)(p1.f00004b >> 24 & 255))
			{
				if ((p1._BitField & 8) != 8)
				{
					throw new BadPasswordException(c0000c0.m00000f("Åi(DÖ\b@DÛ\u001d<H(ó$\u0003¶ì\u0001\u0012\r©{Ù0ÖY"));
				}
				if (array[11] != (byte)(p1._TimeBlob >> 8 & 255))
				{
					throw new BadPasswordException(c0000c0.m00000f("Åi(DÖ\b@DÛ\u001d<H(ó$\u0003¶ì\u0001\u0012\r©{Ù0ÖY"));
				}
			}
			return zipCrypto;
		}

		// Token: 0x170000A4 RID: 164
		// (get) Token: 0x0600037F RID: 895 RVA: 0x00015684 File Offset: 0x00013884
		private byte MagicByte
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				ushort num = (ushort)(this._Keys[2] & 65535U) | 2;
				return (byte)(num * (num ^ 1) >> 8);
			}
		}

		// Token: 0x06000380 RID: 896 RVA: 0x000156AC File Offset: 0x000138AC
		[MethodImpl(MethodImplOptions.NoInlining)]
		public byte[] DecryptMessage(byte[] cipherText, int length)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					int num2;
					byte b;
					switch (num)
					{
					case 0:
						goto IL_A7;
					case 1:
					{
						byte[] array;
						array[num2] = b;
						num2++;
						goto IL_EA;
					}
					case 2:
						goto IL_EA;
					case 3:
					{
						if (cipherText == null)
						{
							goto Block_1;
						}
						if (length > cipherText.Length)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						byte[] array = new byte[length];
						num2 = 0;
						num = delegate0da.f0000d7(-2);
						continue;
					}
					}
					break;
					IL_EA:
					if (num2 >= length)
					{
						byte[] array;
						return array;
					}
					b = (cipherText[num2] ^ this.MagicByte);
					this.UpdateKeys(b);
					num = delegate0da.f0000d7(-1);
				}
			}
			Block_1:
			throw new ArgumentException(c0000c0.m00000f("Ó`)DÊ\f]PØ\u001anH}å$\tñ¢*\u0003N¶cÝ'×\u0018°-\u0098\u0080ßm_/\u001eÌèX\u0084\u001e\0½æï\u0019ÀPÔ\u0096v¹í[c\u00a0\u0089°"), c0000c0.m00000f("òh=\fÃ\u001bgRÔ\u0006"));
			IL_A7:
			throw new ArgumentException(c0000c0.m00000f("Ó`)DÊ\f]PØ\u001anH}å$\tñ¢*\u0003N¶cÝ'×\u0018°-\u0098\u0097Þx\u0017&\töêT\u0098\u001e\u001d©çúTÇA\u0091\u008a9ºµFbì\u0087û0\u0094\u009d2L\u009eëä.¤$\u0081£(\r\u000e\bÚ\u008aöpv;5\u0086=ëd\u0091ÇR\u0014ÿ\u009d]XfÉ8¼b%Nµ\u009b`Bÿ`9\rÉ\a\u0013VÞ\0/U&"), c0000c0.m00000f("ýd#\u0003Ò\u0001"));
		}

		// Token: 0x06000381 RID: 897 RVA: 0x000157B0 File Offset: 0x000139B0
		[MethodImpl(MethodImplOptions.NoInlining)]
		public byte[] EncryptMessage(byte[] plaintext, int length)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					byte byteValue;
					int num2;
					byte[] array;
					switch (num)
					{
					case 0:
						goto IL_A6;
					case 1:
						this.UpdateKeys(byteValue);
						num2++;
						goto IL_EC;
					case 2:
						goto IL_EC;
					case 3:
						if (plaintext == null)
						{
							goto Block_1;
						}
						if (length > plaintext.Length)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						array = new byte[length];
						num2 = 0;
						num = delegate0da.f0000d7(-2);
						continue;
					}
					break;
					IL_EC:
					if (num2 >= length)
					{
						return array;
					}
					byteValue = plaintext[num2];
					array[num2] = (plaintext[num2] ^ this.MagicByte);
					num = delegate0da.f0000d7(-1);
				}
			}
			Block_1:
			throw new ArgumentException(c0000c0.m00000f("Ó`)DÊ\f]PØ\u001anH}å$\tñ¢+\bN¶cÝ'×\u0018°-\u0098\u0097Þx\u0017:\0ùäN¤[\u0015¼µöLÑAÔ\u009a|÷®Zxá\u008bë|\u008bÞ"), c0000c0.m00000f("ám,\rÈ\u001dVOØ"));
			IL_A6:
			throw new ArgumentException(c0000c0.m00000f("Ó`)DÊ\f]PØ\u001anH}å$\tñ¢+\bN¶cÝ'×\u0018°-\u0098·Þx\u0017&\töêT\u0098\u001e\u001d©çúTÇA\u0091\u008a9ºµFbì\u0087û0\u0094\u009d2L\u009eëä.¤$\u0081£(\r\u000e\bÚ\u008aöpv;5\u0086=ëd\u0091ÇR\u0014ÿ\u009d]XfÉ8¼b%Nµ\u009b`Bÿ`9\rÉ\a\u0013VÞ\0/U&"), c0000c0.m00000f("ýd#\u0003Ò\u0001"));
		}

		// Token: 0x06000382 RID: 898 RVA: 0x000158B4 File Offset: 0x00013AB4
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void InitCipher(string p0)
		{
			int num2;
			byte[] array;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						num2 = 0;
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_74;
					case 2:
						goto IL_36;
					case 3:
						array = SharedUtilities.StringToByteArray(p0);
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_36:
			goto IL_81;
			IL_74:
			this.UpdateKeys(array[num2]);
			num2++;
			IL_81:
			if (num2 >= p0.Length)
			{
				return;
			}
			goto IL_74;
		}

		// Token: 0x06000383 RID: 899 RVA: 0x00015950 File Offset: 0x00013B50
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void UpdateKeys(byte byteValue)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						this._Keys[1] = this._Keys[1] + (uint)((byte)this._Keys[0]);
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_CC;
					case 2:
						this._Keys[1] = this._Keys[1] * 134775813U + 1U;
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
						this._Keys[0] = (uint)this.f00004a.ComputeCrc32((int)this._Keys[0], byteValue);
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_CC:
			this._Keys[2] = (uint)this.f00004a.ComputeCrc32((int)this._Keys[2], (byte)(this._Keys[1] >> 24));
		}

		// Token: 0x06000384 RID: 900 RVA: 0x00015A50 File Offset: 0x00013C50
		// Note: this type is marked as 'beforefieldinit'.
		[MethodImpl(MethodImplOptions.NoInlining)]
		static ZipCrypto()
		{
			c0000c0.Initialize();
			c0000c0.PostInitialize();
		}

		// Token: 0x0400015C RID: 348
		private uint[] _Keys = new uint[]
		{
			305419896U,
			591751049U,
			878082192U
		};

		// Token: 0x0400015D RID: 349
		private CRC32 f00004a = new CRC32();
	}
}
