using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using Ionic.Zlib;

namespace Ionic.Zip
{
	// Token: 0x02000082 RID: 130
	[ComVisible(true)]
	[ClassInterface(ClassInterfaceType.AutoDispatch)]
	[Guid("ebc25cf6-9120-4283-b972-0e5520d00004")]
	public class ZipEntry
	{
		// Token: 0x170000B6 RID: 182
		// (get) Token: 0x060003DE RID: 990 RVA: 0x000165E8 File Offset: 0x000147E8
		internal bool AttributesIndicateDirectory
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._InternalFileAttrs == 0 && (this._ExternalFileAttrs & 16) == 16;
			}
		}

		// Token: 0x060003DF RID: 991 RVA: 0x00016610 File Offset: 0x00014810
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void ResetDirEntry()
		{
			this.__FileDataPosition = -1L;
			this._LengthOfHeader = 0;
		}

		// Token: 0x170000B7 RID: 183
		// (get) Token: 0x060003E0 RID: 992 RVA: 0x0001662C File Offset: 0x0001482C
		public string Info
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				StringBuilder stringBuilder;
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							stringBuilder.Append(delegate0101.f000127(c0000c0.m00000f("Ëh=!È\u001dAN\u0096R5\u001cu\u009d"), this.FileName)).Append(delegate0101.f000127(c0000c0.m00000f("±!\u001b\u0001Ô\u001aZXÂR\u0003Mlòm%ï¸NVU¿*\u0097\vÃ}"), this._VersionMadeBy)).Append(delegate0101.f000127(c0000c0.m00000f("±!\u001b\u0001Ô\u001aZXÂR\0Imó(\u0003¬¢^\u001eVô õ.´"), this.VersionNeeded)).Append(delegate0101.f000127(c0000c0.m00000f("±!\u000e\vË\u0019ARß\u0001'Cf·\0\u0002âê\u0001\u0002\u0017äa\u009d.´"), this.CompressionMethod)).Append(delegate0101.f000127(c0000c0.m00000f("±!\u000e\vË\u0019ARß\u0001+H2·}\u001fí²T>PÎ"), this.CompressedSize)).Append(delegate0101.f000127(c0000c0.m00000f("±!\u0018\nÅ\u0006^GÞ\u0017=_mówG¦ú\u0015V\u0017\u009cg§"), this.UncompressedSize)).Append(delegate0101.f000127(c0000c0.m00000f("±!\t\rÕ\u0002\u0013yÙ\u001f,Iz­m\u001c¦ÿd"), this._diskNumber)).Append(delegate0101.f000127(c0000c0.m00000f("±!\u001f\u0001Ê\bG^Ú\u0017ncnñ>\u0002â¸NVU¿*\u0097\vÃ}"), this._RelativeOffsetOfLocalHeader)).Append(delegate0101.f000127(c0000c0.m00000f("±!\u000f\rÒIu^É\u001e*\u0016(§5\u001c¦¸6RPÎ"), this._BitField)).Append(delegate0101.f000127(c0000c0.m00000f("±!\b\nÅ\u001bJGØ\u0017*\u00132·6Wë\u0088"), this._sourceIsEncrypted)).Append(delegate0d5.f0000c9(c0000c0.m00000f("±!\u0019\rË\fQ[Ã\u0010t\f8ï6W¬ÚV\u001b\rìa\u009c.\u0097}"), this._TimeBlob, SharedUtilities.PackedToDateTime(this._TimeBlob))).Append(delegate0101.f000127(c0000c0.m00000f("±!\u000e6åS\u0013\aÔ\t~\u0016P¯0m"), this.f00004b)).Append(delegate0101.f000127(c0000c0.m00000f("±!\u0004\u0017\u0086=VOØMt\fs§0m"), this._IsText)).Append(delegate0101.f000127(c0000c0.m00000f("±!\u0004\u0017\u0086-ZEÉ\u0011:Czîr]¶ù^\u001b'"), this._IsDirectory)).Append(delegate0101.f000127(c0000c0.m00000f("±!\u0004\u0017\u00863ZG\u009aFq\u0016(ì}\u001a\u009c"), this._InputUsesZip64));
							num = delegate0da.f0000d7(-2);
							continue;
						case 1:
							goto IL_2BD;
						case 2:
							if (!string.IsNullOrEmpty(this._Comment))
							{
								num = delegate0da.f0000d7(-1);
								continue;
							}
							goto IL_2DE;
						case 3:
							stringBuilder = new StringBuilder();
							num = delegate0da.f0000d7(0);
							continue;
						}
						break;
					}
				}
				IL_2BD:
				stringBuilder.Append(delegate0101.f000127(c0000c0.m00000f("±!\u000e\vË\u0004VYØHnW8êG"), this._Comment));
				IL_2DE:
				return stringBuilder.ToString();
			}
		}

		// Token: 0x060003E1 RID: 993 RVA: 0x00016920 File Offset: 0x00014B20
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static ZipEntry ReadDirEntry(ZipFile p0)
		{
			ZipEntry zipEntry;
			Stream readStream;
			int num5;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
					{
						byte[] array;
						int num2;
						zipEntry._VersionMadeBy = (short)((int)array[num2++] + (int)array[num2++] * 256);
						zipEntry._VersionNeeded = (short)((int)array[num2++] + (int)array[num2++] * 256);
						zipEntry._BitField = (short)((int)array[num2++] + (int)array[num2++] * 256);
						zipEntry._CompressionMethod = (short)((int)array[num2++] + (int)array[num2++] * 256);
						zipEntry._TimeBlob = (int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256;
						zipEntry._LastModified = SharedUtilities.PackedToDateTime(zipEntry._TimeBlob);
						zipEntry._timestamp |= ZipEntryTimestamp.DOS;
						zipEntry.f00004b = (int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256;
						zipEntry._CompressedSize = (long)((ulong)((int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256));
						zipEntry._UncompressedSize = (long)((ulong)((int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256));
						zipEntry._CompressionMethod_FromZipFile = zipEntry._CompressionMethod;
						zipEntry._filenameLength = (short)((int)array[num2++] + (int)array[num2++] * 256);
						zipEntry._extraFieldLength = (short)((int)array[num2++] + (int)array[num2++] * 256);
						zipEntry._commentLength = (short)((int)array[num2++] + (int)array[num2++] * 256);
						zipEntry._diskNumber = (uint)array[num2++] + (uint)array[num2++] * 256U;
						zipEntry._InternalFileAttrs = (short)((int)array[num2++] + (int)array[num2++] * 256);
						zipEntry._ExternalFileAttrs = (int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256;
						zipEntry._RelativeOffsetOfLocalHeader = (long)((ulong)((int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256));
						zipEntry.IsText = ((zipEntry._InternalFileAttrs & 1) == 1);
						array = new byte[(int)zipEntry._filenameLength];
						num = delegate0da.f0000d7(-2);
						continue;
					}
					case 1:
						goto IL_625;
					case 2:
					{
						byte[] array;
						int num3 = readStream.Read(array, 0, array.Length);
						int num4;
						num4 += num3;
						if ((zipEntry._BitField & 2048) == 2048)
						{
							zipEntry._FileNameInArchive = SharedUtilities.Utf8StringFromBuffer(array);
						}
						else
						{
							Encoding provisionalAlternateEncoding;
							zipEntry._FileNameInArchive = SharedUtilities.StringFromBuffer(array, provisionalAlternateEncoding);
						}
						if (zipEntry.AttributesIndicateDirectory)
						{
							zipEntry.MarkAsDirectory();
						}
						else if (zipEntry._FileNameInArchive.EndsWith(c0000c0.m00000f("¾")))
						{
							zipEntry.MarkAsDirectory();
						}
						zipEntry._CompressedFileDataSize = zipEntry._CompressedSize;
						if ((zipEntry._BitField & 1) == 1)
						{
							zipEntry._Encryption_FromZipFile = (zipEntry._Encryption = EncryptionAlgorithm.PkzipWeak);
							zipEntry._sourceIsEncrypted = true;
						}
						if (zipEntry._extraFieldLength > 0)
						{
							zipEntry._InputUsesZip64 = (zipEntry._CompressedSize == (long)((ulong)-1) || zipEntry._UncompressedSize == (long)((ulong)-1) || zipEntry._RelativeOffsetOfLocalHeader == (long)((ulong)-1));
							num4 += zipEntry.ProcessExtraField(readStream, zipEntry._extraFieldLength);
							zipEntry._CompressedFileDataSize = zipEntry._CompressedSize;
						}
						if (zipEntry._Encryption == EncryptionAlgorithm.PkzipWeak)
						{
							num = delegate0da.f0000d7(-1);
							continue;
						}
						goto IL_63B;
					}
					case 3:
					{
						readStream = p0.ReadStream;
						Encoding provisionalAlternateEncoding = p0.ProvisionalAlternateEncoding;
						num5 = SharedUtilities.ReadSignature(readStream);
						if (ZipEntry.IsNotValidZipDirEntrySig(num5))
						{
							goto Block_9;
						}
						int num4 = 46;
						byte[] array = new byte[42];
						int num3 = delegate0144.f000185(readStream, array, 0, array.Length);
						if (num3 != array.Length)
						{
							goto Block_13;
						}
						int num2 = 0;
						zipEntry = new ZipEntry();
						zipEntry.ProvisionalAlternateEncoding = provisionalAlternateEncoding;
						zipEntry._Source = ZipEntrySource.ZipFile;
						zipEntry._container = new ZipContainer(p0);
						num = delegate0da.f0000d7(0);
						continue;
					}
					}
					break;
				}
			}
			Block_9:
			delegate0149.f00018c(readStream, -4L, SeekOrigin.Current);
			if ((long)num5 != 101010256L && (long)num5 != 101075792L && num5 != 67324752)
			{
				throw new BadReadException(delegate0d5.f0000c9(c0000c0.m00000f("±!\u0017\rÖ,]CÞ\vt\u0016Zò,\u0003Òë\u001c#C°hÔ{\u0097MþUÙ\u0087\u0096n^-\u0002ùùU\u0082[Mà¥ãB\u0092\u000f¬ÀdþàTbì\u0095ñc\u008e\u0084:O\u009c®¦v«}Ú\u00950\u001f"), num5, delegate0e3.f0000e5(readStream)));
			}
			return null;
			Block_13:
			return null;
			IL_625:
			zipEntry._CompressedFileDataSize -= 12L;
			goto IL_67F;
			IL_63B:
			if (zipEntry.Encryption == EncryptionAlgorithm.WinZipAes128 || zipEntry.Encryption == EncryptionAlgorithm.WinZipAes256)
			{
				zipEntry._CompressedFileDataSize = zipEntry.CompressedSize - (long)(ZipEntry.GetLengthOfCryptoHeaderBytes(zipEntry.Encryption) + 10);
				zipEntry._LengthOfTrailer = 10;
			}
			IL_67F:
			if ((zipEntry._BitField & 8) == 8)
			{
				if (zipEntry._InputUsesZip64)
				{
					zipEntry._LengthOfTrailer += 24;
				}
				else
				{
					zipEntry._LengthOfTrailer += 16;
				}
			}
			if (zipEntry._commentLength > 0)
			{
				byte[] array = new byte[(int)zipEntry._commentLength];
				int num3 = delegate0144.f000185(readStream, array, 0, array.Length);
				int num4;
				num4 += num3;
				if ((zipEntry._BitField & 2048) == 2048)
				{
					zipEntry._Comment = SharedUtilities.Utf8StringFromBuffer(array);
				}
				else
				{
					Encoding provisionalAlternateEncoding;
					zipEntry._Comment = SharedUtilities.StringFromBuffer(array, provisionalAlternateEncoding);
				}
			}
			return zipEntry;
		}

		// Token: 0x060003E2 RID: 994 RVA: 0x0001705C File Offset: 0x0001525C
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static bool IsNotValidZipDirEntrySig(int signature)
		{
			return signature != 33639248;
		}

		// Token: 0x060003E3 RID: 995 RVA: 0x00017074 File Offset: 0x00015274
		[MethodImpl(MethodImplOptions.NoInlining)]
		public ZipEntry()
		{
			this._CompressionMethod = 8;
			this._CompressionLevel = CompressionLevel.f000073;
			this._Encryption = EncryptionAlgorithm.None;
			this._Source = ZipEntrySource.None;
		}

		// Token: 0x170000B8 RID: 184
		// (get) Token: 0x060003E4 RID: 996 RVA: 0x000170E0 File Offset: 0x000152E0
		// (set) Token: 0x060003E5 RID: 997 RVA: 0x000170F8 File Offset: 0x000152F8
		public DateTime LastModified
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._LastModified.ToLocalTime();
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this._LastModified = ((value.Kind == DateTimeKind.Unspecified) ? DateTime.SpecifyKind(value, DateTimeKind.Local) : value.ToLocalTime());
				this._Mtime = SharedUtilities.AdjustTime_Reverse(this._LastModified).ToUniversalTime();
				this._metadataChanged = true;
			}
		}

		// Token: 0x170000B9 RID: 185
		// (get) Token: 0x060003E6 RID: 998 RVA: 0x0001714C File Offset: 0x0001534C
		private int BufferSize
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._container.BufferSize;
			}
		}

		// Token: 0x170000BA RID: 186
		// (get) Token: 0x060003E7 RID: 999 RVA: 0x00017164 File Offset: 0x00015364
		// (set) Token: 0x060003E8 RID: 1000 RVA: 0x00017178 File Offset: 0x00015378
		public DateTime ModifiedTime
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._Mtime;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this.SetEntryTimes(this._Ctime, this._Atime, value);
			}
		}

		// Token: 0x170000BB RID: 187
		// (get) Token: 0x060003E9 RID: 1001 RVA: 0x00017198 File Offset: 0x00015398
		// (set) Token: 0x060003EA RID: 1002 RVA: 0x000171AC File Offset: 0x000153AC
		public DateTime AccessedTime
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._Atime;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this.SetEntryTimes(this._Ctime, value, this._Mtime);
			}
		}

		// Token: 0x170000BC RID: 188
		// (get) Token: 0x060003EB RID: 1003 RVA: 0x000171CC File Offset: 0x000153CC
		// (set) Token: 0x060003EC RID: 1004 RVA: 0x000171E0 File Offset: 0x000153E0
		public DateTime CreationTime
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._Ctime;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this.SetEntryTimes(value, this._Atime, this._Mtime);
			}
		}

		// Token: 0x060003ED RID: 1005 RVA: 0x00017200 File Offset: 0x00015400
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void SetEntryTimes(DateTime created, DateTime accessed, DateTime modified)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_D6;
					case 1:
						goto IL_12B;
					case 2:
						if (modified.Kind == ZipEntry._zeroHour.Kind)
						{
							modified = ZipEntry._win32Epoch;
							goto IL_53;
						}
						goto IL_53;
					case 3:
						this._ntfsTimesAreSet = true;
						if (delegate0139.f000177(created, ZipEntry._zeroHour) && created.Kind == ZipEntry._zeroHour.Kind)
						{
							created = ZipEntry._win32Epoch;
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_D6;
					}
					break;
					IL_53:
					this._Ctime = created.ToUniversalTime();
					this._Atime = accessed.ToUniversalTime();
					num = delegate0da.f0000d7(-1);
					continue;
					IL_D6:
					if (accessed == ZipEntry._zeroHour && accessed.Kind == ZipEntry._zeroHour.Kind)
					{
						accessed = ZipEntry._win32Epoch;
					}
					if (!(modified == ZipEntry._zeroHour))
					{
						goto IL_53;
					}
					num = delegate0da.f0000d7(-2);
				}
			}
			IL_12B:
			this._Mtime = modified.ToUniversalTime();
			this._LastModified = this._Mtime;
			if (!this._emitUnixTimes && !this._emitNtfsTimes)
			{
				this._emitNtfsTimes = true;
			}
			this._metadataChanged = true;
		}

		// Token: 0x170000BD RID: 189
		// (get) Token: 0x060003EE RID: 1006 RVA: 0x00017378 File Offset: 0x00015578
		// (set) Token: 0x060003EF RID: 1007 RVA: 0x0001738C File Offset: 0x0001558C
		public bool EmitTimesInWindowsFormatWhenSaving
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._emitNtfsTimes;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this._emitNtfsTimes = value;
				this._metadataChanged = true;
			}
		}

		// Token: 0x170000BE RID: 190
		// (get) Token: 0x060003F0 RID: 1008 RVA: 0x000173A8 File Offset: 0x000155A8
		// (set) Token: 0x060003F1 RID: 1009 RVA: 0x000173BC File Offset: 0x000155BC
		public bool EmitTimesInUnixFormatWhenSaving
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._emitUnixTimes;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this._emitUnixTimes = value;
				this._metadataChanged = true;
			}
		}

		// Token: 0x170000BF RID: 191
		// (get) Token: 0x060003F2 RID: 1010 RVA: 0x000173D8 File Offset: 0x000155D8
		public ZipEntryTimestamp Timestamp
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._timestamp;
			}
		}

		// Token: 0x170000C0 RID: 192
		// (get) Token: 0x060003F3 RID: 1011 RVA: 0x000173EC File Offset: 0x000155EC
		// (set) Token: 0x060003F4 RID: 1012 RVA: 0x00017400 File Offset: 0x00015600
		public FileAttributes Attributes
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return (FileAttributes)this._ExternalFileAttrs;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this._ExternalFileAttrs = (int)value;
				this._VersionMadeBy = 45;
				this._metadataChanged = true;
			}
		}

		// Token: 0x170000C1 RID: 193
		// (get) Token: 0x060003F5 RID: 1013 RVA: 0x00017424 File Offset: 0x00015624
		internal string LocalFileName
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._LocalFileName;
			}
		}

		// Token: 0x170000C2 RID: 194
		// (get) Token: 0x060003F6 RID: 1014 RVA: 0x00017438 File Offset: 0x00015638
		// (set) Token: 0x060003F7 RID: 1015 RVA: 0x0001744C File Offset: 0x0001564C
		public string FileName
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._FileNameInArchive;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				string text;
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							goto IL_B5;
						case 1:
							goto IL_FB;
						case 2:
							return;
						case 3:
							if (this._container.ZipFile == null)
							{
								goto Block_1;
							}
							if (string.IsNullOrEmpty(value))
							{
								num = delegate0da.f0000d7(0);
								continue;
							}
							text = ZipEntry.NameInArchive(value, null);
							if (delegate0db.f0000d9(this._FileNameInArchive, text))
							{
								num = delegate0da.f0000d7(-2);
								continue;
							}
							this._container.ZipFile.RemoveEntry(this);
							this._container.ZipFile.InternalAddEntry(text, this);
							num = delegate0da.f0000d7(-1);
							continue;
						}
						break;
					}
				}
				return;
				Block_1:
				throw new ZipException(c0000c0.m00000f("Ò`#\nÉ\u001d\u0013EÉ\u001c/Am·\u0017\u000eæÇ\0\u0012_½!\u008d=Ñ\u0003þdÍ\u0093ÆrE>\tü­I\u009e\u001e7¡åÔLÖE\u0081\u008cJ£²Pw¡ÊÄy\u0097¹=P\u0087úÅz¢)\u0081\u00a0&"));
				IL_B5:
				throw new ZipException(c0000c0.m00000f("Åi(Dà\0_Râ\u0013#I(ú8\u0014â¢\f\u0003\rªuÃsÛ\u001a®cÁÃ×sSj\u0002÷ã\r\u009eK\u0001¤»"));
				IL_FB:
				this._FileNameInArchive = text;
				this._container.ZipFile.NotifyEntryChanged();
				this._metadataChanged = true;
			}
		}

		// Token: 0x170000C3 RID: 195
		// (get) Token: 0x060003F8 RID: 1016 RVA: 0x00017574 File Offset: 0x00015774
		// (set) Token: 0x060003F9 RID: 1017 RVA: 0x00017588 File Offset: 0x00015788
		public Stream InputStream
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._sourceStream;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							goto IL_7B;
						case 1:
							goto IL_8B;
						case 2:
							goto IL_36;
						case 3:
							if (this._Source != ZipEntrySource.Stream)
							{
								num = delegate0da.f0000d7(0);
								continue;
							}
							goto IL_36;
						}
						break;
						IL_36:
						this._sourceWasJitProvided = true;
						num = delegate0da.f0000d7(-1);
					}
				}
				IL_7B:
				throw new ZipException(c0000c0.m00000f("Èn8DË\u001c@C\u008c\u001c!X(ä(\u0013¶ö\u0006\u0003\r­tÝ&ÊW­cÊ\u0086×p\u0017,\u0003ê­T\u0098W\u001eèÏòIç[\u0080\u008a`ù"));
				IL_8B:
				this._sourceStream = value;
			}
		}

		// Token: 0x170000C4 RID: 196
		// (get) Token: 0x060003FA RID: 1018 RVA: 0x00017628 File Offset: 0x00015828
		public bool InputStreamWasJitProvided
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._sourceWasJitProvided;
			}
		}

		// Token: 0x170000C5 RID: 197
		// (get) Token: 0x060003FB RID: 1019 RVA: 0x0001763C File Offset: 0x0001583C
		public ZipEntrySource Source
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._Source;
			}
		}

		// Token: 0x170000C6 RID: 198
		// (get) Token: 0x060003FC RID: 1020 RVA: 0x00017650 File Offset: 0x00015850
		public short VersionNeeded
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._VersionNeeded;
			}
		}

		// Token: 0x170000C7 RID: 199
		// (get) Token: 0x060003FD RID: 1021 RVA: 0x00017664 File Offset: 0x00015864
		// (set) Token: 0x060003FE RID: 1022 RVA: 0x00017678 File Offset: 0x00015878
		public string Comment
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._Comment;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this._Comment = value;
				this._metadataChanged = true;
			}
		}

		// Token: 0x170000C8 RID: 200
		// (get) Token: 0x060003FF RID: 1023 RVA: 0x00017694 File Offset: 0x00015894
		public bool? RequiresZip64
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._entryRequiresZip64;
			}
		}

		// Token: 0x170000C9 RID: 201
		// (get) Token: 0x06000400 RID: 1024 RVA: 0x000176A8 File Offset: 0x000158A8
		public bool? OutputUsedZip64
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._OutputUsesZip64;
			}
		}

		// Token: 0x170000CA RID: 202
		// (get) Token: 0x06000401 RID: 1025 RVA: 0x000176BC File Offset: 0x000158BC
		public short BitField
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._BitField;
			}
		}

		// Token: 0x170000CB RID: 203
		// (get) Token: 0x06000402 RID: 1026 RVA: 0x000176D0 File Offset: 0x000158D0
		// (set) Token: 0x06000403 RID: 1027 RVA: 0x000176E4 File Offset: 0x000158E4
		public CompressionMethod CompressionMethod
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return (CompressionMethod)this._CompressionMethod;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							if (value != CompressionMethod.Deflate)
							{
								goto Block_5;
							}
							goto IL_BB;
						case 1:
							goto IL_4D;
						case 2:
							goto IL_36;
						case 3:
							if (value == (CompressionMethod)this._CompressionMethod)
							{
								return;
							}
							if (value != CompressionMethod.None)
							{
								num = delegate0da.f0000d7(0);
								continue;
							}
							goto IL_BB;
						}
						break;
						IL_BB:
						this._CompressionMethod = (short)value;
						num = delegate0da.f0000d7(-2);
					}
				}
				IL_36:
				if (this._CompressionMethod == 0)
				{
					this._CompressionLevel = CompressionLevel.None;
					goto IL_5F;
				}
				IL_4D:
				if (this.CompressionLevel == CompressionLevel.None)
				{
					this._CompressionLevel = CompressionLevel.f000073;
				}
				IL_5F:
				this._container.ZipFile.NotifyEntryChanged();
				this._restreamRequiredOnSave = true;
				return;
				Block_5:
				throw new InvalidOperationException(c0000c0.m00000f("Äo>\u0011Ö\u0019\\EØ\u0017*\fkø \u0017äç\u001d\u0015D«t\u008d>Û\u0003¶xÜÍ\u0096NG/\u000fñëYÐ}\u0002¥åé\\ÑF\u009d\u0097w\u009a¥A~£\u0081°T\u0082\u0096?A\u0086ë¶a¢l£¢e\u0012\u000eMÌ\u0088ê~tV$\u009duðhÚ©N\u0013àÖ"));
			}
		}

		// Token: 0x170000CC RID: 204
		// (get) Token: 0x06000404 RID: 1028 RVA: 0x000177CC File Offset: 0x000159CC
		// (set) Token: 0x06000405 RID: 1029 RVA: 0x000177E0 File Offset: 0x000159E0
		public CompressionLevel CompressionLevel
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._CompressionLevel;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							goto IL_8C;
						case 1:
							goto IL_BC;
						case 2:
							return;
						case 3:
							if (value == CompressionLevel.f000073 && this._CompressionMethod == 8)
							{
								return;
							}
							goto IL_8C;
						}
						break;
						IL_8C:
						this._CompressionLevel = value;
						if (value == CompressionLevel.None && this._CompressionMethod == 0)
						{
							num = delegate0da.f0000d7(-2);
						}
						else
						{
							this._CompressionMethod = ((this._CompressionLevel == CompressionLevel.None) ? 0 : 8);
							if (this._container.ZipFile == null)
							{
								goto IL_CC;
							}
							num = delegate0da.f0000d7(-1);
						}
					}
				}
				return;
				IL_BC:
				this._container.ZipFile.NotifyEntryChanged();
				IL_CC:
				this._restreamRequiredOnSave = true;
			}
		}

		// Token: 0x170000CD RID: 205
		// (get) Token: 0x06000406 RID: 1030 RVA: 0x000178C0 File Offset: 0x00015AC0
		public long CompressedSize
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._CompressedSize;
			}
		}

		// Token: 0x170000CE RID: 206
		// (get) Token: 0x06000407 RID: 1031 RVA: 0x000178D4 File Offset: 0x00015AD4
		public long UncompressedSize
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._UncompressedSize;
			}
		}

		// Token: 0x170000CF RID: 207
		// (get) Token: 0x06000408 RID: 1032 RVA: 0x000178E8 File Offset: 0x00015AE8
		public double CompressionRatio
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				if (this.UncompressedSize == 0L)
				{
					return 0.0;
				}
				return 100.0 * (1.0 - 1.0 * (double)this.CompressedSize / (1.0 * (double)this.UncompressedSize));
			}
		}

		// Token: 0x170000D0 RID: 208
		// (get) Token: 0x06000409 RID: 1033 RVA: 0x00017944 File Offset: 0x00015B44
		public int Crc
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this.f00004b;
			}
		}

		// Token: 0x170000D1 RID: 209
		// (get) Token: 0x0600040A RID: 1034 RVA: 0x00017958 File Offset: 0x00015B58
		public bool IsDirectory
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._IsDirectory;
			}
		}

		// Token: 0x170000D2 RID: 210
		// (get) Token: 0x0600040B RID: 1035 RVA: 0x0001796C File Offset: 0x00015B6C
		public bool UsesEncryption
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._Encryption_FromZipFile != EncryptionAlgorithm.None;
			}
		}

		// Token: 0x170000D3 RID: 211
		// (get) Token: 0x0600040C RID: 1036 RVA: 0x00017988 File Offset: 0x00015B88
		// (set) Token: 0x0600040D RID: 1037 RVA: 0x0001799C File Offset: 0x00015B9C
		public EncryptionAlgorithm Encryption
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._Encryption;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							goto IL_64;
						case 1:
							goto IL_7B;
						case 2:
							goto IL_05;
						case 3:
							if (value == this._Encryption)
							{
								return;
							}
							goto IL_64;
						}
						break;
						IL_05:
						this._Encryption = value;
						this._restreamRequiredOnSave = true;
						num = delegate0da.f0000d7(-1);
						continue;
						IL_64:
						if (value == EncryptionAlgorithm.Unsupported)
						{
							goto Block_2;
						}
						goto IL_05;
					}
				}
				return;
				Block_2:
				throw new InvalidOperationException(c0000c0.m00000f("Èn8DË\bJ\u0017Â\u001d:\f{ò9GÓì\r\u0014T´nÄ<ÐWªx\u0098\u0097Þ|Cj\u001aùáU\u0095\u0010"));
				IL_7B:
				if (this._container.ZipFile != null)
				{
					this._container.ZipFile.NotifyEntryChanged();
				}
			}
		}

		// Token: 0x170000D4 RID: 212
		// (set) Token: 0x0600040E RID: 1038 RVA: 0x00017A44 File Offset: 0x00015C44
		public string Password
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							goto IL_8F;
						case 1:
							goto IL_97;
						case 2:
							goto IL_36;
						case 3:
							this._Password = value;
							if (this._Password == null)
							{
								num = delegate0da.f0000d7(0);
								continue;
							}
							goto IL_36;
						}
						break;
						IL_36:
						if (this._Source != ZipEntrySource.ZipFile || this._sourceIsEncrypted)
						{
							goto IL_9E;
						}
						num = delegate0da.f0000d7(-1);
					}
				}
				IL_8F:
				this._Encryption = EncryptionAlgorithm.None;
				return;
				IL_97:
				this._restreamRequiredOnSave = true;
				IL_9E:
				if (this.Encryption == EncryptionAlgorithm.None)
				{
					this._Encryption = EncryptionAlgorithm.PkzipWeak;
				}
			}
		}

		// Token: 0x170000D5 RID: 213
		// (get) Token: 0x0600040F RID: 1039 RVA: 0x00017B04 File Offset: 0x00015D04
		internal bool IsChanged
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._restreamRequiredOnSave | this._metadataChanged;
			}
		}

		// Token: 0x170000D6 RID: 214
		// (get) Token: 0x06000410 RID: 1040 RVA: 0x00017B20 File Offset: 0x00015D20
		// (set) Token: 0x06000411 RID: 1041 RVA: 0x00017B34 File Offset: 0x00015D34
		public ExtractExistingFileAction ExtractExistingFile { [MethodImpl(MethodImplOptions.NoInlining)] get; [MethodImpl(MethodImplOptions.NoInlining)] set; }

		// Token: 0x170000D7 RID: 215
		// (get) Token: 0x06000412 RID: 1042 RVA: 0x00017B48 File Offset: 0x00015D48
		// (set) Token: 0x06000413 RID: 1043 RVA: 0x00017B5C File Offset: 0x00015D5C
		public ZipErrorAction ZipErrorAction { [MethodImpl(MethodImplOptions.NoInlining)] get; [MethodImpl(MethodImplOptions.NoInlining)] set; }

		// Token: 0x170000D8 RID: 216
		// (get) Token: 0x06000414 RID: 1044 RVA: 0x00017B70 File Offset: 0x00015D70
		public bool IncludedInMostRecentSave
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return !this._skippedDuringSave;
			}
		}

		// Token: 0x170000D9 RID: 217
		// (get) Token: 0x06000415 RID: 1045 RVA: 0x00017B88 File Offset: 0x00015D88
		// (set) Token: 0x06000416 RID: 1046 RVA: 0x00017B9C File Offset: 0x00015D9C
		public SetCompressionCallback SetCompression { [MethodImpl(MethodImplOptions.NoInlining)] get; [MethodImpl(MethodImplOptions.NoInlining)] set; }

		// Token: 0x170000DA RID: 218
		// (get) Token: 0x06000417 RID: 1047 RVA: 0x00017BB0 File Offset: 0x00015DB0
		// (set) Token: 0x06000418 RID: 1048 RVA: 0x00017BDC File Offset: 0x00015DDC
		public bool UseUnicodeAsNecessary
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._provisionalAlternateEncoding == delegate0c7.f000090(c0000c0.m00000f("ÄU\vI\u009e"));
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this._provisionalAlternateEncoding = (value ? Encoding.GetEncoding(c0000c0.m00000f("ÄU\vI\u009e")) : ZipFile.DefaultEncoding);
			}
		}

		// Token: 0x170000DB RID: 219
		// (get) Token: 0x06000419 RID: 1049 RVA: 0x00017C08 File Offset: 0x00015E08
		// (set) Token: 0x0600041A RID: 1050 RVA: 0x00017C1C File Offset: 0x00015E1C
		public Encoding ProvisionalAlternateEncoding
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._provisionalAlternateEncoding;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this._provisionalAlternateEncoding = value;
			}
		}

		// Token: 0x170000DC RID: 220
		// (get) Token: 0x0600041B RID: 1051 RVA: 0x00017C30 File Offset: 0x00015E30
		public Encoding ActualEncoding
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._actualEncoding;
			}
		}

		// Token: 0x0600041C RID: 1052 RVA: 0x00017C44 File Offset: 0x00015E44
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static string NameInArchive(string filename, string directoryPathInArchive)
		{
			string text;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_85;
					case 1:
						goto IL_8C;
					case 2:
						goto IL_36;
					case 3:
						text = null;
						if (directoryPathInArchive == null)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_36;
					}
					break;
					IL_36:
					if (!string.IsNullOrEmpty(directoryPathInArchive))
					{
						goto IL_91;
					}
					text = delegate0e4.f0000f0(filename);
					num = delegate0da.f0000d7(-1);
				}
			}
			IL_85:
			text = filename;
			IL_8C:
			goto IL_A3;
			IL_91:
			text = Path.Combine(directoryPathInArchive, delegate0e4.f0000f0(filename));
			IL_A3:
			text = SharedUtilities.NormalizePathForUseInZipFile(text);
			return text;
		}

		// Token: 0x0600041D RID: 1053 RVA: 0x00017CFC File Offset: 0x00015EFC
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static ZipEntry CreateFromNothing(string nameInArchive)
		{
			return ZipEntry.Create(nameInArchive, ZipEntrySource.None, null, null);
		}

		// Token: 0x0600041E RID: 1054 RVA: 0x00017D14 File Offset: 0x00015F14
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static ZipEntry CreateFromFile(string filename, string nameInArchive)
		{
			return ZipEntry.Create(nameInArchive, ZipEntrySource.FileSystem, filename, null);
		}

		// Token: 0x0600041F RID: 1055 RVA: 0x00017D2C File Offset: 0x00015F2C
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static ZipEntry CreateForStream(string entryName, Stream p1)
		{
			return ZipEntry.Create(entryName, ZipEntrySource.Stream, p1, null);
		}

		// Token: 0x06000420 RID: 1056 RVA: 0x00017D44 File Offset: 0x00015F44
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static ZipEntry CreateForWriter(string entryName, WriteDelegate p1)
		{
			return ZipEntry.Create(entryName, ZipEntrySource.WriteDelegate, p1, null);
		}

		// Token: 0x06000421 RID: 1057 RVA: 0x00017D5C File Offset: 0x00015F5C
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static ZipEntry CreateForJitStreamProvider(string nameInArchive, OpenDelegate opener, CloseDelegate closer)
		{
			return ZipEntry.Create(nameInArchive, ZipEntrySource.JitStream, opener, closer);
		}

		// Token: 0x06000422 RID: 1058 RVA: 0x00017D74 File Offset: 0x00015F74
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static ZipEntry CreateForZipOutputStream(string nameInArchive)
		{
			return ZipEntry.Create(nameInArchive, ZipEntrySource.ZipOutputStream, null, null);
		}

		// Token: 0x06000423 RID: 1059 RVA: 0x00017D8C File Offset: 0x00015F8C
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static ZipEntry Create(string nameInArchive, ZipEntrySource source, object arg1, object arg2)
		{
			ZipEntry zipEntry;
			string p;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_11E;
					case 1:
						goto IL_15F;
					case 2:
						goto IL_36;
					case 3:
						if (string.IsNullOrEmpty(nameInArchive))
						{
							goto Block_4;
						}
						zipEntry = new ZipEntry();
						zipEntry._VersionMadeBy = 45;
						zipEntry._Source = source;
						zipEntry._Mtime = (zipEntry._Atime = (zipEntry._Ctime = delegate0cf.f0000b9()));
						if (source == ZipEntrySource.Stream)
						{
							zipEntry._sourceStream = (arg1 as Stream);
							num = delegate0da.f0000d7(0);
							continue;
						}
						if (source == ZipEntrySource.WriteDelegate)
						{
							goto Block_6;
						}
						if (source == ZipEntrySource.JitStream)
						{
							goto Block_7;
						}
						goto IL_36;
					}
					break;
					IL_36:
					if (source == ZipEntrySource.ZipOutputStream)
					{
						goto IL_1CA;
					}
					if (source == ZipEntrySource.None)
					{
						goto Block_2;
					}
					p = (arg1 as string);
					if (delegate0d2.f0000c3(p))
					{
						goto Block_3;
					}
					zipEntry._Mtime = delegate014c.f000190(p);
					num = delegate0da.f0000d7(-1);
				}
			}
			Block_2:
			zipEntry._Source = ZipEntrySource.FileSystem;
			goto IL_1CA;
			Block_3:
			throw new ZipException(c0000c0.m00000f("Åi(DÀ\0_RÂ\u0013#I(ú8\u0014â¢\f\u0003\rªuÃ~Ð\u0002²{\u0098\u0082Øy\u0017$\u0003ö\u00a0E\u009dN\u0019±»"));
			Block_4:
			throw new ZipException(c0000c0.m00000f("Åi(DÃ\aGEÕR Meòm\nãñ\u001aFO¡:Ã<ÐZ°bÔ\u008f\u0096|Y.LöâNÝ[\0¸áâ\u0017"));
			IL_11E:
			goto IL_1CA;
			Block_6:
			zipEntry._WriteDelegate = (arg1 as WriteDelegate);
			goto IL_1CA;
			Block_7:
			zipEntry._OpenDelegate = (arg1 as OpenDelegate);
			zipEntry._CloseDelegate = (arg2 as CloseDelegate);
			goto IL_1CA;
			IL_15F:
			zipEntry._Ctime = delegate014c.f000191(p);
			zipEntry._Atime = delegate014c.f000192(p);
			if (delegate0d2.f0000c1(p) || delegate0d2.f0000c2(p))
			{
				zipEntry._ExternalFileAttrs = (int)delegate013a.f000178(p);
			}
			zipEntry._ntfsTimesAreSet = true;
			zipEntry._LocalFileName = delegate0e4.f0000f1(p);
			IL_1CA:
			zipEntry._LastModified = zipEntry._Mtime;
			zipEntry._FileNameInArchive = SharedUtilities.NormalizePathForUseInZipFile(nameInArchive);
			return zipEntry;
		}

		// Token: 0x06000424 RID: 1060 RVA: 0x00017F7C File Offset: 0x0001617C
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void MarkAsDirectory()
		{
			this._IsDirectory = true;
			if (!this._FileNameInArchive.EndsWith(c0000c0.m00000f("¾")))
			{
				this._FileNameInArchive += c0000c0.m00000f("¾");
			}
		}

		// Token: 0x170000DD RID: 221
		// (get) Token: 0x06000425 RID: 1061 RVA: 0x00017FC4 File Offset: 0x000161C4
		// (set) Token: 0x06000426 RID: 1062 RVA: 0x00017FD8 File Offset: 0x000161D8
		public bool IsText
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				return this._IsText;
			}
			[MethodImpl(MethodImplOptions.NoInlining)]
			set
			{
				this._IsText = value;
			}
		}

		// Token: 0x06000427 RID: 1063 RVA: 0x00017FEC File Offset: 0x000161EC
		[MethodImpl(MethodImplOptions.NoInlining)]
		public override string ToString()
		{
			return delegate0101.f000127(c0000c0.m00000f("Ëh=!È\u001dAN\u0096H5\u001cu"), this.FileName);
		}

		// Token: 0x170000DE RID: 222
		// (get) Token: 0x06000428 RID: 1064 RVA: 0x00018014 File Offset: 0x00016214
		internal Stream ArchiveStream
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				ZipFile zipFile;
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							zipFile = this._container.ZipFile;
							zipFile.Reset();
							num = delegate0da.f0000d7(-2);
							continue;
						case 1:
							goto IL_AA;
						case 2:
							goto IL_36;
						case 3:
							if (this._archiveStream != null)
							{
								goto IL_C0;
							}
							if (this._container.ZipFile != null)
							{
								num = delegate0da.f0000d7(0);
								continue;
							}
							goto IL_AA;
						}
						break;
					}
				}
				IL_36:
				this._archiveStream = zipFile.StreamForDiskNumber(this._diskNumber);
				goto IL_C0;
				IL_AA:
				this._archiveStream = this._container.ZipOutputStream.OutputStream;
				IL_C0:
				return this._archiveStream;
			}
		}

		// Token: 0x06000429 RID: 1065 RVA: 0x000180E8 File Offset: 0x000162E8
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void SetFdpLoh()
		{
			long position = this.ArchiveStream.Position;
			this.ArchiveStream.Seek(this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
			byte[] array = new byte[30];
			this.ArchiveStream.Read(array, 0, array.Length);
			short num = (short)((int)array[26] + (int)array[27] * 256);
			short num2 = (short)((int)array[28] + (int)array[29] * 256);
			this.ArchiveStream.Seek((long)(num + num2), SeekOrigin.Current);
			this._LengthOfHeader = (int)(30 + num2 + num) + ZipEntry.GetLengthOfCryptoHeaderBytes(this._Encryption_FromZipFile);
			this.__FileDataPosition = this._RelativeOffsetOfLocalHeader + (long)this._LengthOfHeader;
			this.ArchiveStream.Seek(position, SeekOrigin.Begin);
		}

		// Token: 0x0600042A RID: 1066 RVA: 0x000181A4 File Offset: 0x000163A4
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static int GetKeyStrengthInBits(EncryptionAlgorithm p0)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						return 256;
					case 1:
						return 128;
					case 2:
						goto IL_36;
					case 3:
						if (p0 == EncryptionAlgorithm.WinZipAes256)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_36;
					}
					break;
					IL_36:
					if (p0 != EncryptionAlgorithm.WinZipAes128)
					{
						return -1;
					}
					num = delegate0da.f0000d7(-1);
				}
			}
			return 256;
		}

		// Token: 0x0600042B RID: 1067 RVA: 0x00018234 File Offset: 0x00016434
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static int GetLengthOfCryptoHeaderBytes(EncryptionAlgorithm p0)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					int result;
					switch (num)
					{
					case 0:
						goto IL_65;
					case 1:
						return result;
					case 2:
						goto IL_36;
					case 3:
						if (p0 == EncryptionAlgorithm.None)
						{
							return 0;
						}
						goto IL_65;
					}
					break;
					IL_36:
					int keyStrengthInBits = ZipEntry.GetKeyStrengthInBits(p0);
					result = keyStrengthInBits / 8 / 2 + 2;
					num = delegate0da.f0000d7(-1);
					continue;
					IL_65:
					if (p0 == EncryptionAlgorithm.WinZipAes128)
					{
						goto IL_36;
					}
					if (p0 != EncryptionAlgorithm.WinZipAes256)
					{
						goto IL_8F;
					}
					num = delegate0da.f0000d7(-2);
				}
			}
			return 0;
			IL_8F:
			if (p0 == EncryptionAlgorithm.PkzipWeak)
			{
				return 12;
			}
			throw new ZipException(c0000c0.m00000f("øo9\u0001Ô\aR[\u008c\u0017<^gå"));
		}

		// Token: 0x170000DF RID: 223
		// (get) Token: 0x0600042C RID: 1068 RVA: 0x000182EC File Offset: 0x000164EC
		internal long FileDataPosition
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				if (this.__FileDataPosition == -1L)
				{
					this.SetFdpLoh();
				}
				return this.__FileDataPosition;
			}
		}

		// Token: 0x170000E0 RID: 224
		// (get) Token: 0x0600042D RID: 1069 RVA: 0x00018314 File Offset: 0x00016514
		private int LengthOfHeader
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				if (this._LengthOfHeader == 0)
				{
					this.SetFdpLoh();
				}
				return this._LengthOfHeader;
			}
		}

		// Token: 0x0600042E RID: 1070 RVA: 0x00018338 File Offset: 0x00016538
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void Extract()
		{
			this.InternalExtract(c0000c0.m00000f("¿"), null, null);
		}

		// Token: 0x0600042F RID: 1071 RVA: 0x00018358 File Offset: 0x00016558
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void Extract(ExtractExistingFileAction extractExistingFile)
		{
			this.ExtractExistingFile = extractExistingFile;
			this.InternalExtract(c0000c0.m00000f("¿"), null, null);
		}

		// Token: 0x06000430 RID: 1072 RVA: 0x00018380 File Offset: 0x00016580
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void Extract(Stream stream)
		{
			this.InternalExtract(null, stream, null);
		}

		// Token: 0x06000431 RID: 1073 RVA: 0x00018398 File Offset: 0x00016598
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void Extract(string baseDirectory)
		{
			this.InternalExtract(baseDirectory, null, null);
		}

		// Token: 0x06000432 RID: 1074 RVA: 0x000183B0 File Offset: 0x000165B0
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void Extract(string baseDirectory, ExtractExistingFileAction extractExistingFile)
		{
			this.ExtractExistingFile = extractExistingFile;
			this.InternalExtract(baseDirectory, null, null);
		}

		// Token: 0x06000433 RID: 1075 RVA: 0x000183D0 File Offset: 0x000165D0
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void ExtractWithPassword(string password)
		{
			this.InternalExtract(c0000c0.m00000f("¿"), null, password);
		}

		// Token: 0x06000434 RID: 1076 RVA: 0x000183F0 File Offset: 0x000165F0
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void ExtractWithPassword(string baseDirectory, string password)
		{
			this.InternalExtract(baseDirectory, null, password);
		}

		// Token: 0x06000435 RID: 1077 RVA: 0x00018408 File Offset: 0x00016608
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void ExtractWithPassword(ExtractExistingFileAction extractExistingFile, string password)
		{
			this.ExtractExistingFile = extractExistingFile;
			this.InternalExtract(c0000c0.m00000f("¿"), null, password);
		}

		// Token: 0x06000436 RID: 1078 RVA: 0x00018430 File Offset: 0x00016630
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void ExtractWithPassword(string baseDirectory, ExtractExistingFileAction extractExistingFile, string password)
		{
			this.ExtractExistingFile = extractExistingFile;
			this.InternalExtract(baseDirectory, null, password);
		}

		// Token: 0x06000437 RID: 1079 RVA: 0x00018450 File Offset: 0x00016650
		[MethodImpl(MethodImplOptions.NoInlining)]
		public void ExtractWithPassword(Stream stream, string password)
		{
			this.InternalExtract(null, stream, password);
		}

		// Token: 0x06000438 RID: 1080 RVA: 0x00018468 File Offset: 0x00016668
		[MethodImpl(MethodImplOptions.NoInlining)]
		public CrcCalculatorStream OpenReader()
		{
			return this.InternalOpenReader(this._Password ?? this._container.Password);
		}

		// Token: 0x06000439 RID: 1081 RVA: 0x00018494 File Offset: 0x00016694
		[MethodImpl(MethodImplOptions.NoInlining)]
		public CrcCalculatorStream OpenReader(string password)
		{
			return this.InternalOpenReader(password);
		}

		// Token: 0x0600043A RID: 1082 RVA: 0x000184A8 File Offset: 0x000166A8
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal CrcCalculatorStream InternalOpenReader(string password)
		{
			long length;
			Stream archiveStream;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					long num2;
					switch (num)
					{
					case 0:
						if (this._Source != ZipEntrySource.ZipFile)
						{
							goto Block_1;
						}
						if (this._CompressionMethod_FromZipFile != 0)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						num2 = this._CompressedFileDataSize;
						goto IL_47;
					case 1:
						goto IL_E6;
					case 2:
						num2 = this.UncompressedSize;
						goto IL_47;
					case 3:
						this.ValidateCompression();
						this.ValidateEncryption();
						this.SetupCryptoForExtract(password);
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
					IL_47:
					length = num2;
					archiveStream = this.ArchiveStream;
					this.ArchiveStream.Seek(this.FileDataPosition, SeekOrigin.Begin);
					num = delegate0da.f0000d7(-1);
				}
			}
			Block_1:
			throw new BadStateException(c0000c0.m00000f("Èn8DË\u001c@C\u008c\u0011/@d·\u0017\u000eæÄ\a\nHêIÌ%ÛW¼rÞ\u008cÄx\u0017)\rôáI\u009eYM\u0087åþWðP\u0095\u009c|¥î"));
			IL_E6:
			this._inputDecryptorStream = this.GetExtractDecryptor(archiveStream);
			Stream extractDecompressor = this.GetExtractDecompressor(this._inputDecryptorStream);
			return new CrcCalculatorStream(extractDecompressor, length);
		}

		// Token: 0x0600043B RID: 1083 RVA: 0x000185BC File Offset: 0x000167BC
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void OnExtractProgress(long bytesWritten, long totalBytesToWrite)
		{
			if (this._container.ZipFile != null)
			{
				this._ioOperationCanceled = this._container.ZipFile.OnExtractBlock(this, bytesWritten, totalBytesToWrite);
			}
		}

		// Token: 0x0600043C RID: 1084 RVA: 0x000185F4 File Offset: 0x000167F4
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void OnBeforeExtract(string path)
		{
			if (this._container.ZipFile != null && !this._container.ZipFile._inExtractAll)
			{
				this._ioOperationCanceled = this._container.ZipFile.OnSingleEntryExtract(this, path, true);
			}
		}

		// Token: 0x0600043D RID: 1085 RVA: 0x00018640 File Offset: 0x00016840
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void OnAfterExtract(string path)
		{
			if (this._container.ZipFile != null && !this._container.ZipFile._inExtractAll)
			{
				this._container.ZipFile.OnSingleEntryExtract(this, path, false);
			}
		}

		// Token: 0x0600043E RID: 1086 RVA: 0x00018688 File Offset: 0x00016888
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void OnExtractExisting(string path)
		{
			if (this._container.ZipFile != null)
			{
				this._ioOperationCanceled = this._container.ZipFile.OnExtractExisting(this, path);
			}
		}

		// Token: 0x0600043F RID: 1087 RVA: 0x000186C0 File Offset: 0x000168C0
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static void ReallyDelete(string fileName)
		{
			if ((delegate013a.f000178(fileName) & FileAttributes.ReadOnly) == FileAttributes.ReadOnly)
			{
				delegate014d.f000193(fileName, FileAttributes.Normal);
			}
			File.Delete(fileName);
		}

		// Token: 0x06000440 RID: 1088 RVA: 0x000186F4 File Offset: 0x000168F4
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void WriteStatus(string format, params object[] args)
		{
			if (this._container.ZipFile != null && this._container.ZipFile.Verbose)
			{
				this._container.ZipFile.StatusMessageTextWriter.WriteLine(format, args);
			}
		}

		// Token: 0x06000441 RID: 1089 RVA: 0x00018740 File Offset: 0x00016940
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void InternalExtract(string baseDir, Stream outstream, string password)
		{
			if (this._container == null)
			{
				throw new BadStateException(c0000c0.m00000f("Åi$\u0017\u00863ZGé\u001c:^q·$\u0014¶ã\0FB¶jÅ2ÐY"));
			}
			this._container.ZipFile.Reset();
			if (this._Source != ZipEntrySource.ZipFile)
			{
				throw new BadStateException(c0000c0.m00000f("Èn8DË\u001c@C\u008c\u0011/@d·\u0017\u000eæÄ\a\nHêIÌ%ÛW¼rÞ\u008cÄx\u0017)\rôáI\u009eYM©ûâ\u0019çM\u0080\u008ax´´\u0015{©\u0091ö\u007f\u0083Þ"));
			}
			this.OnBeforeExtract(baseDir);
			this._ioOperationCanceled = false;
			string text = null;
			bool flag = false;
			this.ValidateCompression();
			this.ValidateEncryption();
			if (this.ValidateOutput(baseDir, outstream, out text))
			{
				this.WriteStatus(c0000c0.m00000f("ôy9\u0016Ç\nG\u0017È\u001b<\fs§0I¸¬"), new object[]
				{
					text
				});
				this.OnAfterExtract(baseDir);
			}
			else
			{
				string text2 = password ?? (this._Password ?? this._container.Password);
				if (this._Encryption_FromZipFile != EncryptionAlgorithm.None)
				{
					if (text2 == null)
					{
						throw new BadPasswordException();
					}
					this.SetupCryptoForExtract(text2);
				}
				Stream stream;
				if (text != null)
				{
					this.WriteStatus(c0000c0.m00000f("ôy9\u0016Ç\nG\u0017Ê\u001b\"I(ì}\u001a¸¬@"), new object[]
					{
						text
					});
					if (!delegate0d2.f0000c2(delegate0e4.f0000ed(text)))
					{
						delegate0d9.f0000d6(delegate0e4.f0000ed(text));
					}
					else if (this._container.ZipFile != null)
					{
						flag = this._container.ZipFile._inExtractAll;
					}
					if (File.Exists(text))
					{
						int num = this.CheckExtractExistingFile(baseDir, text);
						if (num == 2)
						{
							goto IL_297;
						}
						if (num == 1)
						{
							return;
						}
					}
					stream = new FileStream(text, FileMode.CreateNew);
				}
				else
				{
					this.WriteStatus(c0000c0.m00000f("ôy9\u0016Ç\nG\u0017É\u001c:^q·6Wë¢\u001a\t\r·nß6ß\u001að9\u0096"), new object[]
					{
						this.FileName
					});
					stream = outstream;
				}
				if (!this._ioOperationCanceled)
				{
					int actualCrc = this._ExtractOne(stream);
					if (!this._ioOperationCanceled)
					{
						this.VerifyCrcAfterExtract(actualCrc);
						if (text != null)
						{
							delegate0c9.f00009a(stream);
							this._SetTimes(text, true);
							if (flag && this.FileName.IndexOf('/') != -1)
							{
								string fileName = delegate0e4.f0000ed(this.FileName);
								if (this._container.ZipFile[fileName] == null)
								{
									this._SetTimes(delegate0e4.f0000ed(text), false);
								}
							}
							if (((int)this._VersionMadeBy & 65280) == 2560 || ((int)this._VersionMadeBy & 65280) == 0)
							{
								File.SetAttributes(text, (FileAttributes)this._ExternalFileAttrs);
							}
						}
						this.OnAfterExtract(baseDir);
					}
				}
				IL_297:;
			}
		}

		// Token: 0x06000442 RID: 1090 RVA: 0x000189F0 File Offset: 0x00016BF0
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void VerifyCrcAfterExtract(int ActualCrc32)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						if (this.Encryption == EncryptionAlgorithm.WinZipAes256)
						{
							goto IL_D6;
						}
						goto IL_36;
					case 1:
						goto IL_FC;
					case 2:
						goto IL_36;
					case 3:
						if (ActualCrc32 == this.f00004b)
						{
							goto IL_70;
						}
						if (this.Encryption != EncryptionAlgorithm.WinZipAes128)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_D6;
					}
					break;
					IL_70:
					if (this.Encryption != EncryptionAlgorithm.WinZipAes128)
					{
						num = delegate0da.f0000d7(-1);
						continue;
					}
					goto IL_108;
					IL_D6:
					if (this._WinZipAesMethod == 2)
					{
						goto IL_70;
					}
					num = delegate0da.f0000d7(-2);
				}
			}
			IL_36:
			throw new BadCrcException(c0000c0.m00000f("ÒS\u000eDÃ\u001bAXÞHnX`òm\u0001ÿî\vFO¡sÃ4\u009e\u0012¦cÊ\u0082ÕiR.LùýP\u0095_\u001f»µïV\u0082W\u0091Øz¸²Gc¼\u0091ûtÉÐ") + delegate0d5.f0000c9(c0000c0.m00000f("Ôy=\u0001Å\u001dVS\u008cB6W8­\u0015_ë®N'N°oÌ?\u009eG¦l\u0089Ùî%J"), this.f00004b, ActualCrc32));
			IL_FC:
			if (this.Encryption != EncryptionAlgorithm.WinZipAes256)
			{
				return;
			}
			IL_108:
			WinZipAesCipherStream winZipAesCipherStream = this._inputDecryptorStream as WinZipAesCipherStream;
			this._aesCrypto_forExtract.CalculatedMac = winZipAesCipherStream.FinalAuthentication;
			this._aesCrypto_forExtract.ReadAndVerifyMac(this.ArchiveStream);
		}

		// Token: 0x06000443 RID: 1091 RVA: 0x00018B34 File Offset: 0x00016D34
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int CheckExtractExistingFile(string baseDir, string TargetFile)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_CA;
					case 1:
					{
						IL_EE:
						this.OnExtractExisting(baseDir);
						if (this._ioOperationCanceled)
						{
							return 2;
						}
						int num2;
						num2++;
						goto IL_97;
					}
					case 2:
						goto IL_6A;
					case 3:
					{
						int num2 = 0;
						goto IL_97;
					}
					}
					break;
					IL_97:
					switch (this.ExtractExistingFile)
					{
					default:
						goto IL_B4;
					case ExtractExistingFileAction.OverwriteSilently:
						goto IL_CA;
					case ExtractExistingFileAction.DoNotOverwrite:
						this.WriteStatus(c0000c0.m00000f("åi(DÀ\0_R\u008c\t~Q(ò5\u000eåö\u001d]\rªuÙsÛ\u000fªeÙ\u0080ÂtY-LýãT\u0082GCæ»"), new object[]
						{
							this.FileName
						});
						num = delegate0da.f0000d7(-2);
						break;
					case ExtractExistingFileAction.InvokeExtractProgressEvent:
					{
						int num2;
						if (num2 > 0)
						{
							goto Block_1;
						}
						goto IL_EE;
					}
					}
				}
			}
			IL_6A:
			this.OnAfterExtract(baseDir);
			return 1;
			Block_1:
			throw new ZipException(delegate0101.f000127(c0000c0.m00000f("Åi(DÀ\0_R\u008c\t~Q(ö!\u0015óã\n\u001f\r¡bÄ Ê\u0004ð"), TargetFile));
			IL_B4:
			throw new ZipException(string.Format(c0000c0.m00000f("Åi(DÀ\0_R\u008c\t~Q(ö!\u0015óã\n\u001f\r¡bÄ Ê\u0004ð"), TargetFile));
			IL_CA:
			this.WriteStatus(c0000c0.m00000f("åi(DÀ\0_R\u008c\t~Q(ò5\u000eåö\u001d]\r\u00a0\u007fÁ6Ê\u001e°p\u0098\u008aÂ3\u0019d"), new object[]
			{
				TargetFile
			});
			ZipEntry.ReallyDelete(TargetFile);
			return 0;
		}

		// Token: 0x06000444 RID: 1092 RVA: 0x00018C4C File Offset: 0x00016E4C
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void _CheckRead(int nbytes)
		{
			if (nbytes == 0)
			{
				throw new BadReadException(delegate0101.f000127(c0000c0.m00000f("ó`)DÔ\fRS\u008c\u001d(\fmù9\u0015ï¢\u0015VPä|ß<ÓW½xÕ\u0093ÄxD9\tü­A\u0082]\u0005¡ãþ\u0017"), this.FileName));
			}
		}

		// Token: 0x06000445 RID: 1093 RVA: 0x00018C7C File Offset: 0x00016E7C
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int _ExtractOne(Stream output)
		{
			Stream archiveStream = this.ArchiveStream;
			delegate0149.f00018c(archiveStream, this.FileDataPosition, SeekOrigin.Begin);
			int result = 0;
			byte[] array = new byte[this.BufferSize];
			long num = (this._CompressionMethod_FromZipFile == 8) ? this.UncompressedSize : this._CompressedFileDataSize;
			this._inputDecryptorStream = this.GetExtractDecryptor(archiveStream);
			Stream extractDecompressor = this.GetExtractDecompressor(this._inputDecryptorStream);
			long num2 = 0L;
			CrcCalculatorStream crcCalculatorStream = new CrcCalculatorStream(extractDecompressor);
			while (num > 0L)
			{
				int p = (num > (long)array.Length) ? array.Length : ((int)num);
				int num3 = delegate0144.f000185(crcCalculatorStream, array, 0, p);
				this._CheckRead(num3);
				delegate0109.f000133(output, array, 0, num3);
				num -= (long)num3;
				num2 += (long)num3;
				this.OnExtractProgress(num2, this.UncompressedSize);
				if (this._ioOperationCanceled)
				{
					break;
				}
			}
			result = crcCalculatorStream.Crc;
			return result;
		}

		// Token: 0x06000446 RID: 1094 RVA: 0x00018D80 File Offset: 0x00016F80
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal Stream GetExtractDecompressor(Stream input2)
		{
			return (this._CompressionMethod_FromZipFile == 0) ? input2 : new DeflateStream(input2, CompressionMode.Decompress, true);
		}

		// Token: 0x06000447 RID: 1095 RVA: 0x00018DA8 File Offset: 0x00016FA8
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal Stream GetExtractDecryptor(Stream input)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_8E;
					case 1:
						goto IL_A1;
					case 2:
						goto IL_36;
					case 3:
						if (this._Encryption_FromZipFile == EncryptionAlgorithm.PkzipWeak)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_36;
					}
					break;
					IL_36:
					if (this._Encryption_FromZipFile == EncryptionAlgorithm.WinZipAes128)
					{
						goto IL_A1;
					}
					if (this._Encryption_FromZipFile != EncryptionAlgorithm.WinZipAes256)
					{
						goto IL_BA;
					}
					num = delegate0da.f0000d7(-1);
				}
			}
			IL_8E:
			return new ZipCipherStream(input, this._zipCrypto_forExtract, CryptoMode.Decrypt);
			IL_A1:
			return new WinZipAesCipherStream(input, this._aesCrypto_forExtract, this._CompressedFileDataSize, CryptoMode.Decrypt);
			IL_BA:
			return input;
		}

		// Token: 0x06000448 RID: 1096 RVA: 0x00018E74 File Offset: 0x00017074
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void _SetTimes(string fileOrDirectory, bool isFile)
		{
			if (this._ntfsTimesAreSet)
			{
				if (isFile)
				{
					if (delegate0d2.f0000c1(fileOrDirectory))
					{
						delegate014e.f000194(fileOrDirectory, this._Ctime);
						delegate014e.f000195(fileOrDirectory, this._Atime);
						delegate014e.f000196(fileOrDirectory, this._Mtime);
					}
				}
				else if (Directory.Exists(fileOrDirectory))
				{
					delegate014e.f000197(fileOrDirectory, this._Ctime);
					delegate014e.f000198(fileOrDirectory, this._Atime);
					delegate014e.f000199(fileOrDirectory, this._Mtime);
				}
			}
			else
			{
				DateTime dateTime = SharedUtilities.AdjustTime_Reverse(this.LastModified);
				if (isFile)
				{
					delegate014e.f00019a(fileOrDirectory, dateTime);
				}
				else
				{
					Directory.SetLastWriteTime(fileOrDirectory, dateTime);
				}
			}
		}

		// Token: 0x170000E1 RID: 225
		// (get) Token: 0x06000449 RID: 1097 RVA: 0x00018F38 File Offset: 0x00017138
		private string UnsupportedAlgorithm
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				string result;
				uint unsupportedAlgorithmId;
				for (;;)
				{
					int num = delegate0da.f0000d7(-3);
					for (;;)
					{
						switch (num)
						{
						case 0:
							goto IL_125;
						case 1:
							goto IL_1BA;
						case 2:
							goto IL_36;
						case 3:
							result = string.Empty;
							unsupportedAlgorithmId = this._UnsupportedAlgorithmId;
							if (unsupportedAlgorithmId > 26128U)
							{
								goto IL_125;
							}
							if (unsupportedAlgorithmId <= 26115U)
							{
								if (unsupportedAlgorithmId != 0U)
								{
									switch (unsupportedAlgorithmId)
									{
									case 26113U:
										result = c0000c0.m00000f("ÕD\u001e");
										num = delegate0da.f0000d7(-2);
										continue;
									case 26114U:
										goto IL_3B;
									case 26115U:
										goto IL_4B;
									}
									goto Block_4;
								}
								goto IL_EB;
							}
							else
							{
								if (unsupportedAlgorithmId != 26121U)
								{
									switch (unsupportedAlgorithmId)
									{
									case 26126U:
										goto IL_6B;
									case 26127U:
										result = c0000c0.m00000f("ÁJ\u001a\u0005Ô\f\u0013vé!\u007f\u0015:");
										num = delegate0da.f0000d7(-1);
										continue;
									case 26128U:
										goto IL_1BF;
									}
									goto Block_6;
								}
								goto IL_5B;
							}
							break;
						}
						break;
					}
				}
				IL_36:
				return result;
				IL_3B:
				return c0000c0.m00000f("ÃB\u007f");
				IL_4B:
				return c0000c0.m00000f("¢E\b7\u008bX\u0005\u000f");
				IL_5B:
				return c0000c0.m00000f("¢E\b7\u008bX\u0002\u0005");
				IL_6B:
				return c0000c0.m00000f("ÁJ\u001a\u0005Ô\f\u0013vé!\u007f\u001e0");
				Block_4:
				goto IL_1EF;
				IL_EB:
				return c0000c0.m00000f("¼,");
				Block_6:
				goto IL_1EF;
				IL_125:
				if (unsupportedAlgorithmId <= 26401U)
				{
					if (unsupportedAlgorithmId != 26370U)
					{
						switch (unsupportedAlgorithmId)
						{
						case 26400U:
							result = c0000c0.m00000f("Óm\"\u0013À\0@_");
							break;
						case 26401U:
							result = c0000c0.m00000f("Åv\"\u0002Ï\u001a[");
							break;
						default:
							goto IL_1EF;
						}
					}
					else
					{
						result = c0000c0.m00000f("ÃB\u007f");
					}
				}
				else if (unsupportedAlgorithmId != 26625U)
				{
					if (unsupportedAlgorithmId != 65535U)
					{
						goto IL_1EF;
					}
					goto IL_1EF;
				}
				else
				{
					result = c0000c0.m00000f("ÃBy");
				}
				IL_1BA:
				return result;
				IL_1BF:
				return c0000c0.m00000f("ÁJ\u001a\u0005Ô\f\u0013vé!|\u0019>");
				IL_1EF:
				result = string.Format(c0000c0.m00000f("Äo&\nÉ\u001e]\u0017\u0084B6W8­\u0015Së«"), this._UnsupportedAlgorithmId);
				return result;
			}
		}

		// Token: 0x170000E2 RID: 226
		// (get) Token: 0x0600044A RID: 1098 RVA: 0x00019150 File Offset: 0x00017350
		private string UnsupportedCompressionMethod
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			get
			{
				for (;;)
				{
					switch (delegate0da.f0000d7(-3))
					{
					case 0:
						goto IL_7D;
					case 1:
						goto IL_87;
					case 2:
						goto IL_36;
					case 3:
						goto IL_66;
					}
				}
				IL_36:
				return c0000c0.m00000f("Âi?\rÈ\u0002");
				IL_66:
				string empty = string.Empty;
				int compressionMethod = (int)this._CompressionMethod;
				if (compressionMethod <= 9)
				{
					switch (compressionMethod)
					{
					case 0:
						return c0000c0.m00000f("Âu\"\u0016Ã");
					case 1:
						goto IL_36;
					default:
						switch (compressionMethod)
						{
						case 8:
							return c0000c0.m00000f("ÕD\v(ç=v");
						case 9:
							return c0000c0.m00000f("Õd+\bÇ\u001dV\u0001\u0098");
						}
						goto IL_E9;
					}
				}
				IL_7D:
				if (compressionMethod != 14)
				{
					if (compressionMethod == 19)
					{
						return c0000c0.m00000f("Ý[zS");
					}
					if (compressionMethod == 98)
					{
						return c0000c0.m00000f("ÁQ\0\0");
					}
					goto IL_E9;
				}
				IL_87:
				return c0000c0.m00000f("Ý[\0%");
				IL_E9:
				return string.Format(c0000c0.m00000f("Äo&\nÉ\u001e]\u0017\u0084B6W8­\u0015Së«"), this._CompressionMethod);
			}
		}

		// Token: 0x0600044B RID: 1099 RVA: 0x00019274 File Offset: 0x00017474
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void ValidateEncryption()
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						if (this.Encryption != EncryptionAlgorithm.WinZipAes256 && this.Encryption != EncryptionAlgorithm.None)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						return;
					case 1:
						goto IL_CC;
					case 2:
						goto IL_36;
					case 3:
						if (this.Encryption != EncryptionAlgorithm.PkzipWeak && this.Encryption != EncryptionAlgorithm.WinZipAes128)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						return;
					}
					break;
				}
			}
			IL_36:
			if (this._UnsupportedAlgorithmId != 0U)
			{
				throw new ZipException(delegate0d5.f0000c9(c0000c0.m00000f("Ò`#\nÉ\u001d\u0013RÔ\u0006<MkãwGÓì\u001a\u0014Täa\u009d.\u009e\u001e­7Ý\u008dÕoN:\u0018ýé\0\u0087W\u0019\u00a0µúW\u0082T\u0098\u009fv¥©A~¡Åð\u007f\u0093Ð U\u0082þù|¤)\u0084íj\u001b\\lÐ\u008fÍtnA(\u0099'¿wÅ\u009a"), this.FileName, this.UnsupportedAlgorithm));
			}
			IL_CC:
			throw new ZipException(string.Format(c0000c0.m00000f("Ò`#\nÉ\u001d\u0013RÔ\u0006<MkãwGÓì\u001a\u0014Täa\u009d.\u009e\u0002­rËÃ×s\u0017?\u0002ëøP\u0080Q\u001f¼ðÿ\u0019Ç[\u0097\u008a`§´\\y¢Åÿ|\u0080\u009f!I\u0086æû.ø7Ñ÷PP\u0001\u0001"), this.FileName, (int)this.Encryption));
		}

		// Token: 0x0600044C RID: 1100 RVA: 0x00019374 File Offset: 0x00017574
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void ValidateCompression()
		{
			if (this._CompressionMethod_FromZipFile != 0 && this._CompressionMethod_FromZipFile != 8)
			{
				throw new ZipException(delegate0106.f00012d(c0000c0.m00000f("Ôo9\u0016ßIH\aÑR;_mäm\u0006ø¢\u001b\b^±jÝ<Ì\u0003»s\u0098\u0080ÙpG8\tëþI\u009fPM¥ðïQÍQÔÐ)¯»\u0004,\u0094×ã<Ç\u008ba]Û"), this.FileName, this._CompressionMethod_FromZipFile, this.UnsupportedCompressionMethod));
			}
		}

		// Token: 0x0600044D RID: 1101 RVA: 0x000193CC File Offset: 0x000175CC
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void SetupCryptoForExtract(string password)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_BF;
					case 1:
						goto IL_E4;
					case 2:
						goto IL_63;
					case 3:
						if (this._Encryption_FromZipFile == EncryptionAlgorithm.None)
						{
							return;
						}
						if (this._Encryption_FromZipFile == EncryptionAlgorithm.PkzipWeak)
						{
							goto Block_6;
						}
						if (this._Encryption_FromZipFile == EncryptionAlgorithm.WinZipAes128)
						{
							goto IL_63;
						}
						if (this._Encryption_FromZipFile == EncryptionAlgorithm.WinZipAes256)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						return;
					}
					break;
				}
			}
			IL_63:
			if (password == null)
			{
				throw new ZipException(c0000c0.m00000f("Üh>\u0017Ï\aT\u0017Ü\u0013=_\u007fø?\u0003¸"));
			}
			if (this._aesCrypto_forExtract != null)
			{
				this._aesCrypto_forExtract.Password = password;
				return;
			}
			goto IL_E4;
			Block_6:
			if (password == null)
			{
				throw new ZipException(c0000c0.m00000f("Üh>\u0017Ï\aT\u0017Ü\u0013=_\u007fø?\u0003¸"));
			}
			IL_BF:
			this.ArchiveStream.Seek(this.FileDataPosition - 12L, SeekOrigin.Begin);
			this._zipCrypto_forExtract = ZipCrypto.ForRead(password, this);
			return;
			IL_E4:
			int lengthOfCryptoHeaderBytes = ZipEntry.GetLengthOfCryptoHeaderBytes(this._Encryption_FromZipFile);
			this.ArchiveStream.Seek(this.FileDataPosition - (long)lengthOfCryptoHeaderBytes, SeekOrigin.Begin);
			int keyStrengthInBits = ZipEntry.GetKeyStrengthInBits(this._Encryption_FromZipFile);
			this._aesCrypto_forExtract = WinZipAesCrypto.ReadFromStream(password, keyStrengthInBits, this.ArchiveStream);
		}

		// Token: 0x0600044E RID: 1102 RVA: 0x00019500 File Offset: 0x00017700
		[MethodImpl(MethodImplOptions.NoInlining)]
		private bool ValidateOutput(string basedir, Stream outstream, out string OutputFile)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_EE;
					case 1:
						goto IL_144;
					case 2:
						goto IL_36;
					case 3:
					{
						if (basedir == null)
						{
							goto IL_144;
						}
						string text = this.FileName;
						if (text.StartsWith(c0000c0.m00000f("¾")))
						{
							text = this.FileName.Substring(1);
						}
						if (this._container.ZipFile.FlattenFoldersOnExtract)
						{
							OutputFile = Path.Combine(basedir, (text.IndexOf('/') != -1) ? Path.GetFileName(text) : text);
							num = delegate0da.f0000d7(0);
							continue;
						}
						OutputFile = delegate0d0.f0000bb(basedir, text);
						goto IL_EE;
					}
					}
					break;
					IL_EE:
					if (!this.IsDirectory && !this.FileName.EndsWith(c0000c0.m00000f("¾")))
					{
						return false;
					}
					if (Directory.Exists(OutputFile))
					{
						goto IL_44;
					}
					delegate0d9.f0000d6(OutputFile);
					num = delegate0da.f0000d7(-2);
				}
			}
			IL_36:
			this._SetTimes(OutputFile, false);
			return true;
			IL_44:
			if (this.ExtractExistingFile == ExtractExistingFileAction.OverwriteSilently)
			{
				this._SetTimes(OutputFile, false);
			}
			return true;
			IL_144:
			if (outstream != null)
			{
				OutputFile = null;
				return this.IsDirectory || this.FileName.EndsWith(c0000c0.m00000f("¾"));
			}
			throw new ArgumentException(c0000c0.m00000f("Øo;\u0005Ê\0W\u0017Å\u001c>Y|¹"), c0000c0.m00000f("þt9\u0017Ò\u001bVVÁ"));
		}

		// Token: 0x0600044F RID: 1103 RVA: 0x0001969C File Offset: 0x0001789C
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void ReadExtraField()
		{
			short extraFieldLength;
			long position;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
					{
						byte[] array = new byte[30];
						this.ArchiveStream.Read(array, 0, array.Length);
						int num2 = 26;
						num = delegate0da.f0000d7(-2);
						continue;
					}
					case 1:
						goto IL_105;
					case 2:
					{
						byte[] array;
						int num2;
						short num3 = (short)((int)array[num2++] + (int)array[num2++] * 256);
						extraFieldLength = (short)((int)array[num2++] + (int)array[num2++] * 256);
						this.ArchiveStream.Seek((long)num3, SeekOrigin.Current);
						num = delegate0da.f0000d7(-1);
						continue;
					}
					case 3:
						this._readExtraDepth++;
						position = this.ArchiveStream.Position;
						this.ArchiveStream.Seek(this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_105:
			this.ProcessExtraField(this.ArchiveStream, extraFieldLength);
			this.ArchiveStream.Seek(position, SeekOrigin.Begin);
			this._readExtraDepth--;
		}

		// Token: 0x06000450 RID: 1104 RVA: 0x000197DC File Offset: 0x000179DC
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static bool ReadHeader(ZipEntry p0, Encoding defaultEncoding)
		{
			int num6;
			int num7;
			long p;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					byte[] array;
					int num2;
					long num4;
					int num5;
					switch (num)
					{
					case 0:
						goto IL_3C5;
					case 1:
						p0._CompressedSize = (long)((ulong)((int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256));
						p0._UncompressedSize = (long)((ulong)((int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256));
						p0._LengthOfTrailer += 16;
						goto IL_6D7;
					case 2:
					{
						if (p0._container.ZipFile != null)
						{
							p0._container.ZipFile.OnReadBytes(p0);
						}
						long num3 = SharedUtilities.FindSignature(p0.ArchiveStream, 134695760);
						if (num3 == -1L)
						{
							return false;
						}
						num4 += num3;
						if (p0._InputUsesZip64)
						{
							array = new byte[20];
							num5 = delegate0144.f000185(p0.ArchiveStream, array, 0, array.Length);
							if (num5 != 20)
							{
								return false;
							}
							num2 = 0;
							p0.f00004b = (int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256;
							p0._CompressedSize = delegate0117.f000148(array, num2);
							num2 += 8;
							p0._UncompressedSize = delegate0117.f000148(array, num2);
							num2 += 8;
							p0._LengthOfTrailer += 24;
							goto IL_6D7;
						}
						else
						{
							array = new byte[12];
							num5 = delegate0144.f000185(p0.ArchiveStream, array, 0, array.Length);
							if (num5 != 12)
							{
								return false;
							}
							num2 = 0;
							p0.f00004b = (int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256;
							num = delegate0da.f0000d7(-1);
							continue;
						}
						break;
					}
					case 3:
						num6 = 0;
						p0._RelativeOffsetOfLocalHeader = delegate0e3.f0000e5(p0.ArchiveStream);
						num7 = SharedUtilities.ReadEntrySignature(p0.ArchiveStream);
						num6 += 4;
						if (ZipEntry.IsNotValidSig(num7))
						{
							goto Block_6;
						}
						array = new byte[26];
						num5 = delegate0144.f000185(p0.ArchiveStream, array, 0, array.Length);
						if (num5 != array.Length)
						{
							return false;
						}
						num6 += num5;
						num2 = 0;
						p0._VersionNeeded = (short)((int)array[num2++] + (int)array[num2++] * 256);
						p0._BitField = (short)((int)array[num2++] + (int)array[num2++] * 256);
						p0._CompressionMethod_FromZipFile = (p0._CompressionMethod = (short)((int)array[num2++] + (int)array[num2++] * 256));
						p0._TimeBlob = (int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256;
						p0._LastModified = SharedUtilities.PackedToDateTime(p0._TimeBlob);
						p0._timestamp |= ZipEntryTimestamp.DOS;
						if ((p0._BitField & 1) == 1)
						{
							p0._Encryption_FromZipFile = (p0._Encryption = EncryptionAlgorithm.PkzipWeak);
							p0._sourceIsEncrypted = true;
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_3C5;
					}
					break;
					IL_709:
					bool flag;
					if (!flag)
					{
						goto Block_17;
					}
					int num8;
					num8++;
					num = delegate0da.f0000d7(-2);
					continue;
					IL_6D7:
					flag = (num4 != p0._CompressedSize);
					if (flag)
					{
						delegate0149.f00018c(p0.ArchiveStream, -12L, SeekOrigin.Current);
						num4 += 4L;
					}
					goto IL_709;
					IL_3C5:
					p0.f00004b = (int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256;
					p0._CompressedSize = (long)((ulong)((int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256));
					p0._UncompressedSize = (long)((ulong)((int)array[num2++] + (int)array[num2++] * 256 + (int)array[num2++] * 256 * 256 + (int)array[num2++] * 256 * 256 * 256));
					if ((uint)p0._CompressedSize == 4294967295U || (uint)p0._UncompressedSize == 4294967295U)
					{
						p0._InputUsesZip64 = true;
					}
					short num9 = (short)((int)array[num2++] + (int)array[num2++] * 256);
					short extraFieldLength = (short)((int)array[num2++] + (int)array[num2++] * 256);
					array = new byte[(int)num9];
					num5 = delegate0144.f000185(p0.ArchiveStream, array, 0, array.Length);
					num6 += num5;
					p0._actualEncoding = (((p0._BitField & 2048) == 2048) ? Encoding.UTF8 : defaultEncoding);
					p0._FileNameInArchive = delegate0115.f000145(p0._actualEncoding, array, 0, array.Length);
					if (delegate0141.f000181(p0._FileNameInArchive, c0000c0.m00000f("¾")))
					{
						p0.MarkAsDirectory();
					}
					num6 += p0.ProcessExtraField(p0.ArchiveStream, extraFieldLength);
					p0._LengthOfTrailer = 0;
					if (!delegate0141.f000181(p0._FileNameInArchive, c0000c0.m00000f("¾")) && (p0._BitField & 8) == 8)
					{
						p = delegate0e3.f0000e5(p0.ArchiveStream);
						flag = true;
						num4 = 0L;
						num8 = 0;
						goto IL_709;
					}
					goto IL_724;
				}
			}
			return false;
			Block_6:
			delegate0149.f00018c(p0.ArchiveStream, -4L, SeekOrigin.Current);
			if (ZipEntry.IsNotValidZipDirEntrySig(num7) && (long)num7 != 101010256L)
			{
				throw new BadReadException(delegate0d5.f0000c9(c0000c0.m00000f("±!\u0017\rÖ,]CÞ\vt\u0016Zò,\u0003Þç\u000f\u0002H¶2\u0084i\u009e5¿s\u0098\u0090ßzY+\u0018íÿEÐ\u0016]°î«\u0003ú\r\u0089Ñ9¶´\u0015f£\u0096÷d\u008e\u009f=\0Ò¾îuáv¸õu"), num7, delegate0e3.f0000e5(p0.ArchiveStream)));
			}
			return false;
			Block_17:
			delegate0149.f00018c(p0.ArchiveStream, p, SeekOrigin.Begin);
			IL_724:
			p0._CompressedFileDataSize = p0._CompressedSize;
			if ((p0._BitField & 1) == 1)
			{
				if (p0.Encryption == EncryptionAlgorithm.WinZipAes128 || p0.Encryption == EncryptionAlgorithm.WinZipAes256)
				{
					int keyStrengthInBits = ZipEntry.GetKeyStrengthInBits(p0._Encryption_FromZipFile);
					p0._aesCrypto_forExtract = WinZipAesCrypto.ReadFromStream(null, keyStrengthInBits, p0.ArchiveStream);
					num6 += p0._aesCrypto_forExtract.SizeOfEncryptionMetadata - 10;
					p0._CompressedFileDataSize -= (long)p0._aesCrypto_forExtract.SizeOfEncryptionMetadata;
					p0._LengthOfTrailer += 10;
				}
				else
				{
					p0._WeakEncryptionHeader = new byte[12];
					num6 += ZipEntry.ReadWeakEncryptionHeader(p0._archiveStream, p0._WeakEncryptionHeader);
					p0._CompressedFileDataSize -= 12L;
				}
			}
			p0._LengthOfHeader = num6;
			p0._TotalEntrySize = (long)p0._LengthOfHeader + p0._CompressedFileDataSize + (long)p0._LengthOfTrailer;
			return true;
		}

		// Token: 0x06000451 RID: 1105 RVA: 0x00019FF8 File Offset: 0x000181F8
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static int ReadWeakEncryptionHeader(Stream p0, byte[] buffer)
		{
			int num = delegate0144.f000185(p0, buffer, 0, 12);
			if (num != 12)
			{
				throw new ZipException(delegate0101.f000127(c0000c0.m00000f("Äo(\u001cÖ\fPCÉ\u0016nIfóm\bð¢\n\aY¥:Ì'\u009e\a±dÑ\u0097ßrYj\\àö\u0010ÊfUµ"), delegate0e3.f0000e5(p0)));
			}
			return num;
		}

		// Token: 0x06000452 RID: 1106 RVA: 0x0001A04C File Offset: 0x0001824C
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static bool IsNotValidSig(int signature)
		{
			return signature != 67324752;
		}

		// Token: 0x06000453 RID: 1107 RVA: 0x0001A064 File Offset: 0x00018264
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static ZipEntry ReadEntry(ZipContainer p0, bool first)
		{
			ZipEntry zipEntry;
			ZipFile zipFile;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					Stream readStream;
					Encoding provisionalAlternateEncoding;
					switch (num)
					{
					case 0:
						zipEntry._container = p0;
						zipEntry._archiveStream = readStream;
						if (zipFile != null)
						{
							zipFile.OnReadEntry(true, null);
						}
						if (first)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_3C;
					case 1:
						goto IL_107;
					case 2:
						ZipEntry.HandlePK00Prefix(readStream);
						goto IL_3C;
					case 3:
						zipFile = p0.ZipFile;
						readStream = p0.ReadStream;
						provisionalAlternateEncoding = p0.ProvisionalAlternateEncoding;
						zipEntry = new ZipEntry();
						zipEntry._Source = ZipEntrySource.ZipFile;
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
					IL_3C:
					if (!ZipEntry.ReadHeader(zipEntry, provisionalAlternateEncoding))
					{
						goto Block_1;
					}
					zipEntry.__FileDataPosition = delegate0e3.f0000e5(zipEntry.ArchiveStream);
					delegate0149.f00018c(readStream, zipEntry._CompressedFileDataSize + (long)zipEntry._LengthOfTrailer, SeekOrigin.Current);
					num = delegate0da.f0000d7(-1);
				}
			}
			Block_1:
			return null;
			IL_107:
			ZipEntry.HandleUnexpectedDataDescriptor(zipEntry);
			if (zipFile != null)
			{
				zipFile.OnReadBytes(zipEntry);
				zipFile.OnReadEntry(false, zipEntry);
			}
			return zipEntry;
		}

		// Token: 0x06000454 RID: 1108 RVA: 0x0001A194 File Offset: 0x00018394
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static void HandlePK00Prefix(Stream p0)
		{
			uint num = (uint)SharedUtilities.ReadInt(p0);
			if (num != 808471376U)
			{
				delegate0149.f00018c(p0, -4L, SeekOrigin.Current);
			}
		}

		// Token: 0x06000455 RID: 1109 RVA: 0x0001A1C8 File Offset: 0x000183C8
		[MethodImpl(MethodImplOptions.NoInlining)]
		private static void HandleUnexpectedDataDescriptor(ZipEntry entry)
		{
			Stream archiveStream;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
					{
						int num2 = SharedUtilities.ReadInt(archiveStream);
						if ((long)num2 == entry._CompressedSize)
						{
							num2 = SharedUtilities.ReadInt(archiveStream);
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_CF;
					}
					case 1:
						return;
					case 2:
					{
						int num2;
						if ((long)num2 == entry._UncompressedSize)
						{
							return;
						}
						archiveStream.Seek(-12L, SeekOrigin.Current);
						num = delegate0da.f0000d7(-1);
						continue;
					}
					case 3:
					{
						archiveStream = entry.ArchiveStream;
						uint num3 = (uint)SharedUtilities.ReadInt(archiveStream);
						if ((ulong)num3 == (ulong)((long)entry.f00004b))
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_DB;
					}
					}
					break;
				}
			}
			return;
			IL_CF:
			archiveStream.Seek(-8L, SeekOrigin.Current);
			return;
			IL_DB:
			archiveStream.Seek(-4L, SeekOrigin.Current);
		}

		// Token: 0x06000456 RID: 1110 RVA: 0x0001A2BC File Offset: 0x000184BC
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal int ProcessExtraField(Stream p0, short extraFieldLength)
		{
			int num6;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					byte[] array;
					int num3;
					short num2;
					ushort num5;
					long posn;
					switch (num)
					{
					case 0:
					{
						num2 = (short)((int)array[num3 + 2] + (int)array[num3 + 3] * 256);
						num3 += 4;
						ushort num4 = num5;
						if (num4 <= 21589)
						{
							if (num4 <= 10)
							{
								if (num4 == 1)
								{
									num3 = this.ProcessExtraFieldZip64(array, num3, num2, posn);
									goto IL_1EA;
								}
								if (num4 != 10)
								{
									goto IL_1EA;
								}
								num3 = this.ProcessExtraFieldWindowsTimes(array, num3, num2, posn);
								goto IL_1EA;
							}
							else
							{
								if (num4 == 23)
								{
									num3 = this.ProcessExtraFieldPkwareStrongEncryption(array, num3);
									goto IL_1EA;
								}
								if (num4 != 21589)
								{
									num = delegate0da.f0000d7(-2);
									continue;
								}
								goto IL_193;
							}
						}
						else if (num4 <= 30805)
						{
							if (num4 == 22613)
							{
								num3 = this.ProcessExtraFieldInfoZipTimes(array, num3, num2, posn);
								goto IL_1EA;
							}
							if (num4 != 30805)
							{
								goto IL_1EA;
							}
							goto IL_1EA;
						}
						else
						{
							if (num4 == 30837)
							{
								goto IL_1EA;
							}
							if (num4 != 39169)
							{
								goto IL_1EA;
							}
							num3 = this.ProcessExtraFieldWinZipAes(array, num3, num2, posn);
							goto IL_1EA;
						}
						break;
					}
					case 1:
						goto IL_193;
					case 2:
						goto IL_1EA;
					case 3:
						num6 = 0;
						if (extraFieldLength > 0)
						{
							array = (this._Extra = new byte[(int)extraFieldLength]);
							num6 = delegate0144.f000185(p0, array, 0, array.Length);
							posn = delegate0e3.f0000e5(p0) - (long)num6;
							num3 = 0;
							goto IL_1F3;
						}
						return num6;
					}
					break;
					IL_1F3:
					if (num3 + 3 >= array.Length)
					{
						return num6;
					}
					int num7 = num3;
					num5 = (ushort)((int)array[num3] + (int)array[num3 + 1] * 256);
					num = delegate0da.f0000d7(0);
					continue;
					IL_1EA:
					num3 = num7 + (int)num2 + 4;
					goto IL_1F3;
					IL_193:
					num3 = this.ProcessExtraFieldUnixTimes(array, num3, num2, posn);
					goto IL_1EA;
				}
			}
			return num6;
		}

		// Token: 0x06000457 RID: 1111 RVA: 0x0001A4CC File Offset: 0x000186CC
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int ProcessExtraFieldPkwareStrongEncryption(byte[] Buffer, int p1)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						this._UnsupportedAlgorithmId = (uint)((ushort)((int)Buffer[p1] + (int)Buffer[p1 + 1] * 256));
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_9E;
					case 2:
						p1 += 2;
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
						p1 += 2;
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_9E:
			this._Encryption_FromZipFile = (this._Encryption = EncryptionAlgorithm.Unsupported);
			return p1;
		}

		// Token: 0x06000458 RID: 1112 RVA: 0x0001A588 File Offset: 0x00018788
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int ProcessExtraFieldWinZipAes(byte[] Buffer, int p1, short DataSize, long posn)
		{
			short num2;
			int num3;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_10D;
					case 1:
						goto IL_18C;
					case 2:
						p1 += 2;
						if (num2 != 17729)
						{
							goto Block_1;
						}
						num3 = -1;
						if (Buffer[p1] == 1)
						{
							num3 = 128;
							num = delegate0da.f0000d7(-1);
							continue;
						}
						goto IL_18C;
					case 3:
						if (this._CompressionMethod != 99)
						{
							return p1;
						}
						if ((this._BitField & 1) != 1)
						{
							goto Block_4;
						}
						this._sourceIsEncrypted = true;
						if (DataSize != 7)
						{
							goto Block_5;
						}
						goto IL_10D;
					}
					break;
					IL_10D:
					this._WinZipAesMethod = delegate014f.f00019b(Buffer, p1);
					p1 += 2;
					if (this._WinZipAesMethod != 1 && this._WinZipAesMethod != 2)
					{
						goto Block_7;
					}
					num2 = BitConverter.ToInt16(Buffer, p1);
					num = delegate0da.f0000d7(-2);
				}
			}
			Block_1:
			throw new BadReadException(delegate0d5.f0000c9(c0000c0.m00000f("±!\u0018\nÃ\u0011CRÏ\u0006+H(á(\tòí\u001cFd\u0080:\u0085cÆ\fî-à×Ë4\u0017,\u0003ê­w\u0099P7¡å»xçfÔ\u0095|£¡Qw¸\u0084¾q\u0093Ð#O\u0081çâg¿\"Àýp\u0019M\u0012çÊµl"), num2, posn));
			Block_4:
			throw new BadReadException(delegate0101.f000127(c0000c0.m00000f("±!\u0004\nÅ\u0006]DÅ\u0001:Ifãm\nóö\u000f\u0002L°{\u008d2ÊW®xË\u008aÂtX$L¨õ[À\u00045ù£æ"), posn));
			Block_5:
			throw new BadReadException(delegate0d5.f0000c9(c0000c0.m00000f("±!\u0004\nÅ\u0006]DÅ\u0001:Ifãm0ÿì4\u000f]ä[è\0\u009e\u0013¿cÙ\u0090ßgRjD¨õ[À\u00045üè²\u0019ÃAÔ\u0088v¤©A\u007f£\u008b¾ \u009f\u008bb\u001aª¿\u00a0s"), DataSize, posn));
			Block_7:
			throw new BadReadException(delegate0d5.f0000c9(c0000c0.m00000f("±!\u0018\nÃ\u0011CRÏ\u0006+H(á(\tòí\u001cF[¡hÞ:Ñ\u0019þyÍ\u008eÔxEjD¨õ[À\u00045üè²\u0019ÄZ\u0086ØN¾®o\u007f¼ÅßU´Ð>E\u0086ïòo¤-À¬|B\fGÌ\u0092÷xuuaÙeä=Î¿\u0010Kø"), this._WinZipAesMethod, posn));
			IL_18C:
			if (Buffer[p1] == 3)
			{
				num3 = 256;
			}
			if (num3 < 0)
			{
				throw new BadReadException(delegate0101.f000127(c0000c0.m00000f("Øo;\u0005Ê\0W\u0017Ç\u00177\f{ã?\u0002øå\u001a\u000e\rìa\u009d.\u0097"), num3));
			}
			this._Encryption_FromZipFile = (this._Encryption = ((num3 == 128) ? EncryptionAlgorithm.WinZipAes128 : EncryptionAlgorithm.WinZipAes256));
			p1++;
			this._CompressionMethod_FromZipFile = (this._CompressionMethod = delegate014f.f00019b(Buffer, p1));
			p1 += 2;
			return p1;
		}

		// Token: 0x06000459 RID: 1113 RVA: 0x0001A7A0 File Offset: 0x000189A0
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int ProcessExtraFieldZip64(byte[] Buffer, int p1, short DataSize, long posn)
		{
			int num2;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						if (num2 < 8)
						{
							goto Block_5;
						}
						this._UncompressedSize = delegate0117.f000148(Buffer, p1);
						p1 += 8;
						num2 -= 8;
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_152;
					case 2:
						goto IL_36;
					case 3:
						this._InputUsesZip64 = true;
						if (DataSize > 28)
						{
							goto Block_3;
						}
						num2 = (int)DataSize;
						if (this._UncompressedSize == (long)((ulong)-1))
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_36;
					}
					break;
					IL_36:
					if (this._CompressedSize != (long)((ulong)-1))
					{
						goto IL_156;
					}
					if (num2 < 8)
					{
						goto Block_2;
					}
					this._CompressedSize = delegate0117.f000148(Buffer, p1);
					p1 += 8;
					num = delegate0da.f0000d7(-1);
				}
			}
			Block_2:
			throw new BadReadException(delegate0101.f000127(c0000c0.m00000f("±!\0\rÕ\u001aZYËR*M|öm\u0001ùðN<d\u0094,\u0099sÛ\u000fªeÙÃÐtR&\b¸¥c\u009fS\u001dºðèJÇQÔ«p­¥\u001c6­\u0091¾`\u0088\u0083:T\u009báø.à4\u009bü2:M\u001eÂ"), posn));
			Block_3:
			throw new BadReadException(delegate0d5.f0000c9(c0000c0.m00000f("±!\u0004\nÅ\u0006]DÅ\u0001:Ifãm\u0003÷ö\u000f\u0015D¾\u007f\u008d{\u008e\u000f¥'\u0082»\u0082`\u001ej\n÷ÿ\0ªw=þ¡»\\ÚA\u0086\u00999±©Pz¨ÅÿdÇ\u0080<S\u009búÿa¾lÐµsSFp\u008eÍþ"), DataSize, posn));
			Block_5:
			throw new BadReadException(delegate0101.f000127(c0000c0.m00000f("±!\0\rÕ\u001aZYËR*M|öm\u0001ùðN<d\u0094,\u0099sÛ\u000fªeÙÃÐtR&\b¸¥u\u009e]\u0002¥åé\\ÑF\u0091\u009c9\u0084©OsåÅÿdÇ\u0080<S\u009búÿa¾lÐµsSFp\u008eÍþ"), posn));
			IL_152:
			num2 -= 8;
			IL_156:
			if (this._RelativeOffsetOfLocalHeader == (long)((ulong)-1))
			{
				if (num2 < 8)
				{
					throw new BadReadException(delegate0101.f000127(c0000c0.m00000f("±!\0\rÕ\u001aZYËR*M|öm\u0001ùðN<d\u0094,\u0099sÛ\u000fªeÙÃÐtR&\b¸¥r\u0095R\f¼üí\\\u0082z\u0092\u009ej²´\u001c6­\u0091¾`\u0088\u0083:T\u009báø.à4\u009bü2:M\u001eÂ"), posn));
				}
				this._RelativeOffsetOfLocalHeader = delegate0117.f000148(Buffer, p1);
				p1 += 8;
				num2 -= 8;
			}
			return p1;
		}

		// Token: 0x0600045A RID: 1114 RVA: 0x0001A954 File Offset: 0x00018B54
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int ProcessExtraFieldInfoZipTimes(byte[] Buffer, int p1, short DataSize, long posn)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					int num2;
					switch (num)
					{
					case 0:
						goto IL_A7;
					case 1:
						goto IL_DE;
					case 2:
						num2 = BitConverter.ToInt32(Buffer, p1);
						this._Atime = ZipEntry._unixEpoch.AddSeconds((double)num2);
						p1 += 4;
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
						if (DataSize != 12 && DataSize != 8)
						{
							goto Block_2;
						}
						goto IL_A7;
					}
					break;
					IL_A7:
					num2 = BitConverter.ToInt32(Buffer, p1);
					this._Mtime = ZipEntry._unixEpoch.AddSeconds((double)num2);
					p1 += 4;
					num = delegate0da.f0000d7(-2);
				}
			}
			Block_2:
			throw new BadReadException(delegate0d5.f0000c9(c0000c0.m00000f("±!\u0018\nÃ\u0011CRÏ\u0006+H(ó,\u0013÷ñ\a\u001cHä2\u009d+ÅGäO\u008c\u009e\u009f=Q%\u001e¸ÄN\u0096Q7¡å»O\u0093\u0015\u0091\u0080m¥¡\u0015p¥\u0080òtÇ\u0091'\0\u0082áåg¤%\u008f£(R\u0004S\u008eÁÛ ,f"), DataSize, posn));
			IL_DE:
			this._Ctime = delegate0cf.f0000b9();
			this._ntfsTimesAreSet = true;
			this._timestamp |= ZipEntryTimestamp.InfoZip1;
			return p1;
		}

		// Token: 0x0600045B RID: 1115 RVA: 0x0001AA68 File Offset: 0x00018C68
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int ProcessExtraFieldUnixTimes(byte[] Buffer, int p1, short DataSize, long posn)
		{
			int num2;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					byte b;
					switch (num)
					{
					case 0:
						if ((b & 1) != 0 && num2 >= 4)
						{
							int num3 = delegate0150.f00019c(Buffer, p1);
							this._Mtime = ZipEntry._unixEpoch.AddSeconds((double)num3);
							p1 += 4;
							num2 -= 4;
						}
						if ((b & 2) != 0 && num2 >= 4)
						{
							int num4 = delegate0150.f00019c(Buffer, p1);
							num = delegate0da.f0000d7(-2);
							continue;
						}
						this._Atime = delegate0cf.f0000b9();
						goto IL_66;
					case 1:
						goto IL_1A0;
					case 2:
					{
						int num4;
						this._Atime = ZipEntry._unixEpoch.AddSeconds((double)num4);
						p1 += 4;
						num2 -= 4;
						goto IL_66;
					}
					case 3:
						if (DataSize != 13 && DataSize != 9 && DataSize != 5)
						{
							goto Block_5;
						}
						num2 = (int)DataSize;
						if (DataSize == 13 || this._readExtraDepth > 0)
						{
							b = Buffer[p1++];
							num2--;
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_1DF;
					}
					break;
					IL_66:
					if ((b & 4) == 0 || num2 < 4)
					{
						goto IL_1AE;
					}
					int num5 = delegate0150.f00019c(Buffer, p1);
					this._Ctime = ZipEntry._unixEpoch.AddSeconds((double)num5);
					num = delegate0da.f0000d7(-1);
				}
			}
			Block_5:
			throw new BadReadException(delegate0d5.f0000c9(c0000c0.m00000f("±!\u0018\nÃ\u0011CRÏ\u0006+H(ó,\u0013÷ñ\a\u001cHä2\u009d+ÅGäO\u008c\u009e\u009f=Q%\u001e¸ÈX\u0084[\u0003¬ðÿ\u0019ö\\\u0099\u009dj£¡Xfì\u0080æd\u0095\u0091sF\u009bëújð-\u0094íx\r\u000fAË\u0092ì\u007f:+9\u0092,¥TÅÑ\\"), DataSize, posn));
			IL_1A0:
			p1 += 4;
			num2 -= 4;
			goto IL_1BE;
			IL_1AE:
			this._Ctime = delegate0cf.f0000b9();
			IL_1BE:
			this._timestamp |= ZipEntryTimestamp.Unix;
			this._ntfsTimesAreSet = true;
			this._emitUnixTimes = true;
			return p1;
			IL_1DF:
			this.ReadExtraField();
			return p1;
		}

		// Token: 0x0600045C RID: 1116 RVA: 0x0001AC5C File Offset: 0x00018E5C
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int ProcessExtraFieldWindowsTimes(byte[] Buffer, int p1, short DataSize, long posn)
		{
			long p2;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
					{
						p1 += 4;
						short num2;
						short num3;
						if (num2 == 1 && num3 == 24)
						{
							p2 = delegate0117.f000148(Buffer, p1);
							this._Mtime = delegate0151.f00019d(p2);
							num = delegate0da.f0000d7(-2);
							continue;
						}
						return p1;
					}
					case 1:
						goto IL_13F;
					case 2:
						p1 += 8;
						p2 = delegate0117.f000148(Buffer, p1);
						this._Atime = delegate0151.f00019d(p2);
						p1 += 8;
						p2 = delegate0117.f000148(Buffer, p1);
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
					{
						if (DataSize != 32)
						{
							goto Block_1;
						}
						p1 += 4;
						short num2 = (short)((int)Buffer[p1] + (int)Buffer[p1 + 1] * 256);
						short num3 = (short)((int)Buffer[p1 + 2] + (int)Buffer[p1 + 3] * 256);
						num = delegate0da.f0000d7(0);
						continue;
					}
					}
					break;
				}
			}
			Block_1:
			throw new BadReadException(delegate0d5.f0000c9(c0000c0.m00000f("±!\u0018\nÃ\u0011CRÏ\u0006+H(ó,\u0013÷ñ\a\u001cHä2\u009d+ÅGäO\u008c\u009e\u009f=Q%\u001e¸Ãt¶mM¼üö\\Ñ\u0015\u0091\u0080m¥¡\u0015p¥\u0080òtÇ\u0091'\0\u0082áåg¤%\u008f£(R\u0004S\u008eÁÛ ,f"), DataSize, posn));
			IL_13F:
			this._Ctime = delegate0151.f00019d(p2);
			p1 += 8;
			this._ntfsTimesAreSet = true;
			this._timestamp |= ZipEntryTimestamp.Windows;
			this._emitNtfsTimes = true;
			return p1;
		}

		// Token: 0x0600045D RID: 1117 RVA: 0x0001ADDC File Offset: 0x00018FDC
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void WriteCentralDirectoryEntry(Stream p0)
		{
			this._ConsAndWriteCentralDirectoryEntry(p0);
		}

		// Token: 0x0600045E RID: 1118 RVA: 0x0001ADF0 File Offset: 0x00018FF0
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void _ConsAndWriteCentralDirectoryEntry(Stream p0)
		{
			byte[] array;
			int num2;
			int i;
			byte[] array2;
			short num3;
			short num4;
			int num5;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						array[num2++] = (byte)(this.f00004b & 255);
						array[num2++] = (byte)((this.f00004b & 65280) >> 8);
						array[num2++] = (byte)((this.f00004b & 16711680) >> 16);
						array[num2++] = (byte)(((long)this.f00004b & (long)((ulong)-16777216)) >> 24);
						if (this._OutputUsesZip64.Value)
						{
							for (i = 0; i < 8; i++)
							{
								array[num2++] = byte.MaxValue;
							}
						}
						else
						{
							array[num2++] = (byte)(this._CompressedSize & 255L);
							array[num2++] = (byte)((this._CompressedSize & 65280L) >> 8);
							array[num2++] = (byte)((this._CompressedSize & 16711680L) >> 16);
							array[num2++] = (byte)((this._CompressedSize & (long)((ulong)-16777216)) >> 24);
							array[num2++] = (byte)(this._UncompressedSize & 255L);
							array[num2++] = (byte)((this._UncompressedSize & 65280L) >> 8);
							array[num2++] = (byte)((this._UncompressedSize & 16711680L) >> 16);
							array[num2++] = (byte)((this._UncompressedSize & (long)((ulong)-16777216)) >> 24);
						}
						array2 = this._GetEncodedFileNameBytes();
						num3 = (short)array2.Length;
						array[num2++] = (byte)(num3 & 255);
						array[num2++] = (byte)(((int)num3 & 65280) >> 8);
						this._presumeZip64 = this._OutputUsesZip64.Value;
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_4EB;
					case 2:
						this._Extra = this.ConstructExtraField(true);
						num4 = (short)((this._Extra == null) ? 0 : this._Extra.Length);
						array[num2++] = (byte)(num4 & 255);
						array[num2++] = (byte)(((int)num4 & 65280) >> 8);
						num5 = ((this._CommentBytes == null) ? 0 : this._CommentBytes.Length);
						if (num5 + num2 > array.Length)
						{
							num5 = array.Length - num2;
						}
						array[num2++] = (byte)(num5 & 255);
						array[num2++] = (byte)((num5 & 65280) >> 8);
						array[num2++] = (byte)(this._diskNumber & 255U);
						array[num2++] = (byte)((this._diskNumber & 65280U) >> 8);
						array[num2++] = (this._IsText ? 1 : 0);
						array[num2++] = 0;
						array[num2++] = (byte)(this._ExternalFileAttrs & 255);
						array[num2++] = (byte)((this._ExternalFileAttrs & 65280) >> 8);
						array[num2++] = (byte)((this._ExternalFileAttrs & 16711680) >> 16);
						array[num2++] = (byte)(((long)this._ExternalFileAttrs & (long)((ulong)-16777216)) >> 24);
						if (this._OutputUsesZip64.Value)
						{
							for (i = 0; i < 4; i++)
							{
								array[num2++] = byte.MaxValue;
							}
							num = delegate0da.f0000d7(-1);
							continue;
						}
						goto IL_4F0;
					case 3:
					{
						array = new byte[4096];
						num2 = 0;
						array[num2++] = 80;
						array[num2++] = 75;
						array[num2++] = 1;
						array[num2++] = 2;
						array[num2++] = (byte)(this._VersionMadeBy & 255);
						array[num2++] = (byte)(((int)this._VersionMadeBy & 65280) >> 8);
						short num6 = this._OutputUsesZip64.Value ? 45 : 20;
						array[num2++] = (byte)(num6 & 255);
						array[num2++] = (byte)(((int)num6 & 65280) >> 8);
						array[num2++] = (byte)(this._BitField & 255);
						array[num2++] = (byte)(((int)this._BitField & 65280) >> 8);
						array[num2++] = (byte)(this._CompressionMethod & 255);
						array[num2++] = (byte)(((int)this._CompressionMethod & 65280) >> 8);
						if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
						{
							num2 -= 2;
							array[num2++] = 99;
							array[num2++] = 0;
						}
						array[num2++] = (byte)(this._TimeBlob & 255);
						array[num2++] = (byte)((this._TimeBlob & 65280) >> 8);
						array[num2++] = (byte)((this._TimeBlob & 16711680) >> 16);
						array[num2++] = (byte)(((long)this._TimeBlob & (long)((ulong)-16777216)) >> 24);
						num = delegate0da.f0000d7(0);
						continue;
					}
					}
					break;
				}
			}
			IL_4EB:
			goto IL_54C;
			IL_4F0:
			array[num2++] = (byte)(this._RelativeOffsetOfLocalHeader & 255L);
			array[num2++] = (byte)((this._RelativeOffsetOfLocalHeader & 65280L) >> 8);
			array[num2++] = (byte)((this._RelativeOffsetOfLocalHeader & 16711680L) >> 16);
			array[num2++] = (byte)((this._RelativeOffsetOfLocalHeader & (long)((ulong)-16777216)) >> 24);
			IL_54C:
			for (i = 0; i < (int)num3; i++)
			{
				array[num2 + i] = array2[i];
			}
			num2 += i;
			if (this._Extra != null)
			{
				for (i = 0; i < (int)num4; i++)
				{
					array[num2 + i] = this._Extra[i];
				}
				num2 += i;
			}
			if (num5 != 0)
			{
				i = 0;
				while (i < num5 && num2 + i < array.Length)
				{
					array[num2 + i] = this._CommentBytes[i];
					i++;
				}
				num2 += i;
			}
			p0.Write(array, 0, num2);
		}

		// Token: 0x0600045F RID: 1119 RVA: 0x0001B3E0 File Offset: 0x000195E0
		[MethodImpl(MethodImplOptions.NoInlining)]
		private byte[] ConstructExtraField(bool forCentralDirectory)
		{
			byte[] array;
			List<byte[]> list;
			int num6;
			TimeSpan timeSpan;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_2F8;
					case 1:
						goto IL_42D;
					case 2:
					{
						int num2;
						num2 += 4;
						array[num2++] = 1;
						array[num2++] = 0;
						array[num2++] = 24;
						array[num2++] = 0;
						long p = this._Mtime.ToFileTime();
						delegate0fe.f000121(delegate0152.f00019e(p), 0, array, num2, 8);
						num2 += 8;
						p = this._Atime.ToFileTime();
						delegate0fe.f000121(delegate0152.f00019e(p), 0, array, num2, 8);
						num2 += 8;
						p = this._Ctime.ToFileTime();
						delegate0fe.f000121(delegate0152.f00019e(p), 0, array, num2, 8);
						num2 += 8;
						list.Add(array);
						goto IL_F6;
					}
					case 3:
						list = new List<byte[]>();
						if (this._container.Zip64 == Zip64Option.Always || (this._container.Zip64 == Zip64Option.AsNecessary && (!forCentralDirectory || this._entryRequiresZip64.Value)))
						{
							int num3 = 4 + (forCentralDirectory ? 28 : 16);
							array = new byte[num3];
							int num4 = 0;
							if (this._presumeZip64 || forCentralDirectory)
							{
								array[num4++] = 1;
								array[num4++] = 0;
							}
							else
							{
								array[num4++] = 153;
								array[num4++] = 153;
							}
							array[num4++] = (byte)(num3 - 4);
							array[num4++] = 0;
							delegate0fe.f000121(delegate0152.f00019e(this._UncompressedSize), 0, array, num4, 8);
							num4 += 8;
							delegate0fe.f000121(delegate0152.f00019e(this._CompressedSize), 0, array, num4, 8);
							if (forCentralDirectory)
							{
								num4 += 8;
								delegate0fe.f000121(delegate0152.f00019e(this._RelativeOffsetOfLocalHeader), 0, array, num4, 8);
								num4 += 8;
								delegate0fe.f000121(delegate0136.f000173(0), 0, array, num4, 4);
							}
							list.Add(array);
						}
						if (this.Encryption == EncryptionAlgorithm.WinZipAes128)
						{
							goto IL_2F8;
						}
						if (this.Encryption == EncryptionAlgorithm.WinZipAes256)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_3CA;
					}
					break;
					IL_F6:
					if (this._ntfsTimesAreSet && this._emitUnixTimes)
					{
						int num5 = 9;
						if (!forCentralDirectory)
						{
							num5 += 8;
						}
						array = new byte[num5];
						num6 = 0;
						array[num6++] = 85;
						array[num6++] = 84;
						array[num6++] = (byte)(num5 - 4);
						array[num6++] = 0;
						array[num6++] = 7;
						timeSpan = delegate0153.f00019f(this._Mtime, ZipEntry._unixEpoch);
						num = delegate0da.f0000d7(-1);
						continue;
					}
					goto IL_4E9;
					IL_3CA:
					if (this._ntfsTimesAreSet && this._emitNtfsTimes)
					{
						array = new byte[36];
						int num2 = 0;
						array[num2++] = 10;
						array[num2++] = 0;
						array[num2++] = 32;
						array[num2++] = 0;
						num = delegate0da.f0000d7(-2);
						continue;
					}
					goto IL_F6;
					IL_2F8:
					array = new byte[11];
					int num7 = 0;
					array[num7++] = 1;
					array[num7++] = 153;
					array[num7++] = 7;
					array[num7++] = 0;
					array[num7++] = 1;
					array[num7++] = 0;
					array[num7++] = 65;
					array[num7++] = 69;
					array[num7] = byte.MaxValue;
					int keyStrengthInBits = ZipEntry.GetKeyStrengthInBits(this.Encryption);
					if (keyStrengthInBits == 128)
					{
						array[num7] = 1;
					}
					if (keyStrengthInBits == 256)
					{
						array[num7] = 3;
					}
					num7++;
					array[num7++] = (byte)(this._CompressionMethod & 255);
					array[num7++] = (byte)((int)this._CompressionMethod & 65280);
					list.Add(array);
					goto IL_3CA;
				}
			}
			IL_42D:
			int p2 = (int)timeSpan.TotalSeconds;
			delegate0fe.f000121(delegate0136.f000173(p2), 0, array, num6, 4);
			num6 += 4;
			if (!forCentralDirectory)
			{
				p2 = (int)delegate0153.f00019f(this._Atime, ZipEntry._unixEpoch).TotalSeconds;
				delegate0fe.f000121(delegate0136.f000173(p2), 0, array, num6, 4);
				num6 += 4;
				p2 = (int)delegate0153.f00019f(this._Ctime, ZipEntry._unixEpoch).TotalSeconds;
				delegate0fe.f000121(delegate0136.f000173(p2), 0, array, num6, 4);
				num6 += 4;
			}
			list.Add(array);
			IL_4E9:
			byte[] array2 = null;
			if (list.Count > 0)
			{
				int num8 = 0;
				int num9 = 0;
				for (int i = 0; i < list.Count; i++)
				{
					num8 += list[i].Length;
				}
				array2 = new byte[num8];
				for (int i = 0; i < list.Count; i++)
				{
					delegate0fe.f000121(list[i], 0, array2, num9, list[i].Length);
					num9 += list[i].Length;
				}
			}
			return array2;
		}

		// Token: 0x06000460 RID: 1120 RVA: 0x0001B970 File Offset: 0x00019B70
		[MethodImpl(MethodImplOptions.NoInlining)]
		private Encoding GenerateCommentBytes()
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
					{
						string @string = ZipEntry.ibm437.GetString(this._CommentBytes, 0, this._CommentBytes.Length);
						num = delegate0da.f0000d7(-2);
						continue;
					}
					case 1:
						goto IL_C4;
					case 2:
					{
						string @string;
						if (@string == this._Comment)
						{
							num = delegate0da.f0000d7(-1);
							continue;
						}
						goto IL_CA;
					}
					case 3:
						this._CommentBytes = delegate0d7.f0000d2(ZipEntry.ibm437, this._Comment);
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_C4:
			return ZipEntry.ibm437;
			IL_CA:
			this._CommentBytes = this._provisionalAlternateEncoding.GetBytes(this._Comment);
			return this._provisionalAlternateEncoding;
		}

		// Token: 0x06000461 RID: 1121 RVA: 0x0001BA64 File Offset: 0x00019C64
		[MethodImpl(MethodImplOptions.NoInlining)]
		private byte[] _GetEncodedFileNameBytes()
		{
			string text;
			string text2;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						if (text[1] == '/')
						{
							goto Block_9;
						}
						goto IL_185;
					case 1:
						goto IL_1D4;
					case 2:
						goto IL_36;
					case 3:
						text = this.FileName.Replace(c0000c0.m00000f("Í"), c0000c0.m00000f("¾"));
						text2 = null;
						if (this._TrimVolumeFromFullyQualifiedPaths && this.FileName.Length >= 3 && this.FileName[1] == ':' && text[2] == '/')
						{
							goto Block_6;
						}
						if (this.FileName.Length >= 4 && text[0] == '/')
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_185;
					}
					break;
					IL_185:
					if (this.FileName.Length < 3 || text[0] != '.' || text[1] != '/')
					{
						goto IL_3B;
					}
					text2 = text.Substring(2);
					num = delegate0da.f0000d7(-2);
				}
			}
			IL_36:
			goto IL_3D;
			IL_3B:
			text2 = text;
			IL_3D:
			byte[] array = ZipEntry.ibm437.GetBytes(text2);
			string p = delegate0115.f000145(ZipEntry.ibm437, array, 0, array.Length);
			this._CommentBytes = null;
			if (!delegate0db.f0000d9(p, text2))
			{
				array = this._provisionalAlternateEncoding.GetBytes(text2);
				if (this._Comment != null && this._Comment.Length != 0)
				{
					this._CommentBytes = this._provisionalAlternateEncoding.GetBytes(this._Comment);
				}
				this._actualEncoding = this._provisionalAlternateEncoding;
				return array;
			}
			if (this._Comment == null || this._Comment.Length == 0)
			{
				this._actualEncoding = ZipEntry.ibm437;
				return array;
			}
			goto IL_1D4;
			Block_6:
			text2 = text.Substring(3);
			goto IL_3D;
			Block_9:
			int num2 = text.IndexOf('/', 2);
			if (num2 == -1)
			{
				throw new ArgumentException(c0000c0.m00000f("Åi(DÖ\bG_\u008c\u0014!^(ã%\u0006â¢\v\bY¶c\u008d2Î\a»vÊ\u0090\u0096iXj\u000eý­B\u0091Z\u0001±µýVÐX\u0095\u008cm²¤"));
			}
			text2 = text.Substring(num2 + 1);
			goto IL_3D;
			IL_1D4:
			Encoding encoding = this.GenerateCommentBytes();
			if (delegate0fc.f000119(encoding) == 437)
			{
				this._actualEncoding = ZipEntry.ibm437;
				return array;
			}
			this._actualEncoding = encoding;
			array = delegate0d7.f0000d2(encoding, text2);
			return array;
		}

		// Token: 0x06000462 RID: 1122 RVA: 0x0001BCD4 File Offset: 0x00019ED4
		[MethodImpl(MethodImplOptions.NoInlining)]
		private bool WantReadAgain()
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_8F;
					case 1:
						goto IL_AF;
					case 2:
						goto IL_54;
					case 3:
						if (this._UncompressedSize < 16L)
						{
							return false;
						}
						if (this._CompressionMethod == 0)
						{
							return false;
						}
						goto IL_8F;
					}
					break;
					IL_54:
					if (this._Source == ZipEntrySource.Stream && !this._sourceStream.CanSeek)
					{
						return false;
					}
					if (this._aesCrypto_forWrite != null)
					{
						num = delegate0da.f0000d7(-1);
						continue;
					}
					goto IL_D5;
					IL_8F:
					if (this.CompressionLevel == CompressionLevel.None)
					{
						return false;
					}
					if (this._CompressedSize < this._UncompressedSize)
					{
						return false;
					}
					goto IL_54;
				}
			}
			return false;
			IL_AF:
			if (this.CompressedSize - (long)this._aesCrypto_forWrite.SizeOfEncryptionMetadata <= this.UncompressedSize + 16L)
			{
				return false;
			}
			IL_D5:
			return this._zipCrypto_forWrite == null || this.CompressedSize - 12L > this.UncompressedSize;
		}

		// Token: 0x06000463 RID: 1123 RVA: 0x0001BDDC File Offset: 0x00019FDC
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void FigureCompressionMethodForWriting(int cycle)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						return;
					case 1:
						goto IL_D8;
					case 2:
						goto IL_36;
					case 3:
						if (cycle > 1)
						{
							goto Block_3;
						}
						if (this.IsDirectory)
						{
							this._CompressionMethod = 0;
							num = delegate0da.f0000d7(0);
							continue;
						}
						if (this._Source == ZipEntrySource.ZipFile)
						{
							return;
						}
						if (this._Source != ZipEntrySource.Stream)
						{
							goto IL_D8;
						}
						if (this._sourceStream != null)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_FE;
					}
					break;
				}
			}
			IL_36:
			if (!this._sourceStream.CanSeek)
			{
				goto IL_FE;
			}
			long length = this._sourceStream.Length;
			if (length == 0L)
			{
				this._CompressionMethod = 0;
				return;
			}
			goto IL_FE;
			Block_3:
			this._CompressionMethod = 0;
			return;
			IL_D8:
			if (this._Source == ZipEntrySource.FileSystem && SharedUtilities.GetFileLength(this.LocalFileName) == 0L)
			{
				this._CompressionMethod = 0;
				return;
			}
			IL_FE:
			if (this.SetCompression != null)
			{
				this.CompressionLevel = this.SetCompression(this.LocalFileName, this._FileNameInArchive);
			}
			this._CompressionMethod = ((this.CompressionLevel == CompressionLevel.None) ? 0 : 8);
		}

		// Token: 0x06000464 RID: 1124 RVA: 0x0001BF28 File Offset: 0x0001A128
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void WriteHeader(Stream p0, int cycle)
		{
			int i;
			byte[] array;
			int num2;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					IL_05:
					switch (num)
					{
					case 0:
						goto IL_392;
					case 1:
						goto IL_528;
					case 2:
					{
						if (this._presumeZip64)
						{
							for (i = 0; i < 8; i++)
							{
								array[num2++] = byte.MaxValue;
							}
						}
						else
						{
							array[num2++] = (byte)(this._CompressedSize & 255L);
							array[num2++] = (byte)((this._CompressedSize & 65280L) >> 8);
							array[num2++] = (byte)((this._CompressedSize & 16711680L) >> 16);
							array[num2++] = (byte)((this._CompressedSize & (long)((ulong)-16777216)) >> 24);
							array[num2++] = (byte)(this._UncompressedSize & 255L);
							array[num2++] = (byte)((this._UncompressedSize & 65280L) >> 8);
							array[num2++] = (byte)((this._UncompressedSize & 16711680L) >> 16);
							array[num2++] = (byte)((this._UncompressedSize & (long)((ulong)-16777216)) >> 24);
						}
						short num3;
						array[num2++] = (byte)(num3 & 255);
						array[num2++] = (byte)(((int)num3 & 65280) >> 8);
						this._Extra = this.ConstructExtraField(false);
						short num4 = (short)((this._Extra == null) ? 0 : this._Extra.Length);
						array[num2++] = (byte)(num4 & 255);
						array[num2++] = (byte)(((int)num4 & 65280) >> 8);
						byte[] array2;
						for (i = 0; i < array2.Length; i++)
						{
							if (num2 + i >= array.Length)
							{
								num = delegate0da.f0000d7(-1);
								goto IL_05;
							}
							array[num2 + i] = array2[i];
						}
						goto IL_528;
					}
					case 3:
					{
						CountingStream countingStream = p0 as CountingStream;
						this._future_ROLH = ((countingStream != null) ? countingStream.ComputedPosition : delegate0e3.f0000e5(p0));
						i = 0;
						num2 = 0;
						array = new byte[512];
						array[num2++] = 80;
						array[num2++] = 75;
						array[num2++] = 3;
						array[num2++] = 4;
						this._presumeZip64 = (this._container.Zip64 == Zip64Option.Always || (this._container.Zip64 == Zip64Option.AsNecessary && !delegate012e.f000167(p0)));
						short num5 = this._presumeZip64 ? 45 : 20;
						array[num2++] = (byte)(num5 & 255);
						array[num2++] = (byte)(((int)num5 & 65280) >> 8);
						byte[] array2 = this._GetEncodedFileNameBytes();
						short num3 = (short)array2.Length;
						if (this._Encryption == EncryptionAlgorithm.None)
						{
							this._BitField &= -2;
						}
						else
						{
							this._BitField |= 1;
						}
						if (this.ActualEncoding.CodePage == delegate0fc.f000119(delegate0d6.f0000ce()))
						{
							this._BitField |= 2048;
						}
						if (this.IsDirectory || cycle == 99)
						{
							this._BitField &= -9;
							this._BitField &= -2;
							this.Encryption = EncryptionAlgorithm.None;
							this.Password = null;
							num = delegate0da.f0000d7(0);
							continue;
						}
						if (!p0.CanSeek)
						{
							this._BitField |= 8;
							goto IL_392;
						}
						goto IL_392;
					}
					}
					break;
					IL_392:
					array[num2++] = (byte)(this._BitField & 255);
					array[num2++] = (byte)(((int)this._BitField & 65280) >> 8);
					if (this.__FileDataPosition == -1L)
					{
						this._CompressedSize = 0L;
						this._crcCalculated = false;
					}
					this.FigureCompressionMethodForWriting(cycle);
					array[num2++] = (byte)(this._CompressionMethod & 255);
					array[num2++] = (byte)(((int)this._CompressionMethod & 65280) >> 8);
					if (cycle == 99)
					{
						this.SetZip64Flags();
					}
					else if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
					{
						num2 -= 2;
						array[num2++] = 99;
						array[num2++] = 0;
					}
					this._TimeBlob = SharedUtilities.DateTimeToPacked(this.LastModified);
					array[num2++] = (byte)(this._TimeBlob & 255);
					array[num2++] = (byte)((this._TimeBlob & 65280) >> 8);
					array[num2++] = (byte)((this._TimeBlob & 16711680) >> 16);
					array[num2++] = (byte)(((long)this._TimeBlob & (long)((ulong)-16777216)) >> 24);
					array[num2++] = (byte)(this.f00004b & 255);
					array[num2++] = (byte)((this.f00004b & 65280) >> 8);
					array[num2++] = (byte)((this.f00004b & 16711680) >> 16);
					array[num2++] = (byte)(((long)this.f00004b & (long)((ulong)-16777216)) >> 24);
					num = delegate0da.f0000d7(-2);
				}
			}
			IL_528:
			num2 += i;
			if (this._Extra != null)
			{
				for (i = 0; i < this._Extra.Length; i++)
				{
					array[num2 + i] = this._Extra[i];
				}
				num2 += i;
			}
			this._LengthOfHeader = num2;
			ZipSegmentedStream zipSegmentedStream = p0 as ZipSegmentedStream;
			if (zipSegmentedStream != null)
			{
				zipSegmentedStream.ContiguousWrite = true;
				uint num6 = zipSegmentedStream.ComputeSegment(num2);
				if (num6 != zipSegmentedStream.CurrentSegment)
				{
					this._future_ROLH = 0L;
				}
				else
				{
					this._future_ROLH = delegate0e3.f0000e5(zipSegmentedStream);
				}
				this._diskNumber = num6;
			}
			if (this._container.Zip64 == Zip64Option.f000059 && (uint)this._RelativeOffsetOfLocalHeader >= 4294967295U)
			{
				throw new ZipException(c0000c0.m00000f("Þg+\u0017Ã\u001d\u0013@Å\u0006&Ef·9\u000fó¢\u0014\u000f]ä{ß0Ö\u001e¨r\u0098\u0086Î~R/\bë­\u0010\u0088x+\u008eÓÝ\u007fäsÚØZ¸®F\u007f¨\u0080ì0\u0094\u0095'T\u009bàñ.¤$\u0085í]\u0011\u0019rÖ\u008bµ%Ms$\u0087Nþz\u009d\u0089F]õ\u008a\u0012Ge\u009b8­'jDð\u009c|N±[$\u0014à\0_R\u008c\u001b _|ö#\u0004ó¬"));
			}
			p0.Write(array, 0, num2);
			if (zipSegmentedStream != null)
			{
				zipSegmentedStream.ContiguousWrite = false;
			}
			this._EntryHeader = new byte[num2];
			for (i = 0; i < num2; i++)
			{
				this._EntryHeader[i] = array[i];
			}
		}

		// Token: 0x06000465 RID: 1125 RVA: 0x0001C56C File Offset: 0x0001A76C
		[MethodImpl(MethodImplOptions.NoInlining)]
		private int FigureCrc32()
		{
			Stream stream;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_CB;
					case 1:
						goto IL_FC;
					case 2:
						goto IL_8B;
					case 3:
						if (this._crcCalculated)
						{
							goto IL_159;
						}
						stream = null;
						if (this._Source == ZipEntrySource.WriteDelegate)
						{
							CrcCalculatorStream crcCalculatorStream = new CrcCalculatorStream(Stream.Null);
							this._WriteDelegate(this.FileName, crcCalculatorStream);
							this.f00004b = crcCalculatorStream.Crc;
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_D0;
					}
					break;
				}
			}
			IL_8B:
			if (this._Source == ZipEntrySource.JitStream)
			{
				if (this._sourceStream == null)
				{
					this._sourceStream = this._OpenDelegate(this.FileName);
				}
				this.PrepSourceStream();
				stream = this._sourceStream;
				goto IL_11E;
			}
			goto IL_FC;
			IL_CB:
			goto IL_152;
			IL_D0:
			if (this._Source == ZipEntrySource.ZipFile)
			{
				goto IL_152;
			}
			if (this._Source == ZipEntrySource.Stream)
			{
				this.PrepSourceStream();
				stream = this._sourceStream;
				goto IL_11E;
			}
			goto IL_8B;
			IL_FC:
			if (this._Source != ZipEntrySource.ZipOutputStream)
			{
				stream = delegate0134.f000170(this.LocalFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
			}
			IL_11E:
			CRC32 crc = new CRC32();
			this.f00004b = crc.GetCrc32(stream);
			if (this._sourceStream == null)
			{
				delegate0c9.f00009a(stream);
				delegate0c9.f000097(stream);
			}
			IL_152:
			this._crcCalculated = true;
			IL_159:
			return this.f00004b;
		}

		// Token: 0x06000466 RID: 1126 RVA: 0x0001C6D8 File Offset: 0x0001A8D8
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void PrepSourceStream()
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_C4;
					case 1:
						goto IL_103;
					case 2:
						goto IL_36;
					case 3:
						if (this._sourceStream == null)
						{
							goto Block_2;
						}
						if (this._sourceStreamOriginalPosition != null)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						if (this._sourceStream.CanSeek)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						if (this.Encryption == EncryptionAlgorithm.PkzipWeak)
						{
							num = delegate0da.f0000d7(-1);
							continue;
						}
						return;
					}
					break;
				}
			}
			IL_36:
			this._sourceStreamOriginalPosition = new long?(this._sourceStream.Position);
			return;
			Block_2:
			throw new ZipException(delegate0101.f000127(c0000c0.m00000f("Åi(DÏ\aCBØR=Xzò,\n¶ë\u001dFC±vÁsØ\u0018¬7Ý\u008dÂoNjKã½]×\u0010"), this.FileName));
			IL_C4:
			this._sourceStream.Position = this._sourceStreamOriginalPosition.Value;
			return;
			IL_103:
			if (this._Source != ZipEntrySource.ZipFile && (this._BitField & 8) != 8)
			{
				throw new ZipException(c0000c0.m00000f("Øum\rÕI]XØR>C{ä$\u0005úçN\u0012BäoÞ6\u009e'\u0095Mñ³\u0096xY)\u001eáýT\u0099Q\u0003èúõ\u0019Ã\u0015\u009a\u0097wú³Ps§\u0084ü|\u0082Ð:N\u0082ûâ.£8\u0092¨i\u000f"));
			}
		}

		// Token: 0x06000467 RID: 1127 RVA: 0x0001C818 File Offset: 0x0001AA18
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void CopyMetaData(ZipEntry source)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						this._CompressedFileDataSize = source._CompressedFileDataSize;
						this._UncompressedSize = source._UncompressedSize;
						this._BitField = source._BitField;
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_EA;
					case 2:
						this._Source = source._Source;
						this._LastModified = source._LastModified;
						this._Mtime = source._Mtime;
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
						this.__FileDataPosition = source.__FileDataPosition;
						this.CompressionMethod = source.CompressionMethod;
						this._CompressionMethod_FromZipFile = source._CompressionMethod_FromZipFile;
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_EA:
			this._Atime = source._Atime;
			this._Ctime = source._Ctime;
			this._ntfsTimesAreSet = source._ntfsTimesAreSet;
			this._emitUnixTimes = source._emitUnixTimes;
			this._emitNtfsTimes = source._emitNtfsTimes;
		}

		// Token: 0x06000468 RID: 1128 RVA: 0x0001C94C File Offset: 0x0001AB4C
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void OnWriteBlock(long bytesXferred, long totalBytesToXfer)
		{
			if (this._container.ZipFile != null)
			{
				this._ioOperationCanceled = this._container.ZipFile.OnSaveBlock(this, bytesXferred, totalBytesToXfer);
			}
		}

		// Token: 0x06000469 RID: 1129 RVA: 0x0001C984 File Offset: 0x0001AB84
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void _WriteEntryData(Stream p0)
		{
			Stream p = null;
			long _FileDataPosition = -1L;
			_FileDataPosition = delegate0e3.f0000e5(p0);
			long num = this.SetInputAndFigureFileLength(ref p);
			CountingStream entryCounter;
			Stream encryptor;
			Stream deflater;
			CrcCalculatorStream crcCalculatorStream;
			this.PrepOutputStream(p0, num, out entryCounter, out encryptor, out deflater, out crcCalculatorStream);
			if (this._Source == ZipEntrySource.WriteDelegate)
			{
				this._WriteDelegate(this.FileName, crcCalculatorStream);
			}
			else
			{
				byte[] array = new byte[this.BufferSize];
				int p2;
				while ((p2 = SharedUtilities.ReadWithRetry(p, array, 0, array.Length, this.FileName)) != 0)
				{
					delegate0109.f000133(crcCalculatorStream, array, 0, p2);
					this.OnWriteBlock(crcCalculatorStream.TotalBytesSlurped, num);
					if (this._ioOperationCanceled)
					{
						break;
					}
				}
			}
			this.FinishOutputStream(p0, entryCounter, encryptor, deflater, crcCalculatorStream);
			if (this._ioOperationCanceled)
			{
				return;
			}
			this.__FileDataPosition = _FileDataPosition;
			this.PostProcessOutput(p0);
		}

		// Token: 0x0600046A RID: 1130 RVA: 0x0001CA50 File Offset: 0x0001AC50
		[MethodImpl(MethodImplOptions.NoInlining)]
		private long SetInputAndFigureFileLength(ref Stream input)
		{
			long result = -1L;
			if (this._Source == ZipEntrySource.Stream)
			{
				this.PrepSourceStream();
				input = this._sourceStream;
				result = this._sourceStream.Length;
			}
			else if (this._Source == ZipEntrySource.ZipFile)
			{
				string password = (this._Encryption_FromZipFile == EncryptionAlgorithm.None) ? null : (this._Password ?? this._container.Password);
				this._sourceStream = this.InternalOpenReader(password);
				this.PrepSourceStream();
				input = this._sourceStream;
				result = this._sourceStream.Length;
			}
			else if (this._Source == ZipEntrySource.JitStream)
			{
				if (this._sourceStream == null)
				{
					this._sourceStream = this._OpenDelegate(this.FileName);
				}
				this.PrepSourceStream();
				input = this._sourceStream;
				result = this._sourceStream.Length;
			}
			else if (this._Source == ZipEntrySource.FileSystem)
			{
				FileShare fileShare = FileShare.ReadWrite;
				fileShare |= FileShare.Delete;
				input = delegate0134.f000170(this.LocalFileName, FileMode.Open, FileAccess.Read, fileShare);
				result = delegate0e3.f0000e7(input);
			}
			return result;
		}

		// Token: 0x0600046B RID: 1131 RVA: 0x0001CB54 File Offset: 0x0001AD54
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void FinishOutputStream(Stream p0, CountingStream entryCounter, Stream encryptor, Stream deflater, CrcCalculatorStream output)
		{
			WinZipAesCipherStream winZipAesCipherStream;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_D8;
					case 1:
						goto IL_101;
					case 2:
						this._LengthOfTrailer = 0;
						this._UncompressedSize = output.TotalBytesSlurped;
						winZipAesCipherStream = (encryptor as WinZipAesCipherStream);
						if (winZipAesCipherStream != null && this._UncompressedSize > 0L)
						{
							num = delegate0da.f0000d7(-1);
							continue;
						}
						goto IL_11F;
					case 3:
						if (output == null)
						{
							return;
						}
						output.Close();
						if (deflater is DeflateStream)
						{
							delegate0c9.f00009a(deflater);
							num = delegate0da.f0000d7(0);
							continue;
						}
						if (deflater is ParallelDeflateOutputStream)
						{
							delegate0c9.f00009a(deflater);
							goto IL_D8;
						}
						goto IL_D8;
					}
					break;
					IL_D8:
					encryptor.Flush();
					delegate0c9.f00009a(encryptor);
					num = delegate0da.f0000d7(-2);
				}
			}
			return;
			IL_101:
			p0.Write(winZipAesCipherStream.FinalAuthentication, 0, 10);
			this._LengthOfTrailer += 10;
			IL_11F:
			this._CompressedFileDataSize = entryCounter.BytesWritten;
			this._CompressedSize = this._CompressedFileDataSize;
			this.f00004b = output.Crc;
			this.StoreRelativeOffset();
		}

		// Token: 0x0600046C RID: 1132 RVA: 0x0001CCAC File Offset: 0x0001AEAC
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void PostProcessOutput(Stream p0)
		{
			if (this._UncompressedSize == 0L && this._CompressedSize == 0L)
			{
				if (this._Source == ZipEntrySource.ZipOutputStream)
				{
					return;
				}
				if (this._Password != null)
				{
					int num = 0;
					if (this.Encryption == EncryptionAlgorithm.PkzipWeak)
					{
						num = 12;
					}
					else if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
					{
						num = this._aesCrypto_forWrite._Salt.Length + this._aesCrypto_forWrite.GeneratedPV.Length;
					}
					if (this._Source == ZipEntrySource.ZipOutputStream && !delegate012e.f000167(p0))
					{
						throw new ZipException(c0000c0.m00000f("Ëd?\v\u0086\vJCÉ\u0001n[zþ9\u0013óìBFHªyß*Î\u0003·xÖÃßs\u0017?\u001fý¡\0\u0091P\tèûôW\u008fF\u0091\u009dr¶¢Ysì\u008aëd\u0097\u0085'\u000e"));
					}
					if (this.Encryption != EncryptionAlgorithm.None)
					{
						delegate0149.f00018c(p0, (long)(-1 * num), SeekOrigin.Current);
						delegate0154.f0001a0(p0, delegate0e3.f0000e5(p0));
						this._LengthOfHeader -= num;
					}
					this._Password = null;
					this._BitField &= -2;
					int num2 = 6;
					this._EntryHeader[num2++] = (byte)(this._BitField & 255);
					this._EntryHeader[num2++] = (byte)(((int)this._BitField & 65280) >> 8);
				}
				this.CompressionMethod = CompressionMethod.None;
				this.Encryption = EncryptionAlgorithm.None;
			}
			else if (this._zipCrypto_forWrite != null || this._aesCrypto_forWrite != null)
			{
				if (this.Encryption == EncryptionAlgorithm.PkzipWeak)
				{
					this._CompressedSize += 12L;
				}
				else if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
				{
					this._CompressedSize += (long)this._aesCrypto_forWrite.SizeOfEncryptionMetadata;
				}
			}
			int num3 = 8;
			this._EntryHeader[num3++] = (byte)(this._CompressionMethod & 255);
			this._EntryHeader[num3++] = (byte)(((int)this._CompressionMethod & 65280) >> 8);
			num3 = 14;
			this._EntryHeader[num3++] = (byte)(this.f00004b & 255);
			this._EntryHeader[num3++] = (byte)((this.f00004b & 65280) >> 8);
			this._EntryHeader[num3++] = (byte)((this.f00004b & 16711680) >> 16);
			this._EntryHeader[num3++] = (byte)(((long)this.f00004b & (long)((ulong)-16777216)) >> 24);
			this.SetZip64Flags();
			short num4 = (short)((int)this._EntryHeader[26] + (int)this._EntryHeader[27] * 256);
			short num5 = (short)((int)this._EntryHeader[28] + (int)this._EntryHeader[29] * 256);
			if (this._OutputUsesZip64.Value)
			{
				this._EntryHeader[4] = 45;
				this._EntryHeader[5] = 0;
				for (int i = 0; i < 8; i++)
				{
					this._EntryHeader[num3++] = byte.MaxValue;
				}
				num3 = (int)(30 + num4);
				this._EntryHeader[num3++] = 1;
				this._EntryHeader[num3++] = 0;
				num3 += 2;
				delegate0fe.f000121(delegate0152.f00019e(this._UncompressedSize), 0, this._EntryHeader, num3, 8);
				num3 += 8;
				delegate0fe.f000121(delegate0152.f00019e(this._CompressedSize), 0, this._EntryHeader, num3, 8);
			}
			else
			{
				this._EntryHeader[4] = 20;
				this._EntryHeader[5] = 0;
				num3 = 18;
				this._EntryHeader[num3++] = (byte)(this._CompressedSize & 255L);
				this._EntryHeader[num3++] = (byte)((this._CompressedSize & 65280L) >> 8);
				this._EntryHeader[num3++] = (byte)((this._CompressedSize & 16711680L) >> 16);
				this._EntryHeader[num3++] = (byte)((this._CompressedSize & (long)((ulong)-16777216)) >> 24);
				this._EntryHeader[num3++] = (byte)(this._UncompressedSize & 255L);
				this._EntryHeader[num3++] = (byte)((this._UncompressedSize & 65280L) >> 8);
				this._EntryHeader[num3++] = (byte)((this._UncompressedSize & 16711680L) >> 16);
				this._EntryHeader[num3++] = (byte)((this._UncompressedSize & (long)((ulong)-16777216)) >> 24);
				if (num5 != 0)
				{
					num3 = (int)(30 + num4);
					short num6 = (short)((int)this._EntryHeader[num3 + 2] + (int)this._EntryHeader[num3 + 3] * 256);
					if (num6 == 16)
					{
						this._EntryHeader[num3++] = 153;
						this._EntryHeader[num3++] = 153;
					}
				}
			}
			if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
			{
				num3 = 8;
				this._EntryHeader[num3++] = 99;
				this._EntryHeader[num3++] = 0;
				num3 = (int)(30 + num4);
				do
				{
					ushort num7 = (ushort)((int)this._EntryHeader[num3] + (int)this._EntryHeader[num3 + 1] * 256);
					short num8 = (short)((int)this._EntryHeader[num3 + 2] + (int)this._EntryHeader[num3 + 3] * 256);
					if (num7 != 39169)
					{
						num3 += (int)(num8 + 4);
					}
					else
					{
						num3 += 9;
						this._EntryHeader[num3++] = (byte)(this._CompressionMethod & 255);
						this._EntryHeader[num3++] = (byte)((int)this._CompressionMethod & 65280);
					}
				}
				while (num3 < (int)(num5 - 30 - num4));
			}
			if ((this._BitField & 8) != 8 || (this._Source == ZipEntrySource.ZipOutputStream && delegate012e.f000167(p0)))
			{
				ZipSegmentedStream zipSegmentedStream = p0 as ZipSegmentedStream;
				if (zipSegmentedStream != null && this._diskNumber != zipSegmentedStream.CurrentSegment)
				{
					Stream p = ZipSegmentedStream.ForUpdate(this._container.ZipFile.Name, this._diskNumber);
					delegate0149.f00018c(p, this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
					delegate0109.f000133(p, this._EntryHeader, 0, this._EntryHeader.Length);
				}
				else
				{
					p0.Seek(this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
					delegate0109.f000133(p0, this._EntryHeader, 0, this._EntryHeader.Length);
					CountingStream countingStream = p0 as CountingStream;
					if (countingStream != null)
					{
						countingStream.Adjust((long)this._EntryHeader.Length);
					}
					p0.Seek(this._CompressedSize, SeekOrigin.Current);
				}
			}
			if ((this._BitField & 8) == 8 && !this.IsDirectory)
			{
				byte[] array = new byte[16 + (this._OutputUsesZip64.Value ? 8 : 0)];
				num3 = 0;
				delegate0fe.f000121(delegate0136.f000173(134695760), 0, array, num3, 4);
				num3 += 4;
				delegate0fe.f000121(delegate0136.f000173(this.f00004b), 0, array, num3, 4);
				num3 += 4;
				if (this._OutputUsesZip64.Value)
				{
					delegate0fe.f000121(delegate0152.f00019e(this._CompressedSize), 0, array, num3, 8);
					num3 += 8;
					delegate0fe.f000121(delegate0152.f00019e(this._UncompressedSize), 0, array, num3, 8);
					num3 += 8;
				}
				else
				{
					array[num3++] = (byte)(this._CompressedSize & 255L);
					array[num3++] = (byte)((this._CompressedSize & 65280L) >> 8);
					array[num3++] = (byte)((this._CompressedSize & 16711680L) >> 16);
					array[num3++] = (byte)((this._CompressedSize & (long)((ulong)-16777216)) >> 24);
					array[num3++] = (byte)(this._UncompressedSize & 255L);
					array[num3++] = (byte)((this._UncompressedSize & 65280L) >> 8);
					array[num3++] = (byte)((this._UncompressedSize & 16711680L) >> 16);
					array[num3++] = (byte)((this._UncompressedSize & (long)((ulong)-16777216)) >> 24);
				}
				p0.Write(array, 0, array.Length);
				this._LengthOfTrailer += array.Length;
			}
		}

		// Token: 0x0600046D RID: 1133 RVA: 0x0001D4E0 File Offset: 0x0001B6E0
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void SetZip64Flags()
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						if (this._container.Zip64 == Zip64Option.f000059)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_E6;
					case 1:
						goto IL_D6;
					case 2:
						if (this._entryRequiresZip64.Value)
						{
							num = delegate0da.f0000d7(-1);
							continue;
						}
						goto IL_E6;
					case 3:
						this._entryRequiresZip64 = new bool?(this._CompressedSize >= (long)((ulong)-1) || this._UncompressedSize >= (long)((ulong)-1) || this._RelativeOffsetOfLocalHeader >= (long)((ulong)-1));
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_D6:
			throw new ZipException(c0000c0.m00000f("Òn \u0014Ô\f@DÉ\u0016nCz·\u0018\tõí\u0003\u0016_¡iÞ6ÚW­~Â\u0086\u009a=X8L÷ëF\u0083[\u0019èðãZÇP\u0090\u008b9£¨P6¡\u0084æy\u008a\u0085>\0\u0084ïú{µbÀ\u008eg\f\u000fAÛ\u009eñ1i~5\u009dtñkÔ\u0093I\u0018¥­\u000eRZ\u0080<â3RBµ\u0086GJçh#\u0003\u0086\u0019AXÜ\u0017<Xq·\"\t¶ö\u0006\u0003\r\u009esÝ\u0015×\u001b»7Ñ\u008dÅiV$\u000fý£"));
			IL_E6:
			this._OutputUsesZip64 = new bool?(this._container.Zip64 == Zip64Option.Always || this._entryRequiresZip64.Value);
		}

		// Token: 0x0600046E RID: 1134 RVA: 0x0001D604 File Offset: 0x0001B804
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void PrepOutputStream(Stream p0, long streamLength, out CountingStream outputCounter, out Stream encryptor, out Stream deflater, out CrcCalculatorStream output)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						encryptor = this.MaybeApplyEncryption(outputCounter);
						deflater = this.MaybeApplyDeflation(encryptor, streamLength);
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_37;
					case 2:
						goto IL_36;
					case 3:
					{
						outputCounter = new CountingStream(p0);
						if (streamLength != 0L)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						Stream stream;
						deflater = (stream = outputCounter);
						encryptor = stream;
						num = delegate0da.f0000d7(-1);
						continue;
					}
					}
					break;
				}
			}
			IL_36:
			IL_37:
			output = new CrcCalculatorStream(deflater, true);
		}

		// Token: 0x0600046F RID: 1135 RVA: 0x0001D6D4 File Offset: 0x0001B8D4
		[MethodImpl(MethodImplOptions.NoInlining)]
		private Stream MaybeApplyDeflation(Stream p0, long streamLength)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						if (this._container.ParallelDeflateThreshold > 0L)
						{
							goto IL_CC;
						}
						goto IL_128;
					case 1:
						goto IL_128;
					case 2:
						goto IL_36;
					case 3:
						if (this._CompressionMethod != 8 || this.CompressionLevel == CompressionLevel.None)
						{
							return p0;
						}
						if (this._container.ParallelDeflateThreshold == 0L)
						{
							goto IL_CC;
						}
						if (streamLength > this._container.ParallelDeflateThreshold)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_128;
					}
					break;
					IL_CC:
					if (this._container.ParallelDeflater != null)
					{
						goto IL_51;
					}
					this._container.ParallelDeflater = new ParallelDeflateOutputStream(p0, this.CompressionLevel, this._container.Strategy, true);
					if (this._container.CodecBufferSize <= 0)
					{
						goto IL_51;
					}
					num = delegate0da.f0000d7(-2);
				}
			}
			IL_36:
			this._container.ParallelDeflater.BufferSize = this._container.CodecBufferSize;
			IL_51:
			ParallelDeflateOutputStream parallelDeflater = this._container.ParallelDeflater;
			parallelDeflater.Reset(p0);
			return parallelDeflater;
			IL_128:
			DeflateStream deflateStream = new DeflateStream(p0, CompressionMode.Compress, this.CompressionLevel, true);
			if (this._container.CodecBufferSize > 0)
			{
				deflateStream.BufferSize = this._container.CodecBufferSize;
			}
			deflateStream.Strategy = this._container.Strategy;
			return deflateStream;
		}

		// Token: 0x06000470 RID: 1136 RVA: 0x0001D850 File Offset: 0x0001BA50
		[MethodImpl(MethodImplOptions.NoInlining)]
		private Stream MaybeApplyEncryption(Stream p0)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						goto IL_80;
					case 1:
						goto IL_8E;
					case 2:
						goto IL_36;
					case 3:
						if (this.Encryption == EncryptionAlgorithm.PkzipWeak)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_36;
					}
					break;
					IL_36:
					if (this.Encryption == EncryptionAlgorithm.WinZipAes128)
					{
						goto IL_9A;
					}
					num = delegate0da.f0000d7(-1);
				}
			}
			IL_80:
			return new ZipCipherStream(p0, this._zipCrypto_forWrite, CryptoMode.Encrypt);
			IL_8E:
			if (this.Encryption != EncryptionAlgorithm.WinZipAes256)
			{
				return p0;
			}
			IL_9A:
			return new WinZipAesCipherStream(p0, this._aesCrypto_forWrite, CryptoMode.Encrypt);
		}

		// Token: 0x06000471 RID: 1137 RVA: 0x0001D908 File Offset: 0x0001BB08
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void OnZipErrorWhileSaving(Exception p0)
		{
			if (this._container.ZipFile != null)
			{
				this._ioOperationCanceled = this._container.ZipFile.OnZipErrorSaving(this, p0);
			}
		}

		// Token: 0x06000472 RID: 1138 RVA: 0x0001D940 File Offset: 0x0001BB40
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void Write(Stream p0)
		{
			if (this._Source == ZipEntrySource.ZipFile && !this._restreamRequiredOnSave)
			{
				this.CopyThroughOneEntry(p0);
				return;
			}
			if (this.IsDirectory)
			{
				this.WriteHeader(p0, 1);
				this.StoreRelativeOffset();
				this._entryRequiresZip64 = new bool?(this._RelativeOffsetOfLocalHeader >= (long)((ulong)-1));
				this._OutputUsesZip64 = new bool?(this._container.Zip64 == Zip64Option.Always || this._entryRequiresZip64.Value);
				ZipSegmentedStream zipSegmentedStream = p0 as ZipSegmentedStream;
				if (zipSegmentedStream != null)
				{
					this._diskNumber = zipSegmentedStream.CurrentSegment;
				}
			}
			else
			{
				bool flag = true;
				int num = 0;
				do
				{
					num++;
					this.WriteHeader(p0, num);
					this._EmitOne(p0);
					if (num <= 1)
					{
						if (p0.CanSeek)
						{
							flag = this.WantReadAgain();
							if (flag)
							{
								ZipSegmentedStream zipSegmentedStream2 = p0 as ZipSegmentedStream;
								if (zipSegmentedStream2 != null)
								{
									zipSegmentedStream2.TruncateBackward(this._diskNumber, this._RelativeOffsetOfLocalHeader);
								}
								else
								{
									p0.Seek(this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
								}
								p0.SetLength(delegate0e3.f0000e5(p0));
								CountingStream countingStream = p0 as CountingStream;
								if (countingStream != null)
								{
									countingStream.Adjust(this._TotalEntrySize);
								}
							}
						}
					}
				}
				while (flag);
				this._skippedDuringSave = false;
			}
		}

		// Token: 0x06000473 RID: 1139 RVA: 0x0001DAA4 File Offset: 0x0001BCA4
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void StoreRelativeOffset()
		{
			this._RelativeOffsetOfLocalHeader = this._future_ROLH;
		}

		// Token: 0x06000474 RID: 1140 RVA: 0x0001DAC0 File Offset: 0x0001BCC0
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void NotifySaveComplete()
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
						this._CompressionMethod_FromZipFile = this._CompressionMethod;
						num = delegate0da.f0000d7(-2);
						continue;
					case 1:
						goto IL_9D;
					case 2:
						this._restreamRequiredOnSave = false;
						num = delegate0da.f0000d7(-1);
						continue;
					case 3:
						this._Encryption_FromZipFile = this._Encryption;
						num = delegate0da.f0000d7(0);
						continue;
					}
					break;
				}
			}
			IL_9D:
			this._metadataChanged = false;
			this._Source = ZipEntrySource.None;
		}

		// Token: 0x06000475 RID: 1141 RVA: 0x0001DB78 File Offset: 0x0001BD78
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void _EmitOne(Stream outstream)
		{
			this.WriteSecurityMetadata(outstream);
			this._WriteEntryData(outstream);
			this._TotalEntrySize = (long)this._LengthOfHeader + this._CompressedFileDataSize + (long)this._LengthOfTrailer;
		}

		// Token: 0x06000476 RID: 1142 RVA: 0x0001DBB0 File Offset: 0x0001BDB0
		[MethodImpl(MethodImplOptions.NoInlining)]
		internal void WriteSecurityMetadata(Stream outstream)
		{
			byte[] array2;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					byte[] array;
					switch (num)
					{
					case 0:
						return;
					case 1:
						goto IL_15C;
					case 2:
						this._TimeBlob = SharedUtilities.DateTimeToPacked(this.LastModified);
						array[11] = (byte)(this._TimeBlob >> 8 & 255);
						goto IL_7A;
					case 3:
					{
						string password = this._Password;
						if (this._Source == ZipEntrySource.ZipFile && password == null)
						{
							password = this._container.Password;
						}
						if (password == null)
						{
							this._zipCrypto_forWrite = null;
							this._aesCrypto_forWrite = null;
							num = delegate0da.f0000d7(0);
							continue;
						}
						if (this.Encryption != EncryptionAlgorithm.PkzipWeak)
						{
							goto IL_16D;
						}
						this._zipCrypto_forWrite = ZipCrypto.ForWrite(password);
						Random p = new Random();
						array = new byte[12];
						delegate0143.f000184(p, array);
						if ((this._BitField & 8) == 8)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						this.FigureCrc32();
						array[11] = (byte)(this.f00004b >> 24 & 255);
						goto IL_7A;
					}
					}
					break;
					IL_7A:
					array2 = this._zipCrypto_forWrite.EncryptMessage(array, array.Length);
					delegate0109.f000133(outstream, array2, 0, array2.Length);
					num = delegate0da.f0000d7(-1);
				}
			}
			return;
			IL_15C:
			this._LengthOfHeader += array2.Length;
			return;
			IL_16D:
			if (this.Encryption == EncryptionAlgorithm.WinZipAes128 || this.Encryption == EncryptionAlgorithm.WinZipAes256)
			{
				int keyStrengthInBits = ZipEntry.GetKeyStrengthInBits(this.Encryption);
				string password;
				this._aesCrypto_forWrite = WinZipAesCrypto.Generate(password, keyStrengthInBits);
				delegate0109.f000133(outstream, this._aesCrypto_forWrite.Salt, 0, this._aesCrypto_forWrite._Salt.Length);
				delegate0109.f000133(outstream, this._aesCrypto_forWrite.GeneratedPV, 0, this._aesCrypto_forWrite.GeneratedPV.Length);
				this._LengthOfHeader += this._aesCrypto_forWrite._Salt.Length + this._aesCrypto_forWrite.GeneratedPV.Length;
			}
		}

		// Token: 0x06000477 RID: 1143 RVA: 0x0001DDD0 File Offset: 0x0001BFD0
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void CopyThroughOneEntry(Stream outstream)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					bool flag;
					switch (num)
					{
					case 0:
						if (this._InputUsesZip64 && this._container.UseZip64WhenSaving == Zip64Option.f000059)
						{
							goto IL_49;
						}
						if (!this._InputUsesZip64)
						{
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_F1;
					case 1:
						goto IL_EC;
					case 2:
						flag = (this._container.UseZip64WhenSaving == Zip64Option.Always);
						goto IL_4A;
					case 3:
						if (this.LengthOfHeader == 0)
						{
							goto Block_2;
						}
						if (!this._metadataChanged)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_49;
					}
					break;
					IL_4A:
					bool flag2 = flag;
					if (flag2)
					{
						this.CopyThroughWithRecompute(outstream);
						num = delegate0da.f0000d7(-1);
						continue;
					}
					goto IL_F1;
					IL_49:
					flag = true;
					goto IL_4A;
				}
			}
			Block_2:
			throw new BadStateException(c0000c0.m00000f("Ó`)DÎ\fRSÉ\0n@mù*\u0013þ¬"));
			IL_EC:
			goto IL_F8;
			IL_F1:
			this.CopyThroughWithNoChange(outstream);
			IL_F8:
			this._entryRequiresZip64 = new bool?(this._CompressedSize >= (long)((ulong)-1) || this._UncompressedSize >= (long)((ulong)-1) || this._RelativeOffsetOfLocalHeader >= (long)((ulong)-1));
			this._OutputUsesZip64 = new bool?(this._container.Zip64 == Zip64Option.Always || this._entryRequiresZip64.Value);
		}

		// Token: 0x06000478 RID: 1144 RVA: 0x0001DF3C File Offset: 0x0001C13C
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void CopyThroughWithRecompute(Stream outstream)
		{
			CountingStream countingStream;
			int num5;
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					switch (num)
					{
					case 0:
					{
						long num2;
						while (num2 > 0L)
						{
							byte[] array;
							int num3 = (num2 > (long)array.Length) ? array.Length : ((int)num2);
							int num4 = delegate0144.f000185(countingStream, array, 0, num3);
							delegate0109.f000133(outstream, array, 0, num4);
							num2 -= (long)num4;
							this.OnWriteBlock(countingStream.BytesRead, this._CompressedSize);
							if (this._ioOperationCanceled)
							{
								break;
							}
						}
						if ((this._BitField & 8) != 8)
						{
							goto IL_2BB;
						}
						num5 = 16;
						if (this._InputUsesZip64)
						{
							num5 += 8;
							num = delegate0da.f0000d7(-2);
							continue;
						}
						goto IL_36;
					}
					case 1:
						goto IL_22D;
					case 2:
						goto IL_36;
					case 3:
					{
						byte[] array = new byte[this.BufferSize];
						countingStream = new CountingStream(this.ArchiveStream);
						long relativeOffsetOfLocalHeader = this._RelativeOffsetOfLocalHeader;
						int lengthOfHeader = this.LengthOfHeader;
						this.WriteHeader(outstream, 0);
						this.StoreRelativeOffset();
						if (!this.FileName.EndsWith(c0000c0.m00000f("¾")))
						{
							long num6 = relativeOffsetOfLocalHeader + (long)lengthOfHeader;
							int num3 = ZipEntry.GetLengthOfCryptoHeaderBytes(this._Encryption_FromZipFile);
							num6 -= (long)num3;
							this._LengthOfHeader += num3;
							delegate0149.f00018c(countingStream, num6, SeekOrigin.Begin);
							long num2 = this._CompressedSize;
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_2BB;
					}
					}
					break;
				}
			}
			IL_36:
			byte[] array2 = new byte[num5];
			delegate0144.f000185(countingStream, array2, 0, num5);
			if (this._InputUsesZip64 && this._container.UseZip64WhenSaving == Zip64Option.f000059)
			{
				delegate0109.f000133(outstream, array2, 0, 8);
				if (this._CompressedSize > (long)((ulong)-1))
				{
					throw new InvalidOperationException(c0000c0.m00000f("ËH\u001dR\u0092IZD\u008c\0+]}þ?\u0002ò"));
				}
				outstream.Write(array2, 8, 4);
				if (this._UncompressedSize > (long)((ulong)-1))
				{
					throw new InvalidOperationException(c0000c0.m00000f("ËH\u001dR\u0092IZD\u008c\0+]}þ?\u0002ò"));
				}
				outstream.Write(array2, 16, 4);
				this._LengthOfTrailer -= 8;
				goto IL_2BB;
			}
			IL_22D:
			if (!this._InputUsesZip64 && this._container.UseZip64WhenSaving == Zip64Option.Always)
			{
				byte[] p = new byte[4];
				delegate0109.f000133(outstream, array2, 0, 8);
				delegate0109.f000133(outstream, array2, 8, 4);
				delegate0109.f000133(outstream, p, 0, 4);
				delegate0109.f000133(outstream, array2, 12, 4);
				delegate0109.f000133(outstream, p, 0, 4);
				this._LengthOfTrailer += 8;
			}
			else
			{
				outstream.Write(array2, 0, num5);
			}
			IL_2BB:
			this._TotalEntrySize = (long)this._LengthOfHeader + this._CompressedFileDataSize + (long)this._LengthOfTrailer;
		}

		// Token: 0x06000479 RID: 1145 RVA: 0x0001E220 File Offset: 0x0001C420
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void CopyThroughWithNoChange(Stream outstream)
		{
			for (;;)
			{
				int num = delegate0da.f0000d7(-3);
				for (;;)
				{
					byte[] array;
					int num2;
					long num3;
					CountingStream countingStream;
					switch (num)
					{
					case 0:
						this._TotalEntrySize = (long)this._LengthOfHeader + this._CompressedFileDataSize + (long)this._LengthOfTrailer;
						goto IL_E8;
					case 1:
						outstream.Write(array, 0, num2);
						num3 -= (long)num2;
						this.OnWriteBlock(countingStream.BytesRead, this._TotalEntrySize);
						if (this._ioOperationCanceled)
						{
							return;
						}
						goto IL_15E;
					case 2:
						goto IL_15E;
					case 3:
						array = new byte[this.BufferSize];
						countingStream = new CountingStream(this.ArchiveStream);
						delegate0149.f00018c(countingStream, this._RelativeOffsetOfLocalHeader, SeekOrigin.Begin);
						if (this._TotalEntrySize == 0L)
						{
							num = delegate0da.f0000d7(0);
							continue;
						}
						goto IL_E8;
					}
					break;
					IL_15E:
					if (num3 <= 0L)
					{
						return;
					}
					int p = (num3 > (long)array.Length) ? array.Length : ((int)num3);
					num2 = delegate0144.f000185(countingStream, array, 0, p);
					num = delegate0da.f0000d7(-1);
					continue;
					IL_E8:
					CountingStream countingStream2 = outstream as CountingStream;
					this._RelativeOffsetOfLocalHeader = ((countingStream2 != null) ? countingStream2.ComputedPosition : delegate0e3.f0000e5(outstream));
					num3 = this._TotalEntrySize;
					num = delegate0da.f0000d7(-2);
				}
			}
		}

		// Token: 0x0600047A RID: 1146 RVA: 0x0001E398 File Offset: 0x0001C598
		[Conditional("Trace")]
		[MethodImpl(MethodImplOptions.NoInlining)]
		private void TraceWriteLine(string format, params object[] varParams)
		{
			delegate0e6.f0000f4(this._outputLock);
			int num = delegate0fc.f000118(delegate010f.f00013e());
			delegate0146.f000188(num % 8 + ConsoleColor.DarkGray);
			delegate0147.f000189(c0000c0.m00000f("ê1wT\u0096YN\u0017ö\u001b>ifã?\u001e¸Õ\u001c\u000fY¡:"), num);
			delegate0138.f000175(format, varParams);
			delegate0148.f00018b();
		}

		// Token: 0x0600047B RID: 1147 RVA: 0x0001E410 File Offset: 0x0001C610
		// Note: this type is marked as 'beforefieldinit'.
		static ZipEntry()
		{
			c0000c0.Initialize();
			c0000c0.PostInitialize();
			ZipEntry.ibm437 = delegate0c7.f000090(c0000c0.m00000f("ØC\0P\u0095^"));
			ZipEntry._unixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
			ZipEntry._win32Epoch = delegate0151.f00019d(0L);
			ZipEntry._zeroHour = new DateTime(1, 1, 1, 0, 0, 0, DateTimeKind.Utc);
		}

		// Token: 0x04000188 RID: 392
		private short _VersionMadeBy;

		// Token: 0x04000189 RID: 393
		private short _InternalFileAttrs;

		// Token: 0x0400018A RID: 394
		private int _ExternalFileAttrs;

		// Token: 0x0400018B RID: 395
		private short _filenameLength;

		// Token: 0x0400018C RID: 396
		private short _extraFieldLength;

		// Token: 0x0400018D RID: 397
		private short _commentLength;

		// Token: 0x0400018E RID: 398
		private ZipCrypto _zipCrypto_forExtract;

		// Token: 0x0400018F RID: 399
		private ZipCrypto _zipCrypto_forWrite;

		// Token: 0x04000190 RID: 400
		private WinZipAesCrypto _aesCrypto_forExtract;

		// Token: 0x04000191 RID: 401
		private WinZipAesCrypto _aesCrypto_forWrite;

		// Token: 0x04000192 RID: 402
		private short _WinZipAesMethod;

		// Token: 0x04000193 RID: 403
		internal DateTime _LastModified;

		// Token: 0x04000194 RID: 404
		private DateTime _Mtime;

		// Token: 0x04000195 RID: 405
		private DateTime _Atime;

		// Token: 0x04000196 RID: 406
		private DateTime _Ctime;

		// Token: 0x04000197 RID: 407
		private bool _ntfsTimesAreSet;

		// Token: 0x04000198 RID: 408
		private bool _emitNtfsTimes = true;

		// Token: 0x04000199 RID: 409
		private bool _emitUnixTimes;

		// Token: 0x0400019A RID: 410
		private bool _TrimVolumeFromFullyQualifiedPaths = true;

		// Token: 0x0400019B RID: 411
		internal string _LocalFileName;

		// Token: 0x0400019C RID: 412
		private string _FileNameInArchive;

		// Token: 0x0400019D RID: 413
		internal short _VersionNeeded;

		// Token: 0x0400019E RID: 414
		internal short _BitField;

		// Token: 0x0400019F RID: 415
		internal short _CompressionMethod;

		// Token: 0x040001A0 RID: 416
		private short _CompressionMethod_FromZipFile;

		// Token: 0x040001A1 RID: 417
		private CompressionLevel _CompressionLevel;

		// Token: 0x040001A2 RID: 418
		internal string _Comment;

		// Token: 0x040001A3 RID: 419
		private bool _IsDirectory;

		// Token: 0x040001A4 RID: 420
		private byte[] _CommentBytes;

		// Token: 0x040001A5 RID: 421
		internal long _CompressedSize;

		// Token: 0x040001A6 RID: 422
		internal long _CompressedFileDataSize;

		// Token: 0x040001A7 RID: 423
		internal long _UncompressedSize;

		// Token: 0x040001A8 RID: 424
		internal int _TimeBlob;

		// Token: 0x040001A9 RID: 425
		private bool _crcCalculated;

		// Token: 0x040001AA RID: 426
		internal int f00004b;

		// Token: 0x040001AB RID: 427
		internal byte[] _Extra;

		// Token: 0x040001AC RID: 428
		private bool _metadataChanged;

		// Token: 0x040001AD RID: 429
		private bool _restreamRequiredOnSave;

		// Token: 0x040001AE RID: 430
		private bool _sourceIsEncrypted;

		// Token: 0x040001AF RID: 431
		private bool _skippedDuringSave;

		// Token: 0x040001B0 RID: 432
		private uint _diskNumber;

		// Token: 0x040001B1 RID: 433
		private static Encoding ibm437;

		// Token: 0x040001B2 RID: 434
		private Encoding _provisionalAlternateEncoding = delegate0c7.f000090(c0000c0.m00000f("ØC\0P\u0095^"));

		// Token: 0x040001B3 RID: 435
		private Encoding _actualEncoding;

		// Token: 0x040001B4 RID: 436
		internal ZipContainer _container;

		// Token: 0x040001B5 RID: 437
		internal long __FileDataPosition = -1L;

		// Token: 0x040001B6 RID: 438
		private byte[] _EntryHeader;

		// Token: 0x040001B7 RID: 439
		internal long _RelativeOffsetOfLocalHeader;

		// Token: 0x040001B8 RID: 440
		private long _future_ROLH;

		// Token: 0x040001B9 RID: 441
		private long _TotalEntrySize;

		// Token: 0x040001BA RID: 442
		internal int _LengthOfHeader;

		// Token: 0x040001BB RID: 443
		internal int _LengthOfTrailer;

		// Token: 0x040001BC RID: 444
		internal bool _InputUsesZip64;

		// Token: 0x040001BD RID: 445
		private uint _UnsupportedAlgorithmId;

		// Token: 0x040001BE RID: 446
		internal string _Password;

		// Token: 0x040001BF RID: 447
		internal ZipEntrySource _Source;

		// Token: 0x040001C0 RID: 448
		internal EncryptionAlgorithm _Encryption;

		// Token: 0x040001C1 RID: 449
		internal EncryptionAlgorithm _Encryption_FromZipFile;

		// Token: 0x040001C2 RID: 450
		internal byte[] _WeakEncryptionHeader;

		// Token: 0x040001C3 RID: 451
		internal Stream _archiveStream;

		// Token: 0x040001C4 RID: 452
		private Stream _sourceStream;

		// Token: 0x040001C5 RID: 453
		private long? _sourceStreamOriginalPosition;

		// Token: 0x040001C6 RID: 454
		private bool _sourceWasJitProvided;

		// Token: 0x040001C7 RID: 455
		private bool _ioOperationCanceled;

		// Token: 0x040001C8 RID: 456
		private bool _presumeZip64;

		// Token: 0x040001C9 RID: 457
		private bool? _entryRequiresZip64;

		// Token: 0x040001CA RID: 458
		private bool? _OutputUsesZip64;

		// Token: 0x040001CB RID: 459
		private bool _IsText;

		// Token: 0x040001CC RID: 460
		private ZipEntryTimestamp _timestamp;

		// Token: 0x040001CD RID: 461
		private static DateTime _unixEpoch;

		// Token: 0x040001CE RID: 462
		private static DateTime _win32Epoch;

		// Token: 0x040001CF RID: 463
		private static DateTime _zeroHour;

		// Token: 0x040001D0 RID: 464
		private WriteDelegate _WriteDelegate;

		// Token: 0x040001D1 RID: 465
		private OpenDelegate _OpenDelegate;

		// Token: 0x040001D2 RID: 466
		private CloseDelegate _CloseDelegate;

		// Token: 0x040001D3 RID: 467
		private Stream _inputDecryptorStream;

		// Token: 0x040001D4 RID: 468
		private int _readExtraDepth;

		// Token: 0x040001D5 RID: 469
		private object _outputLock = new object();

		// Token: 0x040001D6 RID: 470
		[CompilerGenerated]
		private ExtractExistingFileAction f00004c;

		// Token: 0x040001D7 RID: 471
		[CompilerGenerated]
		private ZipErrorAction f00004d;

		// Token: 0x040001D8 RID: 472
		[CompilerGenerated]
		private SetCompressionCallback f00004e;
	}
}
